#!/usr/bin/bash
# Enhanced WSI (Whisper Speech Input) Script
# Speech-to-text orchestrator for GNOME extension
# Based on: https://github.com/QuantiusBenignus/blurt
# Enhanced with comprehensive debugging and error handling

#============================================================================
# USER CONFIGURATION
#============================================================================
TEMPD='/dev/shm'
ramf="$TEMPD/wfile-$USER"
WHISPERFILE="faster-whisper-transcribe"
model="$HOME/.local/share/ggml-base.en.bin"
NTHR=$(( $(getconf _NPROCESSORS_ONLN) / 2 ))
CLIPBOARD=false
WHOST="127.0.0.1"
WPORT="58080"

#============================================================================
# LOG FILE CONFIGURATION
#============================================================================
LOG_DIR="$HOME/.local/share/speech-to-text"
LOG_FILE="$LOG_DIR/debug.log"
MAX_LOG_SIZE=1048576  # 1MB - rotate when exceeded

#============================================================================
# RUNTIME VARIABLES
#============================================================================
DEBUG=false
VERBOSE=false
IPnPORT=""

#============================================================================
# DBUS CONFIGURATION
#============================================================================
DBUS_PATH="/org/fedoradesktop/SpeechToText"
DBUS_INTERFACE="org.fedoradesktop.SpeechToText"

#============================================================================
# LOGGING FUNCTIONS
#============================================================================

ensure_log_dir() {
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
    fi

    # Rotate log if too large
    if [ -f "$LOG_FILE" ] && [ "$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)" -gt "$MAX_LOG_SIZE" ]; then
        mv "$LOG_FILE" "${LOG_FILE}.old"
    fi
}

log_to_file() {
    if [ "$DEBUG" = true ] || [ "$VERBOSE" = true ]; then
        ensure_log_dir
        echo "[$(date '+%Y-%m-%dT%H:%M:%S')] [WSI] $*" >> "$LOG_FILE"
    fi
}

log() {
    echo "[WSI] $*" >&2
    log_to_file "$*"
}

log_debug() {
    if [ "$DEBUG" = true ] || [ "$VERBOSE" = true ]; then
        echo "[DEBUG] $*" >&2
        log_to_file "[DEBUG] $*"
    fi
}

log_error() {
    echo "[ERROR] $*" >&2
    log_to_file "[ERROR] $*"

    # Send error signal for extension
    gdbus emit --session \
        --object-path "$DBUS_PATH" \
        --signal "${DBUS_INTERFACE}.Error" \
        "$*" 2>/dev/null &
}

#============================================================================
# NOTIFICATION AND DBUS SIGNALING
#============================================================================

notify_state() {
    local state="$1"
    local message="$2"
    local icon="${3:-audio-input-microphone}"

    log_debug "State: $state - $message"

    # Send DBus signal for extension icon state
    gdbus emit --session \
        --object-path "$DBUS_PATH" \
        --signal "${DBUS_INTERFACE}.StateChanged" \
        "$state" 2>/dev/null &

    # Send notification with stack tag for replacement
    notify-send -i "$icon" \
        -h "int:transient:1" \
        -h "string:x-dunst-stack-tag:speech-to-text" \
        "Speech to Text" "$message"
}

#============================================================================
# UTILITY FUNCTIONS
#============================================================================

print_banner() {
    cat >&2 <<'EOF'
┌─────────────────────────────────────────────────────────────────┐
│  WSI - Whisper Speech Input v2.0 (Enhanced)                    │
│  Speech-to-text orchestrator for GNOME extension               │
└─────────────────────────────────────────────────────────────────┘
EOF
}

check_command() {
    local cmd="$1"
    local package="$2"
    local purpose="$3"

    if command -v "$cmd" &>/dev/null; then
        local version=""
        case "$cmd" in
            sox)
                version=$(sox --version 2>&1 | head -1)
                ;;
            curl)
                version=$(curl --version 2>&1 | head -1)
                ;;
            *)
                version="(installed)"
                ;;
        esac
        log_debug "  $cmd: $version"
        return 0
    else
        log_error "  $cmd: NOT FOUND"
        log_error "    Purpose: $purpose"
        log_error "    Install: sudo dnf install $package"
        return 1
    fi
}

check_dependencies() {
    log_debug "Checking dependencies..."
    local failed=0

    check_command "sox" "sox" "Audio recording and silence detection" || ((failed++))
    check_command "curl" "curl" "HTTP requests to whisper.cpp server" || ((failed++))

    local wm="${XDG_SESSION_TYPE:-unknown}"
    log_debug "Window manager: $wm"

    if [[ "$wm" == "wayland" ]]; then
        check_command "wl-copy" "wl-clipboard" "Clipboard management (Wayland)" || ((failed++))
    elif [[ "$wm" == "x11" ]]; then
        check_command "xsel" "xsel" "Clipboard management (X11)" || ((failed++))
    else
        log_error "Unknown window manager: $wm"
        ((failed++))
    fi

    if command -v "$WHISPERFILE" &>/dev/null; then
        local whisperfile_path=$(command -v "$WHISPERFILE")
        log_debug "  $WHISPERFILE: $whisperfile_path"
    else
        log_error "  $WHISPERFILE: NOT FOUND in PATH"
        ((failed++))
    fi

    if [ -d "$TEMPD" ] && [ -w "$TEMPD" ]; then
        log_debug "  Temp directory: $TEMPD (writable)"
    else
        log_error "  Temp directory: $TEMPD (not writable)"
        ((failed++))
    fi

    if [ $failed -gt 0 ]; then
        log_error "Dependency check failed: $failed errors found"
        return 1
    fi

    log_debug "All dependencies satisfied"
    return 0
}

print_config() {
    cat >&2 <<EOF
Configuration:
  Temp directory:     $TEMPD
  Temp audio file:    $ramf
  Whisperfile:        $WHISPERFILE ($(command -v "$WHISPERFILE" 2>/dev/null || echo "NOT FOUND"))
  Processing threads: $NTHR
  Clipboard mode:     $([ "$CLIPBOARD" = true ] && echo "CLIPBOARD" || echo "PRIMARY")
  Window manager:     ${XDG_SESSION_TYPE:-unknown}
  Log file:           $LOG_FILE
EOF
}

usage() {
    cat >&2 <<'EOF'
Usage: wsi [OPTIONS]

Options:
  -c, --clipboard     Use CLIPBOARD instead of PRIMARY selection
  -n, --netapi        Use whisper.cpp server (host:port from config)
  -d, --debug         Enable debug mode (verbose output + dependency checks)
  -v, --verbose       Enable verbose output only
  -h, --help          Show this help message

  IP:PORT             Use whisper.cpp server at specific address

Examples:
  wsi                 # Record speech and transcribe locally
  wsi -d              # Debug mode with full diagnostics
  wsi -c              # Use CLIPBOARD instead of PRIMARY
  wsi server.local:8080  # Use remote whisper.cpp server
EOF
}

#============================================================================
# COMMAND LINE ARGUMENT PARSING
#============================================================================

while [ $# -gt 0 ]; do
    case "$1" in
        -c|--clipboard)
            CLIPBOARD=true
            log_debug "Clipboard mode: CLIPBOARD"
            shift
            ;;
        -d|--debug)
            DEBUG=true
            VERBOSE=true
            log_debug "Debug mode enabled"
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            log_debug "Verbose mode enabled"
            shift
            ;;
        -n|--netapi)
            IPnPORT="$WHOST:$WPORT"
            if [[ "$(curl -s -f -o /dev/null -w '%{http_code}' "$IPnPORT" 2>/dev/null)" != "200" ]]; then
                log_error "Can't connect to whisper.cpp server at $IPnPORT"
                exit 1
            fi
            log_debug "Using whisper.cpp server: $IPnPORT"
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            IPnPORT="$1"
            if [[ "$(curl -s -f -o /dev/null -w '%{http_code}' "$IPnPORT" 2>/dev/null)" != "200" ]]; then
                log_error "Can't connect to whisper.cpp server at $IPnPORT"
                exit 1
            fi
            log_debug "Using whisper.cpp server: $IPnPORT"
            shift
            ;;
    esac
done

#============================================================================
# DEBUG MODE INITIALIZATION
#============================================================================

if [ "$DEBUG" = true ]; then
    print_banner
    print_config
    echo "" >&2
    check_dependencies || exit 1
    echo "" >&2
    log "Starting speech recording with full debugging..."
fi

#============================================================================
# ERROR TRAP HANDLER
#============================================================================

trap_handler() {
    local exit_code=$?
    local line_no=$1
    local command="$BASH_COMMAND"

    log_error "Script failed at line $line_no: $command (exit code: $exit_code)"

    # Send error state via DBus
    notify_state "ERROR" "Script error (see log)"

    exit $exit_code
}

# Enable trap for debug mode
if [ "$DEBUG" = true ]; then
    trap 'trap_handler $LINENO' ERR
fi

#============================================================================
# FAIL FAST
#============================================================================
set -e

#============================================================================
# SPEECH RECORDING
#============================================================================

log_debug "Preparing microphone..."

# Warm up sox/microphone with a short dummy recording
rec -q -t wav /dev/null trim 0 0.1 2>/dev/null || true

log_debug "Ready! Speak now..."

# Notify user that recording has started
notify_state "RECORDING" "Recording... (speak now)"

# Record audio with silence detection
# - Record at 44100Hz (hardware native rate)
# - silence 1 0.1 0.1%: Start recording after 0.1s above 0.1% threshold (very sensitive)
# - 1 2.0 0.5%: Stop after 2.0 seconds below 0.5% threshold
# - trim 0 30: Maximum 30 seconds (safety limit)

if [ "$DEBUG" = true ]; then
    rec -q -r 44100 -c 2 -t wav "$ramf" silence 1 0.1 0.1% 1 2.0 0.5% trim 0 30
else
    rec -q -r 44100 -c 2 -t wav "$ramf" silence 1 0.1 0.1% 1 2.0 0.5% trim 0 30 2>/dev/null
fi

log_debug "Recording complete: $ramf"

if [ -f "$ramf" ]; then
    size=$(du -h "$ramf" 2>/dev/null | cut -f1)
    log_debug "Audio file size: $size"
else
    log_error "Audio file not created: $ramf"
    notify_state "ERROR" "Recording failed"
    exit 1
fi

# Resample from 44100Hz to 16000Hz (whisper requirement)
log_debug "Resampling audio from 44100Hz to 16000Hz..."

if [ "$DEBUG" = true ]; then
    sox "$ramf" "${ramf}.resampled.wav" rate 16k
else
    sox "$ramf" "${ramf}.resampled.wav" rate 16k 2>/dev/null
fi
mv "${ramf}.resampled.wav" "$ramf"

# Check audio duration and pad if needed (whisper requires min 1 second)
audio_duration=$(soxi -D "$ramf" 2>/dev/null | cut -d. -f1)
log_debug "Audio duration: ${audio_duration}s"

if [ -n "$audio_duration" ] && [ "$audio_duration" -lt 1 ]; then
    log_debug "Audio too short, padding to 1 second..."
    sox "$ramf" "${ramf}.padded" pad 0 1 2>/dev/null
    mv "${ramf}.padded" "$ramf"
fi

#============================================================================
# SPEECH TRANSCRIPTION
#============================================================================

notify_state "TRANSCRIBING" "Transcribing..."
log_debug "Starting transcription..."

str=""
whisper_exit=0

if [ -n "$IPnPORT" ]; then
    log_debug "Using whisper.cpp server: $IPnPORT"

    str=$(curl -S -s "$IPnPORT/inference" \
        -H "Content-Type: multipart/form-data" \
        -F file="@$ramf" \
        -F temperature="0.0" \
        -F temperature_inc="0.2" \
        -F response_format="text") || whisper_exit=$?

    log_debug "curl exit code: $whisper_exit"

elif command -v "$WHISPERFILE" &>/dev/null; then
    log_debug "Using faster-whisper: $(command -v "$WHISPERFILE")"

    # Capture both stdout and stderr
    whisper_stderr_file="/tmp/whisper_stderr_$$"

    log_debug "Running: $WHISPERFILE $ramf"

    # Run with explicit error capture
    set +e  # Temporarily disable errexit
    str="$("$WHISPERFILE" "$ramf" 2>"$whisper_stderr_file")"
    whisper_exit=$?
    set -e  # Re-enable errexit

    log_debug "faster-whisper exit code: $whisper_exit"

    # Log stderr if present
    if [ -s "$whisper_stderr_file" ]; then
        log_debug "faster-whisper output:"
        while IFS= read -r line; do
            log_debug "  $line"
        done < "$whisper_stderr_file"
    fi
    rm -f "$whisper_stderr_file"

    if [ $whisper_exit -ne 0 ]; then
        log_error "faster-whisper failed with exit code $whisper_exit"
        notify_state "ERROR" "Transcription failed (code $whisper_exit)"
        exit 1
    fi
else
    log_error "No transcription backend available!"
    log_error "Expected: $WHISPERFILE command in PATH"
    notify_state "ERROR" "No transcription backend"
    exit 1
fi

log_debug "Raw transcription: '$str'"

#============================================================================
# TEXT POST-PROCESSING
#============================================================================

# Remove non-speech artifacts detected by Whisper
str="${str/\(*\)}"
str="${str/\[*\]}"

# Remove leading newlines
str="${str#$'\n'}"
str="${str#$'\n'}"

# Remove leading whitespace and capitalize first letter
if [ -n "$BASH_VERSION" ]; then
    shopt -s extglob
    str="${str##+([[:space:]])}"
    str="${str^}"
else
    str="${str##+([[:space:]])}"
fi

if [ -z "$str" ]; then
    log_error "No transcription result (empty string)"
    log_debug "Possible causes:"
    log_debug "  - No speech detected in recording"
    log_debug "  - Background noise too high"
    log_debug "  - Microphone not working"
    notify_state "ERROR" "No speech detected" "dialog-warning"
    exit 1
fi

log_debug "Processed result: '$str'"

#============================================================================
# CLIPBOARD OUTPUT
#============================================================================

# Check if running in a graphics environment
if [[ -z "${DISPLAY}" ]] && [[ -z "${WAYLAND_DISPLAY}" ]] && [[ -z "${DESKTOP_SESSION}" ]]; then
    echo "$str"
    exit 0
fi

wm="${XDG_SESSION_TYPE:-unknown}"
log_debug "Sending to clipboard (window manager: $wm)"

case "$wm" in
    "x11")
        if [ "$CLIPBOARD" = true ]; then
            echo "$str" | xsel -ib
            log_debug "Text sent to CLIPBOARD"
        else
            echo "$str" | xsel -ip
            log_debug "Text sent to PRIMARY selection"
        fi
        ;;
    "wayland")
        if [ "$CLIPBOARD" = true ]; then
            echo "$str" | wl-copy
            log_debug "Text sent to CLIPBOARD"
        else
            echo "$str" | wl-copy -p
            log_debug "Text sent to PRIMARY selection"
        fi
        ;;
    *)
        log_error "Unknown window manager: $wm"
        echo "$str"
        ;;
esac

# Send success notification with preview
preview="${str:0:60}"
[ ${#str} -gt 60 ] && preview="${preview}..."

if [ "$CLIPBOARD" = true ]; then
    notify_state "SUCCESS" "$preview\n\nCtrl+V to paste"
else
    notify_state "SUCCESS" "$preview\n\nMiddle-click to paste"
fi

# Signal idle state after brief delay
(sleep 2 && gdbus emit --session \
    --object-path "$DBUS_PATH" \
    --signal "${DBUS_INTERFACE}.StateChanged" \
    "IDLE" 2>/dev/null) &

log_debug "WSI completed successfully"

exit 0
