#!/usr/bin/bash
# Enhanced WSI (Whisper Speech Input) Script
# Speech-to-text orchestrator for GNOME extension
# Based on: https://github.com/QuantiusBenignus/blurt
# Enhanced with comprehensive debugging and error handling

#============================================================================
# USER CONFIGURATION
#============================================================================
TEMPD='/dev/shm'
ramf="$TEMPD/wfile-$USER.wav"
WHISPERFILE="faster-whisper-transcribe"
CLIPBOARD=false
AUTO_PASTE=false
WHOST="127.0.0.1"
WPORT="58080"

#============================================================================
# LOG FILE CONFIGURATION
#============================================================================
LOG_DIR="$HOME/.local/share/speech-to-text"
LOG_FILE="$LOG_DIR/debug.log"
MAX_LOG_SIZE=1048576  # 1MB - rotate when exceeded

#============================================================================
# PID FILE FOR SIGNAL HANDLING
#============================================================================
PID_FILE="$TEMPD/stt-recording-$USER.pid"
REC_PID=""

#============================================================================
# RUNTIME VARIABLES
#============================================================================
DEBUG=false
VERBOSE=false
IPnPORT=""
LOG_BUFFER=()  # Buffer for logs in non-debug mode

#============================================================================
# DBUS CONFIGURATION
#============================================================================
DBUS_PATH="/org/fedoradesktop/SpeechToText"
DBUS_INTERFACE="org.fedoradesktop.SpeechToText"

#============================================================================
# LOGGING FUNCTIONS
#============================================================================

ensure_log_dir() {
    if [ ! -d "$LOG_DIR" ]; then
        mkdir -p "$LOG_DIR"
    fi

    # Rotate log if too large
    if [ -f "$LOG_FILE" ] && [ "$(stat -c%s "$LOG_FILE" 2>/dev/null || echo 0)" -gt "$MAX_LOG_SIZE" ]; then
        mv "$LOG_FILE" "${LOG_FILE}.old"
    fi
}

log_to_file() {
    local log_line="[$(date '+%Y-%m-%dT%H:%M:%S')] [WSI] $*"

    if [ "$DEBUG" = true ] || [ "$VERBOSE" = true ]; then
        # Debug mode - write immediately
        ensure_log_dir
        echo "$log_line" >> "$LOG_FILE"
    else
        # Normal mode - buffer logs
        LOG_BUFFER+=("$log_line")
    fi
}

flush_log_buffer() {
    # Write buffered logs to disk
    local buffer_size=${#LOG_BUFFER[@]}
    if [ $buffer_size -gt 0 ]; then
        ensure_log_dir
        for line in "${LOG_BUFFER[@]}"; do
            echo "$line" >> "$LOG_FILE"
        done
        LOG_BUFFER=()
        echo $buffer_size  # Return count for caller
        return 0
    fi
    return 1
}

log() {
    echo "[WSI] $*" >&2
    log_to_file "$*"
}

log_debug() {
    if [ "$DEBUG" = true ] || [ "$VERBOSE" = true ]; then
        echo "[DEBUG] $*" >&2
        log_to_file "[DEBUG] $*"
    fi
}

log_error() {
    echo "[ERROR] $*" >&2
    log_to_file "[ERROR] $*"

    # Flush buffered logs on error
    if [ "$DEBUG" = false ]; then
        local flushed_count=$(flush_log_buffer 2>/dev/null || echo "0")
        if [ "$flushed_count" != "0" ]; then
            # Notify user that logs were saved
            notify_state "ERROR" "$*\n\nðŸ“ Debug logs saved ($flushed_count entries):\n$LOG_FILE"
            # Write flush info to log (will go directly to file now)
            DEBUG=true log_to_file "Flushed $flushed_count buffered log entries to disk on error"
            DEBUG=false
        else
            # Send regular error notification
            notify_state "ERROR" "$*"
        fi
    else
        # Debug mode - logs already written, just notify
        notify_state "ERROR" "$*"
    fi

    # Send error signal for extension
    gdbus emit --session \
        --object-path "$DBUS_PATH" \
        --signal "${DBUS_INTERFACE}.Error" \
        "$*" 2>/dev/null &
}

#============================================================================
# NOTIFICATION AND DBUS SIGNALING
#============================================================================

NOTIFICATION_ID=0

notify_state() {
    local state="$1"
    local message="$2"
    local icon="${3:-audio-input-microphone}"

    log_debug "State: $state - $message"

    # Send DBus signal for extension icon state
    gdbus emit --session \
        --object-path "$DBUS_PATH" \
        --signal "${DBUS_INTERFACE}.StateChanged" \
        "$state" 2>/dev/null &

    # Send notification via gdbus so we can replace it
    # Using a fixed app name ensures replacement works
    local result
    result=$(gdbus call --session \
        --dest org.freedesktop.Notifications \
        --object-path /org/freedesktop/Notifications \
        --method org.freedesktop.Notifications.Notify \
        "speech-to-text" \
        "$NOTIFICATION_ID" \
        "$icon" \
        "Speech to Text" \
        "$message" \
        '[]' \
        '{}' \
        3000 2>/dev/null) || true

    # Extract notification ID for replacement
    if [[ "$result" =~ \(uint32\ ([0-9]+),\) ]]; then
        NOTIFICATION_ID="${BASH_REMATCH[1]}"
    fi
}

#============================================================================
# CLEANUP AND SIGNAL HANDLING
#============================================================================

STOP_REQUESTED=false

cleanup() {
    log_debug "Cleanup triggered"
    # Remove PID file
    rm -f "$PID_FILE"
    # Signal idle state only if we're actually exiting (not just stopping recording)
    if [ "$STOP_REQUESTED" = false ]; then
        gdbus emit --session \
            --object-path "$DBUS_PATH" \
            --signal "${DBUS_INTERFACE}.StateChanged" \
            "IDLE" 2>/dev/null &
    fi
}

stop_recording() {
    log_debug "Stop requested - sending SIGINT to rec process"
    STOP_REQUESTED=true
    # Send SIGINT (like Ctrl+C) so rec flushes audio buffers before exiting
    if [ -n "$REC_PID" ] && kill -0 "$REC_PID" 2>/dev/null; then
        log_debug "Sending SIGINT to rec process $REC_PID"
        kill -INT "$REC_PID" 2>/dev/null
        # Wait for rec to actually exit and flush buffers
        for i in {1..20}; do
            if ! kill -0 "$REC_PID" 2>/dev/null; then
                log_debug "rec exited after ${i}0ms"
                break
            fi
            sleep 0.1
        done
    fi
}

# Trap EXIT for final cleanup
trap cleanup EXIT
# Trap TERM/INT to stop recording but continue script
trap 'stop_recording' TERM INT

#============================================================================
# UTILITY FUNCTIONS
#============================================================================

print_banner() {
    cat >&2 <<'EOF'
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  WSI - Whisper Speech Input v2.0 (Enhanced)                    â”‚
â”‚  Speech-to-text orchestrator for GNOME extension               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
EOF
}

check_command() {
    local cmd="$1"
    local package="$2"
    local purpose="$3"

    if command -v "$cmd" &>/dev/null; then
        local version=""
        case "$cmd" in
            sox)
                version=$(sox --version 2>&1 | head -1)
                ;;
            curl)
                version=$(curl --version 2>&1 | head -1)
                ;;
            *)
                version="(installed)"
                ;;
        esac
        log_debug "  $cmd: $version"
        return 0
    else
        log_error "  $cmd: NOT FOUND"
        log_error "    Purpose: $purpose"
        log_error "    Install: sudo dnf install $package"
        return 1
    fi
}

check_dependencies() {
    log_debug "Checking dependencies..."
    local failed=0

    check_command "pw-record" "pipewire" "Audio recording (PipeWire)" || ((failed++))
    check_command "sox" "sox" "Audio resampling" || ((failed++))
    check_command "soxi" "sox" "Audio file info" || ((failed++))
    check_command "curl" "curl" "HTTP requests to whisper.cpp server" || ((failed++))

    local wm="${XDG_SESSION_TYPE:-unknown}"
    log_debug "Window manager: $wm"

    if [[ "$wm" == "wayland" ]]; then
        check_command "wl-copy" "wl-clipboard" "Clipboard management (Wayland)" || ((failed++))
        check_command "ydotool" "ydotool" "Auto-paste (Wayland/X11)" || ((failed++))
    elif [[ "$wm" == "x11" ]]; then
        check_command "xsel" "xsel" "Clipboard management (X11)" || ((failed++))
        check_command "ydotool" "ydotool" "Auto-paste (Wayland/X11)" || ((failed++))
    else
        log_error "Unknown window manager: $wm"
        ((failed++))
    fi

    if command -v "$WHISPERFILE" &>/dev/null; then
        local whisperfile_path=$(command -v "$WHISPERFILE")
        log_debug "  $WHISPERFILE: $whisperfile_path"
    else
        log_error "  $WHISPERFILE: NOT FOUND in PATH"
        ((failed++))
    fi

    if [ -d "$TEMPD" ] && [ -w "$TEMPD" ]; then
        log_debug "  Temp directory: $TEMPD (writable)"
    else
        log_error "  Temp directory: $TEMPD (not writable)"
        ((failed++))
    fi

    if [ $failed -gt 0 ]; then
        log_error "Dependency check failed: $failed errors found"
        return 1
    fi

    log_debug "All dependencies satisfied"
    return 0
}

print_config() {
    local paste_mode="PRIMARY"
    [ "$CLIPBOARD" = true ] && paste_mode="CLIPBOARD"
    [ "$AUTO_PASTE" = true ] && paste_mode="AUTO-PASTE"
    cat >&2 <<EOF
Configuration:
  Temp directory:     $TEMPD
  Temp audio file:    $ramf
  Whisperfile:        $WHISPERFILE ($(command -v "$WHISPERFILE" 2>/dev/null || echo "NOT FOUND"))
  Paste mode:         $paste_mode
  Window manager:     ${XDG_SESSION_TYPE:-unknown}
  Log file:           $LOG_FILE
EOF
}

usage() {
    cat >&2 <<'EOF'
Usage: wsi [OPTIONS]

Options:
  -c, --clipboard     Use CLIPBOARD instead of PRIMARY selection
  -a, --auto-paste    Type text directly at cursor (no clipboard)
  -n, --netapi        Use whisper.cpp server (host:port from config)
  -d, --debug         Enable debug mode (verbose output + dependency checks)
  -v, --verbose       Enable verbose output only
  -h, --help          Show this help message

  IP:PORT             Use whisper.cpp server at specific address

Examples:
  wsi                 # Record speech and transcribe locally
  wsi -d              # Debug mode with full diagnostics
  wsi -c              # Use CLIPBOARD instead of PRIMARY
  wsi -a              # Auto-paste at cursor position
  wsi server.local:8080  # Use remote whisper.cpp server
EOF
}

#============================================================================
# COMMAND LINE ARGUMENT PARSING
#============================================================================

while [ $# -gt 0 ]; do
    case "$1" in
        -c|--clipboard)
            CLIPBOARD=true
            log_debug "Clipboard mode: CLIPBOARD"
            shift
            ;;
        -a|--auto-paste)
            AUTO_PASTE=true
            log_debug "Auto-paste mode enabled"
            shift
            ;;
        -d|--debug)
            DEBUG=true
            VERBOSE=true
            log_debug "Debug mode enabled"
            shift
            ;;
        -v|--verbose)
            VERBOSE=true
            log_debug "Verbose mode enabled"
            shift
            ;;
        -n|--netapi)
            IPnPORT="$WHOST:$WPORT"
            if [[ "$(curl -s -f -o /dev/null -w '%{http_code}' "$IPnPORT" 2>/dev/null)" != "200" ]]; then
                log_error "Can't connect to whisper.cpp server at $IPnPORT"
                exit 1
            fi
            log_debug "Using whisper.cpp server: $IPnPORT"
            shift
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            IPnPORT="$1"
            if [[ "$(curl -s -f -o /dev/null -w '%{http_code}' "$IPnPORT" 2>/dev/null)" != "200" ]]; then
                log_error "Can't connect to whisper.cpp server at $IPnPORT"
                exit 1
            fi
            log_debug "Using whisper.cpp server: $IPnPORT"
            shift
            ;;
    esac
done

#============================================================================
# DEBUG MODE INITIALIZATION
#============================================================================

if [ "$DEBUG" = true ]; then
    print_banner
    print_config
    echo "" >&2
    check_dependencies || exit 1
    echo "" >&2
    log "Starting speech recording with full debugging..."
fi

#============================================================================
# ERROR TRAP HANDLER
#============================================================================

trap_handler() {
    local exit_code=$?
    local line_no=$1
    local command="$BASH_COMMAND"

    log_error "Script failed at line $line_no: $command (exit code: $exit_code)"

    # Send error state via DBus
    notify_state "ERROR" "Script error (see log)"

    exit $exit_code
}

# Enable trap for debug mode
if [ "$DEBUG" = true ]; then
    trap 'trap_handler $LINENO' ERR
fi

#============================================================================
# FAIL FAST - PREFLIGHT SANITY CHECKS
#============================================================================
set -e

log_debug "Running preflight sanity checks..."

# Check critical commands exist
for cmd in pw-record sox soxi; do
    if ! command -v "$cmd" &>/dev/null; then
        log_error "Required command not found: $cmd"
        log_to_file "Install with: sudo dnf install $([ "$cmd" = "pw-record" ] && echo "pipewire" || echo "sox")"
        exit 1
    fi
done

# Check Whisper availability if not using network API
if [ -z "$IPnPORT" ]; then
    if ! command -v "$WHISPERFILE" &>/dev/null; then
        log_error "Whisper not found: $WHISPERFILE"
        log_to_file "Install with: pip install --user faster-whisper"
        exit 1
    fi
fi

# Check ydotool if in auto-paste mode
if [ "$AUTO_PASTE" = true ]; then
    if ! command -v ydotool &>/dev/null; then
        log_error "ydotool not found (required for auto-paste)"
        log_to_file "Install with: sudo dnf install ydotool"
        exit 1
    fi

    # Check socket exists
    if [ ! -S "/run/ydotool.socket" ]; then
        log_error "ydotool socket not found: /run/ydotool.socket"
        log_to_file "ydotool service not running"
        log_to_file "Fix: sudo systemctl restart ydotool"
        exit 1
    fi

    # Check socket is writable
    if [ ! -w "/run/ydotool.socket" ]; then
        log_error "ydotool socket not writable"
        log_to_file "Socket permissions: $(ls -l /run/ydotool.socket 2>&1)"
        log_to_file "Fix: sudo systemctl restart ydotool"
        exit 1
    fi
fi

# Check clipboard tools for non-auto-paste mode
if [ "$AUTO_PASTE" = false ]; then
    wm="${XDG_SESSION_TYPE:-unknown}"
    if [[ "$wm" == "wayland" ]]; then
        if ! command -v wl-copy &>/dev/null; then
            log_error "wl-copy not found (required for Wayland clipboard)"
            log_to_file "Install with: sudo dnf install wl-clipboard"
            exit 1
        fi
    elif [[ "$wm" == "x11" ]]; then
        if ! command -v xsel &>/dev/null; then
            log_error "xsel not found (required for X11 clipboard)"
            log_to_file "Install with: sudo dnf install xsel"
            exit 1
        fi
    fi
fi

# Check temp directory is writable
if [ ! -w "$TEMPD" ]; then
    log_error "Temp directory not writable: $TEMPD"
    exit 1
fi

log_debug "All preflight checks passed"

#============================================================================
# SPEECH RECORDING
#============================================================================

# Write PID file so extension can stop us
echo $$ > "$PID_FILE"
log_debug "PID file written: $PID_FILE ($$)"

log_debug "Ready! Speak now... (press Insert again to stop)"

# Notify user that recording has started
notify_state "RECORDING" "Recording... (Insert to stop)"

# Use pw-record (PipeWire native) for minimal buffering
# Records directly to wav at 44100Hz, low latency ensures audio is flushed on kill
if [ "$DEBUG" = true ]; then
    pw-record --rate 44100 --channels 2 --latency 50ms "$ramf" &
else
    pw-record --rate 44100 --channels 2 --latency 50ms "$ramf" 2>/dev/null &
fi
REC_PID=$!
log_debug "pw-record started with PID $REC_PID"

# Start 30-second timeout timer in background
(
    sleep 30
    if kill -0 "$REC_PID" 2>/dev/null; then
        log_debug "30-second limit reached, auto-stopping recording"
        kill -INT "$REC_PID" 2>/dev/null
    fi
) &
TIMER_PID=$!
log_debug "30-second timer started with PID $TIMER_PID"

# Wait for recording to complete (or be killed)
wait $REC_PID || true

# Cancel the timer if recording stopped early
if kill -0 "$TIMER_PID" 2>/dev/null; then
    kill "$TIMER_PID" 2>/dev/null
    log_debug "Timer cancelled (recording stopped early)"
fi

log_debug "Recording complete: $ramf"

if [ ! -f "$ramf" ] || [ ! -s "$ramf" ]; then
    log_error "Recording file empty or missing: $ramf"
    notify_state "ERROR" "Recording failed"
    exit 1
fi

if [ -f "$ramf" ]; then
    size=$(du -h "$ramf" 2>/dev/null | cut -f1)
    log_debug "Audio file size: $size"
else
    log_error "Audio file not created: $ramf"
    notify_state "ERROR" "Recording failed"
    exit 1
fi

# Resample from 44100Hz to 16000Hz (whisper requirement)
log_debug "Resampling audio from 44100Hz to 16000Hz..."

if [ "$DEBUG" = true ]; then
    sox "$ramf" "${ramf}.resampled.wav" rate 16k
else
    sox "$ramf" "${ramf}.resampled.wav" rate 16k 2>/dev/null
fi
mv "${ramf}.resampled.wav" "$ramf"

# Check audio duration and pad if needed (whisper requires min 1 second)
audio_duration=$(soxi -D "$ramf" 2>/dev/null | cut -d. -f1)
log_debug "Audio duration: ${audio_duration}s"

if [ -n "$audio_duration" ] && [ "$audio_duration" -lt 1 ]; then
    log_debug "Audio too short, padding to 1 second..."
    sox "$ramf" "${ramf}.padded" pad 0 1 2>/dev/null
    mv "${ramf}.padded" "$ramf"
fi

#============================================================================
# SPEECH TRANSCRIPTION
#============================================================================

notify_state "TRANSCRIBING" "Transcribing..."
log_debug "Starting transcription..."

str=""
whisper_exit=0

if [ -n "$IPnPORT" ]; then
    log_debug "Using whisper.cpp server: $IPnPORT"

    str=$(curl -S -s "$IPnPORT/inference" \
        -H "Content-Type: multipart/form-data" \
        -F file="@$ramf" \
        -F temperature="0.0" \
        -F temperature_inc="0.2" \
        -F response_format="text") || whisper_exit=$?

    log_debug "curl exit code: $whisper_exit"

elif command -v "$WHISPERFILE" &>/dev/null; then
    log_debug "Using faster-whisper: $(command -v "$WHISPERFILE")"
    log_debug "Running: $WHISPERFILE $ramf"

    # Run transcription (batch mode - fast enough that streaming display isn't needed)
    set +e  # Temporarily disable errexit
    str="$("$WHISPERFILE" "$ramf" 2>/dev/null)"
    whisper_exit=$?
    set -e  # Re-enable errexit

    log_debug "faster-whisper exit code: $whisper_exit"

    if [ $whisper_exit -ne 0 ]; then
        log_error "faster-whisper failed with exit code $whisper_exit"
        notify_state "ERROR" "Transcription failed (code $whisper_exit)"
        exit 1
    fi
else
    log_error "No transcription backend available!"
    log_error "Expected: $WHISPERFILE command in PATH"
    notify_state "ERROR" "No transcription backend"
    exit 1
fi

log_debug "Raw transcription: '$str'"

#============================================================================
# TEXT POST-PROCESSING
#============================================================================

# Remove non-speech artifacts detected by Whisper (global replace)
str="${str//\(*\)}"
str="${str//\[*\]}"

# Remove leading newlines
str="${str#$'\n'}"
str="${str#$'\n'}"

# Remove leading whitespace and capitalize first letter
if [ -n "$BASH_VERSION" ]; then
    shopt -s extglob
    str="${str##+([[:space:]])}"
    str="${str^}"
else
    str="${str##+([[:space:]])}"
fi

if [ -z "$str" ]; then
    log_error "No transcription result (empty string)"
    log_debug "Possible causes:"
    log_debug "  - No speech detected in recording"
    log_debug "  - Background noise too high"
    log_debug "  - Microphone not working"
    notify_state "ERROR" "No speech detected" "dialog-warning"
    exit 1
fi

log_debug "Processed result: '$str'"

#============================================================================
# SAVE TRANSCRIPTION TO FILE
#============================================================================

# Save transcribed text to cache file for later access
TRANSCRIPTION_FILE="$HOME/.cache/speech-to-text/last-transcription.txt"
mkdir -p "$(dirname "$TRANSCRIPTION_FILE")"
echo "$str" > "$TRANSCRIPTION_FILE"
log_debug "Transcription saved to: $TRANSCRIPTION_FILE"

#============================================================================
# CLIPBOARD OUTPUT
#============================================================================

# Check if running in a graphics environment
if [[ -z "${DISPLAY}" ]] && [[ -z "${WAYLAND_DISPLAY}" ]] && [[ -z "${DESKTOP_SESSION}" ]]; then
    echo "$str"
    exit 0
fi

wm="${XDG_SESSION_TYPE:-unknown}"

# Handle auto-paste mode - type directly at cursor
if [ "$AUTO_PASTE" = true ]; then
    log_debug "Auto-pasting text at cursor via ydotool"
    log_debug "Text length: ${#str} characters"
    log_debug "Text preview: ${str:0:100}"

    # Double-check socket still exists (in case service crashed)
    if [ ! -S "/run/ydotool.socket" ]; then
        log_error "ydotool socket disappeared before paste"
        log_to_file "Service may have crashed during recording"
        exit 1
    fi

    # Check if ydotool daemon is responsive
    if ! timeout 1 bash -c "YDOTOOL_SOCKET=/run/ydotool.socket ydotool key 29:0" 2>/dev/null; then
        log_error "ydotool daemon not responding"
        log_to_file "Daemon may be hung or crashed"
        log_to_file "Check: sudo systemctl status ydotool"
        exit 1
    fi

    # ydotool works on both Wayland and X11 via uinput
    # Use system socket (daemon runs as root with world-accessible socket)
    log_debug "Typing text via ydotool (${#str} characters)"
    if ! bash -c "YDOTOOL_SOCKET=/run/ydotool.socket ydotool type -- \"\$1\"" _ "$str"; then
        local exit_code=$?
        log_error "ydotool failed (exit code: $exit_code)"
        log_to_file "Text length was: ${#str} characters"
        exit 1
    fi
    log_debug "Text typed successfully"
    # Small delay to ensure ydotool completes before script exits
    sleep 0.2
    preview="${str:0:60}"
    [ ${#str} -gt 60 ] && preview="${preview}..."
    notify_state "SUCCESS" "$preview"
else
    # Clipboard mode
    log_debug "Sending to clipboard (window manager: $wm)"
    case "$wm" in
        "x11")
            if [ "$CLIPBOARD" = true ]; then
                echo "$str" | xsel -ib
                log_debug "Text sent to CLIPBOARD"
            else
                echo "$str" | xsel -ip
                log_debug "Text sent to PRIMARY selection"
            fi
            ;;
        "wayland")
            if [ "$CLIPBOARD" = true ]; then
                echo "$str" | wl-copy
                log_debug "Text sent to CLIPBOARD"
            else
                echo "$str" | wl-copy -p
                log_debug "Text sent to PRIMARY selection"
            fi
            ;;
        *)
            log_error "Unknown window manager: $wm"
            echo "$str"
            ;;
    esac

    # Send success notification with preview
    preview="${str:0:60}"
    [ ${#str} -gt 60 ] && preview="${preview}..."

    if [ "$CLIPBOARD" = true ]; then
        notify_state "SUCCESS" "$preview\n\nCtrl+V to paste"
    else
        notify_state "SUCCESS" "$preview\n\nMiddle-click to paste"
    fi
fi

# Signal idle state after brief delay
(sleep 2 && gdbus emit --session \
    --object-path "$DBUS_PATH" \
    --signal "${DBUS_INTERFACE}.StateChanged" \
    "IDLE" 2>/dev/null) &

# Cleanup temporary files
rm -f "$ramf" "${ramf}.resampled.wav" "${ramf}.padded"

log_debug "WSI completed successfully"

exit 0
