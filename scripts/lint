#!/usr/bin/env bash
# Ansible Lint Wrapper Script
# Provides consistent linting with JSON output, intelligent summaries, and auto-fix capability

set -e

# Configuration
LINT_OUTPUT_DIR="./untracked/lint"
MAX_KEPT_FILES=10
TIMESTAMP=$(date +"%Y-%m-%dT%H-%M-%S")

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Default values
FIX_MODE=""
TARGET_PATH=""

# Parse command line arguments
show_usage() {
    cat <<EOF
Usage: $0 [OPTIONS] [PATH]

Options:
  --fix[=RULES]    Auto-fix violations. Optional comma-separated rule list.
                   Examples: --fix, --fix=fqcn, --fix=fqcn,yaml
  -h, --help       Show this help message

Arguments:
  PATH             File or directory to lint (default: playbooks/)

Examples:
  $0                                    # Lint entire playbooks/ directory
  $0 playbooks/imports/play-git.yml    # Lint specific file
  $0 --fix playbooks/                  # Auto-fix all violations
  $0 --fix=fqcn playbooks/             # Auto-fix only FQCN violations
EOF
    exit 0
}

# Parse arguments
while [[ $# -gt 0 ]]; do
    case "$1" in
        --fix)
            FIX_MODE="all"
            shift
            ;;
        --fix=*)
            FIX_MODE="${1#*=}"
            shift
            ;;
        -h|--help)
            show_usage
            ;;
        -*)
            echo "Error: Unknown option: $1" >&2
            show_usage
            exit 2
            ;;
        *)
            TARGET_PATH="$1"
            shift
            ;;
    esac
done

# Set default target path if not specified
TARGET_PATH="${TARGET_PATH:-playbooks/}"

# Sanitize path for filename (replace / with -)
SANITIZED_PATH=$(echo "$TARGET_PATH" | sed 's|/|-|g' | sed 's|^-||' | sed 's|-$||')
if [ -z "$SANITIZED_PATH" ]; then
    SANITIZED_PATH="playbooks"
fi

OUTPUT_JSON="${LINT_OUTPUT_DIR}/${TIMESTAMP}-${SANITIZED_PATH}.json"

# Ensure output directory exists
mkdir -p "$LINT_OUTPUT_DIR"

# Helper function to prune old files
prune_old_files() {
    local file_count=$(ls -1 "$LINT_OUTPUT_DIR"/*.json 2>/dev/null | wc -l)
    if [ "$file_count" -gt "$MAX_KEPT_FILES" ]; then
        local files_to_delete=$((file_count - MAX_KEPT_FILES))
        ls -1t "$LINT_OUTPUT_DIR"/*.json | tail -n "$files_to_delete" | xargs rm -f
        echo -e "${YELLOW}Pruned $files_to_delete old lint report(s)${NC}" >&2
    fi
}

# Helper function to print summary header
print_header() {
    echo ""
    echo "========================================="
    if [ -n "$FIX_MODE" ]; then
        echo "  Ansible Lint Auto-Fix"
    else
        echo "  Ansible Lint Summary"
    fi
    echo "========================================="
    echo "Target: $TARGET_PATH"
    if [ -n "$FIX_MODE" ]; then
        echo "Fix Mode: $FIX_MODE"
    fi
    echo "Date: $(date '+%Y-%m-%d %H:%M:%S')"
    echo "========================================="
    echo ""
}

# Helper function to generate terse summary
generate_summary() {
    local json_file="$1"

    # Check if JSON file is empty or has no issues
    local issue_count=$(jq 'length' "$json_file" 2>/dev/null || echo "0")

    if [ "$issue_count" -eq 0 ]; then
        echo -e "${GREEN}âœ“ No ansible-lint violations found!${NC}"
        return 0
    fi

    # Check severity levels - only fail on major issues
    local major_count=$(jq '[.[] | select(.severity == "major")] | length' "$json_file" 2>/dev/null || echo "0")
    local minor_count=$(jq '[.[] | select(.severity == "minor")] | length' "$json_file" 2>/dev/null || echo "0")

    # Count total violations
    local total_violations="$issue_count"

    # Count unique files
    local unique_files=$(jq -r '[.[].location.path] | unique | length' "$json_file")

    # Determine pass/fail based on severity
    if [ "$major_count" -eq 0 ]; then
        # Only warnings (minor severity)
        echo -e "${GREEN}âœ“ Passed: 0 failures, $minor_count warning(s) across $unique_files file(s)${NC}"
        echo ""
        echo "Top Warnings:"
        jq -r '[.[] | .check_name] | group_by(.) | map({rule: .[0], count: length}) | sort_by(.count) | reverse | .[] | "  \(.rule): \(.count) warning(s)"' "$json_file"

        echo ""
        echo "ðŸ“„ Detailed results saved to:"
        echo "   $OUTPUT_JSON"
        echo ""

        return 0
    else
        # Has major failures
        echo -e "${RED}Found $major_count failure(s) and $minor_count warning(s) across $unique_files file(s)${NC}"
        echo ""
        echo "Top Issues:"
        jq -r '[.[] | .check_name] | group_by(.) | map({rule: .[0], count: length}) | sort_by(.count) | reverse | .[] | "  \(.rule): \(.count) violation(s)"' "$json_file"

        echo ""

        # Show per-file breakdown if <= 10 files
        if [ "$unique_files" -le 10 ]; then
            echo "Violations by file:"
            jq -r '[.[] | .location.path] | group_by(.) | map({file: .[0], count: length}) | sort_by(.count) | reverse | .[] | "  \(.file): \(.count) violation(s)"' "$json_file"
            echo ""
        fi

        # Show detailed results location
        echo "ðŸ“„ Detailed results saved to:"
        echo "   $OUTPUT_JSON"
        echo ""

        # Provide jq query examples
        echo "ðŸ” Example jq queries:"
        echo ""
        echo "  # List files with most issues:"
        echo "  jq '[.[] | .location.path] | group_by(.) | map({file: .[0], count: length}) | sort_by(.count) | reverse' '$OUTPUT_JSON'"
        echo ""
        echo "  # Get all FQCN violations:"
        echo "  jq '[.[] | select(.check_name | startswith(\"fqcn\"))]' '$OUTPUT_JSON'"
        echo ""
        echo "  # Get violations for specific file:"
        echo "  jq '[.[] | select(.location.path == \"path/to/file.yml\")]' '$OUTPUT_JSON'"
        echo ""
        echo "  # Count violations by severity:"
        echo "  jq '[.[] | .severity] | group_by(.) | map({severity: .[0], count: length})' '$OUTPUT_JSON'"
        echo ""

        return 1
    fi
}

# Run ansible-lint in fix mode
run_fix_mode() {
    echo -e "${BLUE}Running ansible-lint --fix=$FIX_MODE on: $TARGET_PATH${NC}"
    echo ""

    # Store initial violation count
    echo "Analyzing violations before fix..."
    if ansible-lint -f json "$TARGET_PATH" 2>/dev/null > "${OUTPUT_JSON}.before"; then
        BEFORE_COUNT=0
    else
        BEFORE_COUNT=$(jq 'length' "${OUTPUT_JSON}.before" 2>/dev/null || echo "0")
    fi
    echo "Found $BEFORE_COUNT violation(s) before fix"
    echo ""

    # Run ansible-lint --fix
    echo "Applying fixes..."
    if ansible-lint --fix="$FIX_MODE" "$TARGET_PATH" 2>&1 | grep -v "WARNING\|DEPRECATION"; then
        echo ""
        echo -e "${GREEN}âœ“ Fix completed successfully${NC}"
    else
        fix_exit_code=$?
        if [ $fix_exit_code -eq 2 ]; then
            echo ""
            echo -e "${YELLOW}âš  Fix completed with some remaining violations${NC}"
        else
            echo ""
            echo -e "${RED}âœ— Fix encountered errors${NC}"
        fi
    fi

    echo ""
    echo "Re-analyzing violations after fix..."

    # Run lint again to see what's left
    if ansible-lint -f json "$TARGET_PATH" 2>/dev/null > "$OUTPUT_JSON"; then
        AFTER_COUNT=0
    else
        AFTER_COUNT=$(jq 'length' "$OUTPUT_JSON" 2>/dev/null || echo "0")
    fi

    # Calculate fixed count
    FIXED_COUNT=$((BEFORE_COUNT - AFTER_COUNT))

    echo ""
    echo "========================================="
    echo "  Fix Summary"
    echo "========================================="
    echo "Before: $BEFORE_COUNT violation(s)"
    echo "After:  $AFTER_COUNT violation(s)"
    echo -e "${GREEN}Fixed:  $FIXED_COUNT violation(s)${NC}"
    echo "========================================="
    echo ""

    # Clean up temporary file
    rm -f "${OUTPUT_JSON}.before"

    # Return 0 if all fixed, 1 if some remain
    if [ "$AFTER_COUNT" -eq 0 ]; then
        return 0
    else
        return 1
    fi
}

# Main execution
main() {
    print_header

    # Check if target exists
    if [ ! -e "$TARGET_PATH" ]; then
        echo -e "${RED}Error: Target path '$TARGET_PATH' does not exist${NC}" >&2
        exit 2
    fi

    # Run in fix mode or normal mode
    if [ -n "$FIX_MODE" ]; then
        # Fix mode
        if run_fix_mode; then
            fix_result=0
        else
            fix_result=1
        fi

        # Show remaining violations if any
        if [ "$fix_result" -eq 1 ]; then
            echo ""
            echo "Remaining violations:"
            echo ""
            generate_summary "$OUTPUT_JSON"
        fi

        # Prune old files
        prune_old_files

        exit $fix_result
    else
        # Normal lint mode
        echo "Running ansible-lint on: $TARGET_PATH"
        echo ""

        # Run lint, suppress stderr warnings, capture JSON
        if ansible-lint -f json "$TARGET_PATH" 2>/dev/null > "$OUTPUT_JSON"; then
            # No violations found
            lint_exit_code=0
        else
            # Violations found or error occurred
            lint_exit_code=$?
        fi

        # Check if JSON file is valid
        if ! jq empty "$OUTPUT_JSON" 2>/dev/null; then
            echo -e "${RED}Error: Failed to generate valid JSON output${NC}" >&2
            echo "Ansible-lint may have encountered an error" >&2
            exit 2
        fi

        # Generate and display summary
        if generate_summary "$OUTPUT_JSON"; then
            summary_exit_code=0
        else
            summary_exit_code=1
        fi

        # Prune old files
        prune_old_files

        # Exit with appropriate code
        exit $summary_exit_code
    fi
}

# Run main function
main "$@"
