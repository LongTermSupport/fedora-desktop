#!/bin/bash
# Session Management Library for CCY
# Provides named sessions with TUI picker, context tracking, and auto-pruning
#
# Version: 1.0.0

# Get session directory for a named session
get_session_dir() {
    local session_name="${1:-default}"
    local sessions_root="${2:-.claude/ccy}"

    echo "$sessions_root/sessions/$session_name"
}

# Initialize sessions directory structure
init_sessions_dir() {
    local sessions_root="${1:-.claude/ccy}"
    local sessions_dir="$sessions_root/sessions"

    mkdir -p "$sessions_dir"
    chmod 700 "$sessions_dir"

    # ALWAYS create/enforce self-excluding .gitignore inside sessions directory
    # This protects sessions even if root .gitignore is modified
    # We recreate this every time to ensure it's never corrupted or deleted
    local gitignore_file="$sessions_dir/.gitignore"
    local first_time_setup=false

    # Check if this is first-time setup (directory didn't exist)
    if [[ ! -f "$gitignore_file" ]]; then
        first_time_setup=true
    fi

    # Always write the .gitignore (enforcement)
    cat > "$gitignore_file" <<'EOF'
# CCY Session Data - Do not commit
# Sessions contain conversation history and are specific to this machine
# Each session is isolated and should not be shared via git

# Ignore everything in this directory
*

# Except this .gitignore file itself
!.gitignore
EOF
    chmod 644 "$gitignore_file"

    # Show helpful message on first-time setup
    if [[ "$first_time_setup" == "true" ]]; then
        echo "✓ Session directory initialized: $sessions_dir" >&2
        echo "  └─ Self-protecting .gitignore created (prevents accidental commits)" >&2
    fi

    # Debug logging
    if [[ "${DEBUG_MODE:-false}" == "true" ]]; then
        echo "DEBUG: Enforced .gitignore in sessions directory: $gitignore_file" >&2
    fi

    # Create sessions registry if it doesn't exist
    # Store inside sessions/ directory so it's also gitignored
    local sessions_json="$sessions_dir/sessions.json"
    if [[ ! -f "$sessions_json" ]]; then
        cat > "$sessions_json" <<'EOF'
{
  "version": 1,
  "config": {
    "auto_prune_days": 4,
    "max_sessions": 50,
    "show_context_length": 60,
    "tui_recent_limit": 10,
    "confirm_autogenerated_names": true,
    "auto_discard_empty_sessions": true
  },
  "sessions": {},
  "last_session": null
}
EOF
        chmod 600 "$sessions_json"
    fi

    # Create config.json in ccy root (this SHOULD be committed)
    # Users can customize session behavior and commit their preferences
    local config_file="$sessions_root/config.json"
    if [[ ! -f "$config_file" ]]; then
        cat > "$config_file" <<'EOF'
{
  "version": 1,
  "auto_prune_days": 4,
  "max_sessions": 50,
  "show_context_length": 60,
  "tui_recent_limit": 10,
  "confirm_autogenerated_names": true,
  "auto_discard_empty_sessions": true
}
EOF
        chmod 644 "$config_file"
    fi
}

# Extract last context from session history
get_session_context() {
    local session_dir="$1"
    local history_file="$session_dir/history.jsonl"
    local max_length="${2:-60}"

    if [[ ! -f "$history_file" ]]; then
        echo "(no messages yet)"
        return
    fi

    # Get last 3 user messages from history.jsonl, filtering out slash commands
    local messages=$(tail -n 50 "$history_file" 2>/dev/null | \
        jq -r 'select(.display != null) | .display' 2>/dev/null | \
        grep -v '^/exit' | \
        grep -v '^/resume' | \
        grep -v '^/clear' | \
        grep -v '^\[Pasted text' | \
        tail -n 3)

    if [[ -n "$messages" ]]; then
        # Join messages with " → " and truncate to max_length
        local joined=$(echo "$messages" | tr '\n' '→' | sed 's/→$//; s/→/ → /g' | head -c "$max_length")
        echo "${joined}..."
    else
        echo "(session started)"
    fi
}

# Count messages in session
count_session_messages() {
    local session_dir="$1"
    local history_file="$session_dir/history.jsonl"

    if [[ ! -f "$history_file" ]]; then
        echo "0"
        return
    fi

    # Count non-empty lines in history file
    grep -c . "$history_file" 2>/dev/null || echo "0"
}

# Helper: Convert timestamp to human-readable age
get_human_time_ago() {
    local timestamp="$1"
    local now=$(date +%s)
    local then=$(date -d "$timestamp" +%s 2>/dev/null || echo "$now")
    local diff=$((now - then))

    local days=$((diff / 86400))
    local hours=$(((diff % 86400) / 3600))
    local mins=$(((diff % 3600) / 60))

    if [[ $days -gt 1 ]]; then
        echo "${days} days ago"
    elif [[ $days -eq 1 ]]; then
        echo "yesterday"
    elif [[ $hours -gt 0 ]]; then
        echo "${hours}h ago"
    elif [[ $mins -gt 0 ]]; then
        echo "${mins}m ago"
    else
        echo "just now"
    fi
}

# Update session metadata after each run
update_session_metadata() {
    local session_name="$1"
    local sessions_root="${2:-.claude/ccy}"
    local sessions_json="$sessions_root/sessions/sessions.json"
    local session_dir="$sessions_root/sessions/$session_name"

    # Ensure jq is available
    if ! command -v jq &> /dev/null; then
        print_warning "jq not found - skipping metadata update"
        return 1
    fi

    # Extract context and count
    local context=$(get_session_context "$session_dir")
    local msg_count=$(count_session_messages "$session_dir")

    # Update metadata
    local temp_json=$(mktemp)
    jq --arg name "$session_name" \
       --arg timestamp "$(date -Iseconds)" \
       --arg context "$context" \
       --argjson count "$msg_count" \
       '.sessions[$name].last_used = $timestamp |
        .sessions[$name].last_context = $context |
        .sessions[$name].message_count = $count |
        .last_session = $name' \
       "$sessions_json" > "$temp_json" 2>/dev/null && \
       mv "$temp_json" "$sessions_json" || \
       rm -f "$temp_json"
}

# Create or get named session
# Normalize a session name to valid format
# Converts spaces to hyphens, removes invalid chars, lowercases
normalize_session_name() {
    local input="$1"

    # Convert to lowercase, replace spaces with hyphens
    local normalized=$(echo "$input" | tr '[:upper:]' '[:lower:]' | tr ' ' '-')

    # Remove any characters that aren't alphanumeric, hyphen, or underscore
    normalized=$(echo "$normalized" | sed 's/[^a-z0-9_-]//g')

    # Remove leading/trailing hyphens
    normalized=$(echo "$normalized" | sed 's/^-*//' | sed 's/-*$//')

    # Collapse multiple consecutive hyphens into one
    normalized=$(echo "$normalized" | sed 's/-\+/-/g')

    echo "$normalized"
}

# Prompt user to confirm or adjust normalized session name
confirm_or_adjust_session_name() {
    local original="$1"
    local normalized="$2"

    # If they're the same, no need to confirm
    if [[ "$original" == "$normalized" ]]; then
        echo "$normalized"
        return 0
    fi

    # Show the normalized version and ask for confirmation
    echo "" >&2
    echo "Session name normalized: '$original' → '$normalized'" >&2
    read -p "Use this name? [Y/n] or enter new name: " response

    case "$response" in
        ""|y|Y)
            # Accept normalized name
            echo "$normalized"
            return 0
            ;;
        n|N)
            # Reject - ask for new name
            read -p "Enter new session name: " new_name
            if [[ -z "$new_name" ]]; then
                echo "$(date '+%Y-%m-%d_%H-%M')"  # Default to auto-named
            else
                # Recursively normalize and confirm the new name
                local new_normalized=$(normalize_session_name "$new_name")
                confirm_or_adjust_session_name "$new_name" "$new_normalized"
            fi
            ;;
        *)
            # They entered a new name directly
            local new_normalized=$(normalize_session_name "$response")
            confirm_or_adjust_session_name "$response" "$new_normalized"
            ;;
    esac
}

ensure_session() {
    local session_name="$1"
    local sessions_root="${2:-.claude/ccy}"
    local session_dir="$sessions_root/sessions/$session_name"
    local sessions_json="$sessions_root/sessions/sessions.json"

    # Validate session name (should already be normalized)
    if [[ ! "$session_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
        print_error "Invalid session name: $session_name"
        echo "Session names must contain only letters, numbers, hyphens, and underscores" >&2
        return 1
    fi

    # Create session if it doesn't exist
    if [[ ! -d "$session_dir" ]]; then
        mkdir -p "$session_dir"
        chmod 700 "$session_dir"

        # Add to registry (if jq available)
        if command -v jq &> /dev/null; then
            local temp_json=$(mktemp)
            jq --arg name "$session_name" \
               --arg created "$(date -Iseconds)" \
               --arg desc "Session created $(date '+%Y-%m-%d %H:%M')" \
               '.sessions[$name] = {
                   "created": $created,
                   "last_used": $created,
                   "message_count": 0,
                   "last_context": "(no messages yet)"
               }' "$sessions_json" > "$temp_json" 2>/dev/null && \
               mv "$temp_json" "$sessions_json" || \
               rm -f "$temp_json"
        fi
    fi

    # Update last_used timestamp
    if command -v jq &> /dev/null; then
        local temp_json=$(mktemp)
        jq --arg name "$session_name" \
           --arg timestamp "$(date -Iseconds)" \
           '.sessions[$name].last_used = $timestamp | .last_session = $name' \
           "$sessions_json" > "$temp_json" 2>/dev/null && \
           mv "$temp_json" "$sessions_json" || \
           rm -f "$temp_json"
    fi

    echo "$session_dir"
}

# Silent deletion (no confirmation, for batch operations)
delete_session_silent() {
    local session_name="$1"
    local sessions_root="${2:-.claude/ccy}"
    local session_dir="$sessions_root/sessions/$session_name"
    local sessions_json="$sessions_root/sessions/sessions.json"

    if [[ -d "$session_dir" ]]; then
        rm -rf "$session_dir"
    fi

    # Remove from registry
    if command -v jq &> /dev/null; then
        local temp_json=$(mktemp)
        jq --arg name "$session_name" \
           'del(.sessions[$name])' \
           "$sessions_json" > "$temp_json" 2>/dev/null && \
           mv "$temp_json" "$sessions_json" || \
           rm -f "$temp_json"
    fi
}

# Delete session with confirmation
delete_session() {
    local session_name="$1"
    local sessions_root="${2:-.claude/ccy}"

    if [[ -z "$session_name" ]]; then
        print_error "Session name required"
        return 1
    fi

    local session_dir="$sessions_root/sessions/$session_name"

    if [[ ! -d "$session_dir" ]]; then
        print_error "Session not found: $session_name"
        return 1
    fi

    # Show session info
    local msg_count=$(count_session_messages "$session_dir")
    local context=$(get_session_context "$session_dir")

    echo ""
    echo "⚠️  Warning: Delete session '$session_name'?"
    echo "   Messages: $msg_count"
    if [[ "$msg_count" -gt 0 ]]; then
        echo "   Last: $context"
    fi
    echo ""
    read -p "Confirm deletion [y/N]: " confirm
    echo ""

    if [[ "$confirm" == "y" ]] || [[ "$confirm" == "Y" ]]; then
        delete_session_silent "$session_name" "$sessions_root"
        print_success "Deleted session: $session_name"
    else
        echo "Cancelled"
        return 1
    fi
}

# Check for old sessions and offer to prune
check_and_prune_old_sessions() {
    local sessions_root="${1:-.claude/ccy}"
    local sessions_json="$sessions_root/sessions/sessions.json"

    # Ensure jq is available
    if ! command -v jq &> /dev/null; then
        return 0
    fi

    # Get prune threshold from config file (default 4 days)
    local config_file="$sessions_root/config.json"
    local prune_days=$(jq -r '.auto_prune_days // 4' "$config_file" 2>/dev/null || echo "4")
    local cutoff_timestamp=$(date -d "$prune_days days ago" +%s 2>/dev/null || echo "0")

    if [[ "$cutoff_timestamp" -eq 0 ]]; then
        return 0
    fi

    # Find old sessions
    local old_sessions=$(jq -r --argjson cutoff "$cutoff_timestamp" \
        '.sessions | to_entries |
        map(select((.value.last_used | fromdateiso8601) < $cutoff)) |
        .[] | @json' "$sessions_json" 2>/dev/null)

    if [[ -z "$old_sessions" ]]; then
        return 0
    fi

    local count=$(echo "$old_sessions" | wc -l)

    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "⚠️  Found $count old session(s) (>$prune_days days)"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""

    # List old sessions
    while IFS= read -r session_json; do
        local name=$(echo "$session_json" | jq -r '.key')
        local last_used=$(echo "$session_json" | jq -r '.value.last_used')
        local last_context=$(echo "$session_json" | jq -r '.value.last_context // ""')
        local age=$(get_human_time_ago "$last_used")

        printf "  • %s (%s)\n" "$name" "$age"
        if [[ -n "$last_context" ]] && [[ "$last_context" != "(no messages yet)" ]]; then
            printf "    └─ %s\n" "$last_context"
        fi
    done <<< "$old_sessions"

    echo ""

    while true; do
        read -p "Remove these sessions? [Y/n] " confirm
        confirm=${confirm:-Y}
        echo ""

        case "$confirm" in
            Y|y|Yes|yes)
                # Delete old sessions
                while IFS= read -r session_json; do
                    local name=$(echo "$session_json" | jq -r '.key')
                    delete_session_silent "$name" "$sessions_root"
                done <<< "$old_sessions"

                print_success "Removed $count old session(s)"
                echo ""
                break
                ;;
            N|n|No|no)
                echo "Keeping old sessions"
                echo ""
                break
                ;;
            *)
                echo "Invalid choice. Please enter Y or n"
                echo ""
                ;;
        esac
    done

    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
}

# List all sessions with details
list_all_sessions() {
    local sessions_root="${1:-.claude/ccy}"
    local sessions_json="$sessions_root/sessions/sessions.json"

    if ! command -v jq &> /dev/null; then
        print_error "jq required for listing sessions"
        return 1
    fi

    if [[ ! -f "$sessions_json" ]]; then
        echo "No sessions found"
        return 0
    fi

    local sessions=$(jq -r '.sessions | to_entries |
        sort_by(.value.last_used) | reverse |
        .[] | @json' "$sessions_json" 2>/dev/null)

    if [[ -z "$sessions" ]]; then
        echo "No sessions found"
        return 0
    fi

    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "All Sessions"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""

    while IFS= read -r session_json; do
        local name=$(echo "$session_json" | jq -r '.key')
        local created=$(echo "$session_json" | jq -r '.value.created')
        local last_used=$(echo "$session_json" | jq -r '.value.last_used')
        local context=$(echo "$session_json" | jq -r '.value.last_context // "No messages yet"')
        local msg_count=$(echo "$session_json" | jq -r '.value.message_count // 0')

        local age=$(get_human_time_ago "$last_used")

        printf "• %s (%s)\n" "$name" "$age"
        printf "  └─ Last: %s\n" "$context"
        printf "  └─ Messages: %s | Created: %s\n\n" \
            "$msg_count" \
            "$(date -d "$created" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "$created")"
    done <<< "$sessions"

    echo "════════════════════════════════════════════════════════════════════════════════"
}

# Interactive session picker TUI
session_picker_tui() {
    local sessions_root="${1:-.claude/ccy}"
    local sessions_json="$sessions_root/sessions/sessions.json"

    # Check if jq is available
    if ! command -v jq &> /dev/null; then
        print_error "jq is required for session management"
        echo "" >&2
        echo "Install jq to use named sessions:" >&2
        echo "  sudo dnf install jq" >&2
        echo "" >&2
        echo "Falling back to auto-generated session name..." >&2
        echo "$(date '+%Y-%m-%d_%H-%M')"
        return 0
    fi

    # Check for old sessions and offer to prune
    check_and_prune_old_sessions "$sessions_root"

    # Get all sessions sorted by last_used
    local sessions=$(jq -r '.sessions | to_entries |
        sort_by(.value.last_used) | reverse |
        .[] | @json' "$sessions_json" 2>/dev/null)

    if [[ -z "$sessions" ]]; then
        # No sessions yet
        # Send UI to stderr so it displays (stdout gets captured by $(...))
        echo "" >&2
        echo "════════════════════════════════════════════════════════════════════════════════" >&2
        echo "Welcome to CCY - No existing sessions" >&2
        echo "════════════════════════════════════════════════════════════════════════════════" >&2
        echo "" >&2

        read -p "Session name (leave blank for $(date '+%Y-%m-%d_%H-%M')): " session_name

        if [[ -z "$session_name" ]]; then
            # Blank = auto-generate
            echo "$(date '+%Y-%m-%d_%H-%M')"  # Only this goes to stdout
        else
            # Normalize and confirm
            local normalized=$(normalize_session_name "$session_name")
            local confirmed=$(confirm_or_adjust_session_name "$session_name" "$normalized")
            echo "$confirmed"  # Only this goes to stdout
        fi
        return 0
    fi

    # Display session list with context
    # Send UI to stderr so it displays (stdout gets captured by $(...))
    echo "" >&2
    echo "════════════════════════════════════════════════════════════════════════════════" >&2
    echo "CCY Session Manager - $(basename "$PWD")" >&2
    echo "════════════════════════════════════════════════════════════════════════════════" >&2
    echo "" >&2

    # Get recent limit from config file
    local config_file="$sessions_root/config.json"
    local recent_limit=$(jq -r '.tui_recent_limit // 10' "$config_file" 2>/dev/null || echo "10")

    echo "Recent Sessions:" >&2
    echo "" >&2

    local index=1
    local session_names=()

    while IFS= read -r session_json; do
        if [[ $index -gt $recent_limit ]]; then
            break
        fi

        local name=$(echo "$session_json" | jq -r '.key')
        local created=$(echo "$session_json" | jq -r '.value.created')
        local last_used=$(echo "$session_json" | jq -r '.value.last_used')
        local context=$(echo "$session_json" | jq -r '.value.last_context // "No messages yet"')
        local msg_count=$(echo "$session_json" | jq -r '.value.message_count // 0')

        # Calculate age
        local age=$(get_human_time_ago "$last_used")

        # Format output (to stderr for display)
        printf "  %d) %s (%s)\n" "$index" "$name" "$age" >&2
        printf "     └─ Last: %s\n" "$context" >&2
        printf "     └─ Messages: %s | Created: %s\n\n" \
            "$msg_count" \
            "$(date -d "$created" '+%Y-%m-%d %H:%M' 2>/dev/null || echo "$created")" >&2

        session_names+=("$name")
        ((index++))
    done <<< "$sessions"

    echo "════════════════════════════════════════════════════════════════════════════════" >&2
    echo "" >&2

    while true; do
        read -p "Resume [1-$((index-1))], list [l], delete [d], or session name (blank for $(date '+%Y-%m-%d_%H-%M')): " choice
        echo "" >&2

        # Check if numeric selection (resume existing session)
        if [[ "$choice" =~ ^[0-9]+$ ]] && \
           [[ $choice -ge 1 ]] && \
           [[ $choice -lt $index ]]; then
            # Return selected session name (only this goes to stdout)
            echo "${session_names[$((choice-1))]}"
            return 0
        fi

        case "$choice" in
            l|L)
                # List all sessions
                list_all_sessions "$sessions_root"
                echo "" >&2
                ;;
            d|D)
                # Delete a session
                read -p "Session name to delete: " del_name
                if [[ -n "$del_name" ]]; then
                    delete_session "$del_name" "$sessions_root"
                    # Refresh and show menu again
                    session_picker_tui "$sessions_root"
                    return $?
                fi
                ;;
            "")
                # Blank = auto-generate
                echo "$(date '+%Y-%m-%d_%H-%M')"  # Only this goes to stdout
                return 0
                ;;
            *)
                # Anything else = treat as new session name, normalize and confirm
                local normalized=$(normalize_session_name "$choice")
                local confirmed=$(confirm_or_adjust_session_name "$choice" "$normalized")
                echo "$confirmed"  # Only this goes to stdout
                return 0
                ;;
        esac
    done
}

# Prompt user to confirm or rename session after work
confirm_session_name() {
    local current_name="$1"
    local session_dir="$2"
    local sessions_root="${3:-.claude/ccy}"
    local sessions_json="$sessions_root/sessions/sessions.json"

    # Check if jq available
    if ! command -v jq &> /dev/null; then
        # Can't rename without jq - just update metadata
        update_session_metadata "$current_name" "$sessions_root"
        return 0
    fi

    # Check config file for confirmation preference
    local config_file="$sessions_root/config.json"
    local should_confirm=$(jq -r '.confirm_autogenerated_names // true' "$config_file" 2>/dev/null)
    local auto_discard=$(jq -r '.auto_discard_empty_sessions // true' "$config_file" 2>/dev/null)

    # Skip confirmation if session name looks intentional (not auto-generated)
    # Auto-generated pattern: YYYY-MM-DD_HH-MM
    if [[ ! "$current_name" =~ ^[0-9]{4}-[0-9]{2}-[0-9]{2}_[0-9]{2}-[0-9]{2}$ ]]; then
        # User already named it - just update metadata
        update_session_metadata "$current_name" "$sessions_root"
        return 0
    fi

    # Check if confirmation is disabled
    if [[ "$should_confirm" != "true" ]]; then
        update_session_metadata "$current_name" "$sessions_root"
        return 0
    fi

    # Get session context to show user what they worked on
    local context=$(get_session_context "$session_dir")
    local msg_count=$(count_session_messages "$session_dir")

    # Auto-discard empty sessions if enabled
    if [[ "$msg_count" -eq 0 ]] && [[ "$auto_discard" == "true" ]]; then
        delete_session_silent "$current_name" "$sessions_root"
        echo ""
        echo "Empty session discarded."
        return 0
    fi

    # Don't prompt for empty sessions (but keep them)
    if [[ "$msg_count" -eq 0 ]]; then
        update_session_metadata "$current_name" "$sessions_root"
        return 0
    fi

    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "Session Complete"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
    echo "Current session: $current_name"
    echo "Messages: $msg_count"
    echo ""
    echo "Last activity:"
    echo "  $context"
    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
    echo "Options:"
    echo "  [Enter]  Keep current name: $current_name"
    echo "  [name]   Rename session (e.g., 'feature-auth', 'bugfix-api')"
    echo "  [d]      Delete this session (discard work - NOT RECOMMENDED)"
    echo ""

    while true; do
        read -p "Action [Enter/name/d]: " choice
        echo ""

        if [[ -z "$choice" ]]; then
            # Keep current name
            echo "✓ Session saved as: $current_name"
            update_session_metadata "$current_name" "$sessions_root"
            return 0

        elif [[ "$choice" == "d" ]] || [[ "$choice" == "D" ]]; then
            # Delete session - require confirmation
            echo "⚠️  WARNING: This will DELETE all work from this session!"
            echo "   Messages: $msg_count"
            echo ""
            read -p "Are you absolutely sure? Type 'DELETE' to confirm: " confirm
            echo ""

            if [[ "$confirm" == "DELETE" ]]; then
                delete_session_silent "$current_name" "$sessions_root"
                echo "Session deleted."
                return 0
            else
                echo "Cancelled. Session preserved."
                echo ""
                # Loop back to main prompt
                continue
            fi

        else
            # Rename session
            local new_name="$choice"

            # Validate new name
            if [[ ! "$new_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
                echo "❌ Invalid session name: $new_name"
                echo "   Names must contain only letters, numbers, hyphens, and underscores"
                echo ""
                continue
            fi

            # Check if name already exists
            local target_dir="$sessions_root/sessions/$new_name"
            if [[ -d "$target_dir" ]] && [[ "$new_name" != "$current_name" ]]; then
                echo "❌ Session already exists: $new_name"
                echo ""
                read -p "Overwrite existing session? [y/N] " overwrite
                echo ""

                if [[ "$overwrite" != "y" ]] && [[ "$overwrite" != "Y" ]]; then
                    echo "Cancelled. Choose a different name."
                    echo ""
                    continue
                fi

                # Delete existing session
                delete_session_silent "$new_name" "$sessions_root"
            fi

            # Rename session directory
            mv "$session_dir" "$target_dir"

            # Update metadata registry
            local temp_json=$(mktemp)
            jq --arg old "$current_name" \
               --arg new "$new_name" \
               '.sessions[$new] = .sessions[$old] | del(.sessions[$old])' \
               "$sessions_json" > "$temp_json" 2>/dev/null && \
               mv "$temp_json" "$sessions_json" || \
               rm -f "$temp_json"

            # Update metadata with new name
            update_session_metadata "$new_name" "$sessions_root"

            echo "✓ Session renamed: $current_name → $new_name"
            return 0
        fi
    done
}

# Fork session (copy state)
fork_session() {
    local from_name="$1"
    local to_name="$2"
    local sessions_root="${3:-.claude/ccy}"

    if [[ -z "$from_name" ]] || [[ -z "$to_name" ]]; then
        print_error "Usage: fork_session <from> <to>"
        return 1
    fi

    local from_dir="$sessions_root/sessions/$from_name"
    local to_dir="$sessions_root/sessions/$to_name"

    if [[ ! -d "$from_dir" ]]; then
        print_error "Source session not found: $from_name"
        return 1
    fi

    if [[ -d "$to_dir" ]]; then
        print_error "Target session already exists: $to_name"
        return 1
    fi

    # Copy session directory
    cp -r "$from_dir" "$to_dir"

    # Add to registry
    if command -v jq &> /dev/null; then
        local sessions_json="$sessions_root/sessions/sessions.json"
        local temp_json=$(mktemp)
        jq --arg from "$from_name" \
           --arg to "$to_name" \
           --arg created "$(date -Iseconds)" \
           '.sessions[$to] = (.sessions[$from] + {
               "created": $created,
               "last_used": $created,
               "forked_from": $from
           })' "$sessions_json" > "$temp_json" 2>/dev/null && \
           mv "$temp_json" "$sessions_json" || \
           rm -f "$temp_json"
    fi

    print_success "Forked session: $from_name → $to_name"
}

# Export all functions
# Verify sessions directory .gitignore is properly configured
verify_sessions_gitignore() {
    local sessions_root="${1:-.claude/ccy}"
    local sessions_dir="$sessions_root/sessions"
    local gitignore_file="$sessions_dir/.gitignore"

    echo ""
    echo "════════════════════════════════════════════════════════════════"
    echo "CCY Sessions .gitignore Verification"
    echo "════════════════════════════════════════════════════════════════"
    echo ""

    # Check if .gitignore exists
    if [[ ! -f "$gitignore_file" ]]; then
        echo "❌ MISSING: $gitignore_file" >&2
        echo "" >&2
        echo "This is a critical security issue!" >&2
        echo "Sessions may be committed to git without this file." >&2
        echo "" >&2
        echo "Run 'ccy' to recreate the .gitignore file." >&2
        return 1
    fi

    echo "✓ File exists: $gitignore_file"
    echo ""

    # Check content
    if grep -q "^\\*$" "$gitignore_file" && grep -q "^!.gitignore$" "$gitignore_file"; then
        echo "✓ Content verified: Ignoring all files except .gitignore"
    else
        echo "⚠  WARNING: Content may be corrupted" >&2
        echo "" >&2
        echo "Expected patterns:" >&2
        echo "  - '*' (ignore everything)" >&2
        echo "  - '!.gitignore' (except .gitignore itself)" >&2
        echo "" >&2
        echo "Run 'ccy' to fix the .gitignore file." >&2
        return 1
    fi

    # Check git status
    if command -v git &> /dev/null && git rev-parse --git-dir &> /dev/null 2>&1; then
        echo ""
        echo "Git Status Check:"

        # Check if sessions directory is tracked
        if git ls-files --error-unmatch "$sessions_dir" &> /dev/null 2>&1; then
            echo "⚠  WARNING: Sessions directory is tracked by git!" >&2
            echo "" >&2
            echo "This should not happen. Check your root .gitignore." >&2
        else
            echo "✓ Sessions directory is NOT tracked by git (correct)"
        fi

        # Check if .gitignore itself is tracked
        if git ls-files --error-unmatch "$gitignore_file" &> /dev/null 2>&1; then
            echo "✓ .gitignore file IS tracked by git (correct)"
        else
            echo "⚠  .gitignore file is NOT tracked (should be committed)"
        fi
    fi

    echo ""
    echo "════════════════════════════════════════════════════════════════"
    echo ""

    return 0
}

export -f get_session_dir
export -f init_sessions_dir
export -f get_session_context
export -f count_session_messages
export -f get_human_time_ago
export -f update_session_metadata
export -f ensure_session
export -f delete_session_silent
export -f delete_session
export -f check_and_prune_old_sessions
export -f list_all_sessions
export -f session_picker_tui
export -f confirm_session_name
export -f fork_session
export -f verify_sessions_gitignore
