#!/bin/bash
# Claude Code YOLO Mode Wrapper
# Runs Claude Code with --dangerously-skip-permissions in isolated Docker container
# IMPORTANT: Uses separate token storage from desktop Claude Code to prevent OAuth conflicts
#
# Version: 2.6.0 - Enhanced network naming and connect error handling
#
# IMPORTANT: When modifying this script, ALWAYS increment CCY_VERSION!
# The hash validates script integrity - if hash changes but version doesn't,
# users will get a warning that version wasn't properly updated.
#
CCY_VERSION="2.12.0"  # Fix: Auto-add DNS servers to networks for WARP/localhost DNS compatibility

# Load shared helpers
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
if [ -f "$SCRIPT_DIR/lib/common.bash" ]; then
    source "$SCRIPT_DIR/lib/common.bash"
else
    # Fallback if library not found
    echo "ERROR: Shared library not found at $SCRIPT_DIR/lib/common.bash" >&2
    exit 1
fi

# Load specialized libraries
for lib in token-management ssh-handling network-management dockerfile-custom ui-helpers; do
    if [ -f "$SCRIPT_DIR/lib/$lib.bash" ]; then
        source "$SCRIPT_DIR/lib/$lib.bash"
    else
        print_error "Required library not found: $SCRIPT_DIR/lib/$lib.bash"
        exit 1
    fi
done

# IMPORTANT: When modifying the Dockerfile, ALWAYS increment REQUIRED_CONTAINER_VERSION!
# This ensures users automatically rebuild when critical container changes are made.
REQUIRED_CONTAINER_VERSION="1.2"

set -e

# Debug output helper - only prints when DEBUG_MODE=true
# Usage: debug "message"
debug() {
    [[ "$DEBUG_MODE" = true ]] && echo "DEBUG: $*" || true
}

# Calculate script hash (exclude this variable line to avoid circular dependency)
CCY_HASH=$(grep -v '^CCY_HASH=' "$0" | md5sum | cut -d' ' -f1 | cut -c1-16)

# Configuration file schema version
CONFIG_VERSION=1

# Fail fast: Must be run from a git repository root
check_git_repo || exit 1

# Get project name from directory (used for container naming)
# Uses parent-project format to avoid collisions (defined in lib/common.bash)
PROJECT_NAME=$(get_project_name)

IMAGE_NAME="claude-yolo:latest"
DOCKERFILE_DIR="/opt/claude-yolo"
CCY_ROOT="$HOME/.claude-tokens/ccy"
TOKEN_DIR="$CCY_ROOT/tokens"
PROJECT_DIR="$CCY_ROOT/projects"
VERSION_CHECK_CACHE="$HOME/.cache/claude-yolo-version-check"

# Show version if requested
if [ "$1" = "--version" ] || [ "$1" = "-v" ]; then
    echo "ccy version $CCY_VERSION"
    echo "Hash: $CCY_HASH"
    exit 0
fi

# Show help if requested
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    cat << 'EOF'
Claude Code YOLO Mode (ccy) - Container-based execution with --dangerously-skip-permissions

Usage: ccy [OPTIONS] [CLAUDE_ARGS...]

Session Management (disabled by default, enable with --sessions or CCY_SESSIONS=1):
  --sessions             Enable named sessions (shows TUI picker)
  --session [NAME]       Start/resume named session (implicitly enables sessions)
  --new [NAME]           Force new session (auto-named if no name provided)
  --list-sessions        List all sessions with details
  --delete-session NAME  Delete a specific session
  --fork-session FROM TO Fork an existing session to a new name
  --verify-sessions      Verify .gitignore protection is working correctly

Wrapper Options:
  --rebuild              Force rebuild of container image (clears cache)
  --debug                Enable debug output (bash -x)
  --engine ENGINE        Use specific container engine (docker/podman, default: podman)
  --ssh-key PATH         SSH private key to mount (can be specified multiple times)
  --no-ssh               Skip SSH key selection (git push will not work)
  --token NAME           Use specific named token
  --create-token         Create a new named token
  --list-tokens          List available tokens
  --network NETWORK      Auto-connect to specified container network on launch
  --no-network           Skip network auto-detection
  --connect [NETWORK]    Connect running container to network
  --custom               Create/edit custom project Dockerfile interactively
  --custom-docker        AI-guided Dockerfile creation and customization
  --prompt "text"        Start Claude Code with a preseeded prompt
  --headless             Run in headless mode (requires --prompt)
  --help, -h             Show this help message

All other arguments are passed directly to Claude Code with --dangerously-skip-permissions

Features:
  â€¢ Fresh start each launch (history preserved, no forced resume)
  â€¢ Pass --resume explicitly to continue previous conversation
  â€¢ Optional named sessions with --sessions flag or CCY_SESSIONS=1 env var
  â€¢ Runs in isolated Docker container with git/gh
  â€¢ Long-lived OAuth tokens (sk-ant-oat01-...) - same as GitHub Actions
  â€¢ Named tokens with expiry tracking for multiple Claude accounts
  â€¢ Automatic expiry checking - forces new token when expired
  â€¢ Checks for Claude Code updates once per day (cached)
  â€¢ Mounts current directory as /workspace
  â€¢ Files created have correct host user ownership
  â€¢ Project-specific container extensions via .claude/ccy/Dockerfile

Security:
  âš   YOLO mode bypasses all permission checks
  âœ“  Container isolation prevents unintended host access
  âœ“  Cannot run as root user (safety check)
  âœ“  Tokens isolated from desktop Claude Code

Examples:
  ccy                           # Start fresh (history preserved, no auto-resume)
  ccy "implement feature X"     # Start with specific task
  ccy --resume                  # Resume previous conversation explicitly
  ccy --prompt "fix the bug"    # Start interactive session with prompt
  ccy --headless --prompt "run tests"  # Run in headless mode
  ccy --top                     # Container manager: list/stop all CCY containers

  # Named sessions (opt-in):
  ccy --sessions                # Enable sessions, show TUI picker
  ccy --session feature-auth    # Resume or create "feature-auth" session
  ccy --new bugfix-api          # Force new session named "bugfix-api"
  CCY_SESSIONS=1 ccy            # Enable sessions via env var

  # Token management:
  ccy --create-token            # Create a new named token
  ccy --token personal          # Use "personal" token
  ccy --list-tokens             # List available tokens

Custom Dockerfile (Quick template-based):
  ccy --custom                  # Template selection workflow
  > Select template (ansible/golang/project-template)
  > Choose: Claude customization, manual edit, or use as-is
  > Quick setup for known tech stacks

Custom Dockerfile (AI-guided planning):
  ccy --custom-docker           # Comprehensive workflow with planning
  > Claude enters planning mode
  > Investigates project structure (package.json, go.mod, etc.)
  > Asks questions about your needs
  > Proposes features for approval
  > Creates/updates Dockerfile with validation
  > Exit, run 'ccy --rebuild', then 'ccy'

Network Management (run in separate terminal while ccy is running):
  ccy --connect                 # Interactive network selection
  ccy --connect myproject_default  # Connect to specific network

Token Management:
  Tokens stored in: ~/.claude-tokens/ccy/tokens/
  Format: NAME.YYYY-MM-DD.token (expiry date in filename)
  Long-lived OAuth tokens (sk-ant-oat01-...) created via 'claude setup-token'
  Expiry checked on launch - forces recreation when expired or expiring today
  Desktop Claude Code (~/.claude/) is NEVER modified

Session Management (opt-in with --sessions or CCY_SESSIONS=1):
  By default, ccy uses a "default" session - history is preserved but not auto-resumed.
  Pass --resume explicitly to continue previous conversation.
  Enable named sessions for TUI picker and multiple session management.

  When enabled:
    Sessions stored in: .claude/ccy/sessions/ (gitignored, project-specific)
    Auto-generated names: YYYY-MM-DD_HH-MM (e.g., 2025-12-07_14-30)
    Session TUI picker for easy selection and auto-resume

  Configuration: .claude/ccy/config.json (COMMITTED - team preferences)
    - auto_prune_days: Age threshold for pruning (default: 4)
    - confirm_autogenerated_names: Prompt to rename on exit (default: true)
    - auto_discard_empty_sessions: Delete sessions with 0 messages (default: true)
    - tui_recent_limit: Max sessions shown in TUI (default: 10)
    - max_sessions: Soft limit for session count (default: 50)

  Session Data: .claude/ccy/sessions/ (GITIGNORED - local only)
    - sessions.json: Session metadata and registry
    - <session-name>/: Individual session directories
    - .gitignore: Self-protecting (ignores all session data)

Project-Specific Container Extensions:
  Command: ccy --custom
  Location: .claude/ccy/Dockerfile
  Image cached as: claude-yolo:<project-name>

  Workflow:
    1. Run 'ccy --custom' in your project
    2. Select a template:
       - Dockerfile.example-ansible (Ansible + testing tools)
       - Dockerfile.example-golang (Go + dev tools)
       - Dockerfile.project-template (generic, use for other stacks)
    3. Choose how to proceed:
       - Use Claude to customize (recommended)
       - Edit manually in $EDITOR
       - Use template as-is
    4. If using Claude:
       - Claude checks what's in base container
       - Scans your project files
       - Asks what tools you need
       - Edits the Dockerfile with proper cache mounts
       - Tells you to: exit, 'ccy --rebuild', 'ccy'
    5. Custom image is cached (fast subsequent starts)

  Templates include Claude instructions:
    Each template has comments telling Claude how to customize it
    Templates know what's already installed (git, gh, Node.js, npm, Claude Code)
    Templates use cache mounts for fast rebuilds

  Template Library:
    Directory: /opt/claude-yolo/custom-dockerfiles/
    Pattern: Dockerfile.<name>
    Never overwritten by ansible - safe to customize
    Add your own templates for reuse across projects

EOF

    # Check if container image exists to show Claude Code help
    if container_cmd image inspect "$IMAGE_NAME" &> /dev/null 2>&1; then
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Claude Code Help (from container):"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        # Run claude --help in container to show actual Claude Code options
        container_cmd run --rm --entrypoint claude "$IMAGE_NAME" --help 2>/dev/null || echo "Note: Container exists but Claude Code help unavailable"
    else
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Claude Code Help:"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Container image not built yet. Run 'ccy --rebuild' first to build the container,"
        echo "then run 'ccy --help' again to see Claude Code options."
    fi

    exit 0
fi

# Function to load last launch configuration for current project
# Returns 0 if valid config loaded, 1 if no config or invalid
load_launch_config() {
    local ccy_root="$1"
    local config_file="$ccy_root/.last-launch.conf"

    # Check if config exists
    if [[ ! -f "$config_file" ]]; then
        return 1  # No config, use interactive
    fi

    # Source config
    source "$config_file" 2>/dev/null || {
        echo "Warning: Config file corrupted, reconfiguring..." >&2
        rm -f "$config_file"
        return 1
    }

    # Validate CONFIG_VERSION (schema version)
    if [[ "${SAVED_CONFIG_VERSION:-0}" != "$CONFIG_VERSION" ]]; then
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "âš ï¸  Config schema outdated" >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "Saved config:  v${SAVED_CONFIG_VERSION:-0}" >&2
        echo "Expected:      v${CONFIG_VERSION}" >&2
        echo "" >&2
        echo "Your saved launch configuration uses an old format." >&2
        echo "Reconfiguring with interactive prompts..." >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "" >&2
        rm -f "$config_file"
        return 1
    fi

    # Validate CCY_VERSION and CCY_HASH together
    local version_match=false
    local hash_match=false

    [[ "${CCY_VERSION}" == "${SAVED_CCY_VERSION:-}" ]] && version_match=true
    [[ "${CCY_HASH}" == "${SAVED_CCY_HASH:-}" ]] && hash_match=true

    if $version_match && $hash_match; then
        # Perfect match - config is valid
        return 0

    elif $version_match && ! $hash_match; then
        # VERSION same but HASH different = Developer forgot to update version!
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "âš ï¸  DEVELOPER ERROR: CCY script modified without version bump" >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "Version:       ${CCY_VERSION} (unchanged)" >&2
        echo "Saved hash:    ${SAVED_CCY_HASH:-unknown}" >&2
        echo "Current hash:  ${CCY_HASH}" >&2
        echo "" >&2
        echo "The CCY script has been modified but CCY_VERSION was not updated." >&2
        echo "This is a developer error - version numbers must be incremented" >&2
        echo "when the script changes to ensure config compatibility." >&2
        echo "" >&2
        echo "Forcing reconfiguration for safety..." >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "" >&2
        rm -f "$config_file"
        return 1

    elif ! $version_match; then
        # VERSION different = Normal upgrade/downgrade
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "â„¹ï¸  CCY version changed" >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "Saved config:  v${SAVED_CCY_VERSION:-unknown}" >&2
        echo "Current CCY:   v${CCY_VERSION}" >&2
        echo "" >&2
        echo "Reconfiguring for compatibility with new version..." >&2
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”" >&2
        echo "" >&2
        rm -f "$config_file"
        return 1
    fi
}

# Function to save launch configuration for current project
save_launch_config() {
    local ccy_root="$1"
    local token_name="$2"
    local ssh_keys_str="$3"
    local network="$4"

    local config_file="$ccy_root/.last-launch.conf"

    cat > "$config_file" <<EOF
# CCY Launch Configuration
# Config Version: ${CONFIG_VERSION}
# CCY Version: ${CCY_VERSION}
# CCY Hash: ${CCY_HASH}
# Generated: $(date '+%Y-%m-%d %H:%M:%S')
SAVED_CONFIG_VERSION=${CONFIG_VERSION}
SAVED_CCY_VERSION="${CCY_VERSION}"
SAVED_CCY_HASH="${CCY_HASH}"
LAST_TOKEN="${token_name}"
LAST_SSH_KEYS="${ssh_keys_str}"
LAST_NETWORK="${network}"
LAST_LAUNCH_DATE="$(date '+%Y-%m-%d')"
EOF

    chmod 600 "$config_file"
}

# Check for wrapper flags
FORCE_REBUILD=false
DEBUG_MODE=false
SSH_KEYS=()
CLAUDE_ARGS=()
NEXT_IS_SSH_KEY=false
NEXT_IS_TOKEN=false
NEXT_IS_CONNECT=false
NEXT_IS_NETWORK=false
NEXT_IS_PROMPT=false
NEXT_IS_SESSION=false
NEXT_IS_DELETE_SESSION=false
NEXT_IS_FORK_FROM=false
NEXT_IS_FORK_TO=false
NEXT_IS_ENGINE=false
SPECIFIED_TOKEN=""
CREATE_TOKEN_MODE=false
LIST_TOKENS_MODE=false
CONNECT_MODE=false
CUSTOM_MODE=false
CONNECT_NETWORK=""
NO_SSH_MODE=false
SPECIFIED_NETWORK=""
NETWORK_FROM_CONFIG=false
NO_NETWORK_MODE=false
HEADLESS_MODE=false
PROMPT_TEXT=""
SESSION_NAME=""
NEW_SESSION_MODE=false
LIST_SESSIONS_MODE=false
DELETE_SESSION_NAME=""
FORK_SESSION_MODE=false
FORK_FROM=""
FORK_TO=""
VERIFY_SESSIONS_MODE=false
# Sessions disabled by default - enable with CCY_SESSIONS=1 or --sessions flag
SESSIONS_ENABLED="${CCY_SESSIONS:-false}"
[[ "$SESSIONS_ENABLED" == "1" || "$SESSIONS_ENABLED" == "true" ]] && SESSIONS_ENABLED=true || SESSIONS_ENABLED=false

for arg in "$@"; do
    if [ "$NEXT_IS_ENGINE" = true ]; then
        # Validate engine choice
        if [[ "$arg" != "docker" ]] && [[ "$arg" != "podman" ]]; then
            print_error "Invalid container engine: $arg"
            echo "Valid options: docker, podman" >&2
            exit 1
        fi
        # Check if engine is available
        if ! command -v "$arg" &>/dev/null; then
            print_error "Container engine '$arg' not found"
            echo "Please install $arg or use a different engine" >&2
            exit 1
        fi
        CONTAINER_ENGINE="$arg"
        export CONTAINER_ENGINE
        NEXT_IS_ENGINE=false
    elif [ "$NEXT_IS_SSH_KEY" = true ]; then
        if [ ! -f "$arg" ]; then
            print_error "SSH key not found: $arg"
            exit 1
        fi
        SSH_KEYS+=("$arg")
        NEXT_IS_SSH_KEY=false
    elif [ "$NEXT_IS_TOKEN" = true ]; then
        SPECIFIED_TOKEN="$arg"
        NEXT_IS_TOKEN=false
    elif [ "$NEXT_IS_CONNECT" = true ]; then
        CONNECT_NETWORK="$arg"
        NEXT_IS_CONNECT=false
    elif [ "$NEXT_IS_NETWORK" = true ]; then
        SPECIFIED_NETWORK="$arg"
        NEXT_IS_NETWORK=false
    elif [ "$NEXT_IS_PROMPT" = true ]; then
        PROMPT_TEXT="$arg"
        NEXT_IS_PROMPT=false
    elif [ "$NEXT_IS_SESSION" = true ]; then
        SESSION_NAME="$arg"
        NEXT_IS_SESSION=false
    elif [ "$NEXT_IS_DELETE_SESSION" = true ]; then
        DELETE_SESSION_NAME="$arg"
        NEXT_IS_DELETE_SESSION=false
    elif [ "$NEXT_IS_FORK_FROM" = true ]; then
        FORK_FROM="$arg"
        NEXT_IS_FORK_FROM=false
        NEXT_IS_FORK_TO=true
    elif [ "$NEXT_IS_FORK_TO" = true ]; then
        FORK_TO="$arg"
        NEXT_IS_FORK_TO=false
    elif [ "$arg" = "--session" ]; then
        NEXT_IS_SESSION=true
    elif [ "$arg" = "--new" ]; then
        NEW_SESSION_MODE=true
        NEXT_IS_SESSION=true  # Can optionally provide name
    elif [ "$arg" = "--list-sessions" ]; then
        LIST_SESSIONS_MODE=true
    elif [ "$arg" = "--delete-session" ]; then
        NEXT_IS_DELETE_SESSION=true
    elif [ "$arg" = "--fork-session" ]; then
        FORK_SESSION_MODE=true
        NEXT_IS_FORK_FROM=true
    elif [ "$arg" = "--verify-sessions" ]; then
        VERIFY_SESSIONS_MODE=true
    elif [ "$arg" = "--sessions" ]; then
        SESSIONS_ENABLED=true
    elif [ "$arg" = "--rebuild" ]; then
        FORCE_REBUILD=true
    elif [ "$arg" = "--no-ssh" ]; then
        NO_SSH_MODE=true
    elif [ "$arg" = "--no-network" ]; then
        NO_NETWORK_MODE=true
    elif [ "$arg" = "--headless" ]; then
        HEADLESS_MODE=true
    elif [ "$arg" = "--prompt" ]; then
        NEXT_IS_PROMPT=true
    elif [ "$arg" = "--debug" ]; then
        DEBUG_MODE=true
        DEBUG_LOG="/tmp/ccy-debug-$(date +%Y%m%d-%H%M%S).log"
        # Redirect all output to both terminal and log file
        exec > >(tee -a "$DEBUG_LOG") 2>&1
        set -x
        echo "Debug logging to: $DEBUG_LOG"
    elif [ "$arg" = "--engine" ]; then
        NEXT_IS_ENGINE=true
    elif [ "$arg" = "--ssh-key" ]; then
        NEXT_IS_SSH_KEY=true
    elif [ "$arg" = "--token" ]; then
        NEXT_IS_TOKEN=true
    elif [ "$arg" = "--create-token" ]; then
        CREATE_TOKEN_MODE=true
    elif [ "$arg" = "--list-tokens" ]; then
        LIST_TOKENS_MODE=true
    elif [ "$arg" = "--network" ]; then
        NEXT_IS_NETWORK=true
    elif [ "$arg" = "--connect" ]; then
        CONNECT_MODE=true
        NEXT_IS_CONNECT=true
    elif [ "$arg" = "--custom" ]; then
        CUSTOM_MODE=true
    elif [ "$arg" = "--custom-docker" ]; then
        CUSTOM_DOCKER_MODE=true
    elif [ "$arg" = "--top" ]; then
        TOP_MODE=true
    else
        CLAUDE_ARGS+=("$arg")
    fi
done

# Ensure directory structure exists early
mkdir -p "$CCY_ROOT"
chmod 700 "$CCY_ROOT"
mkdir -p "$TOKEN_DIR"
chmod 700 "$TOKEN_DIR"
mkdir -p "$PROJECT_DIR"
chmod 700 "$PROJECT_DIR"

# Validate --headless requires --prompt
if [ "$HEADLESS_MODE" = true ]; then
    if [ -z "$PROMPT_TEXT" ]; then
        print_error "--headless flag requires --prompt with content"
        echo "" >&2
        echo "Usage:" >&2
        echo "  ccy --headless --prompt \"your prompt here\"" >&2
        echo "" >&2
        echo "The --headless flag runs Claude Code in non-interactive mode," >&2
        echo "which requires a prompt to execute." >&2
        exit 1
    fi
fi

# Handle --top mode (global container management - doesn't need git repo)
if [ "$TOP_MODE" = true ]; then
    show_container_top "yolo"
    exit 0
fi

# Handle list tokens mode (doesn't need SSH/GH setup)
if [ "$LIST_TOKENS_MODE" = true ]; then
    list_tokens "$TOKEN_DIR" "ccy"
    exit 0
fi

# Handle connect mode (doesn't need SSH/GH setup)
if [ "$CONNECT_MODE" = true ]; then
    connect_to_network "$CONNECT_NETWORK" "_yolo" "ccy"
    exit 0
fi

# Handle custom mode (doesn't need SSH/GH setup)
if [ "$CUSTOM_MODE" = true ]; then
    custom_dockerfile "$0" ".claude/ccy" "ccy"
    exit 0
fi

# Handle custom-docker mode (AI-guided Dockerfile creation)
if [ "$CUSTOM_DOCKER_MODE" = true ]; then
    create_dockerfile_guided "$0" ".claude/ccy" "ccy"
    exit 0
fi

# Initialize sessions directory (required for session commands)
init_sessions_dir ".claude/ccy"

# Handle session commands (don't need full setup)
if [ "$LIST_SESSIONS_MODE" = true ]; then
    list_all_sessions ".claude/ccy"
    exit 0
fi

if [ -n "$DELETE_SESSION_NAME" ]; then
    delete_session "$DELETE_SESSION_NAME" ".claude/ccy"
    exit 0
fi

if [ "$FORK_SESSION_MODE" = true ]; then
    if [ -z "$FORK_FROM" ] || [ -z "$FORK_TO" ]; then
        print_error "Fork requires both source and target names"
        echo "Usage: ccy --fork-session <from> <to>" >&2
        exit 1
    fi
    fork_session "$FORK_FROM" "$FORK_TO" ".claude/ccy"
    exit 0
fi

if [ "$VERIFY_SESSIONS_MODE" = true ]; then
    verify_sessions_gitignore ".claude/ccy"
    exit $?
fi

# Try to load previous launch configuration (if no flags specified)
CONFIG_LOADED=false
SAVED_NETWORK=""

if [[ "$NO_SSH_MODE" = false ]] && [[ ${#SSH_KEYS[@]} -eq 0 ]] && \
   [[ -z "$SPECIFIED_TOKEN" ]] && [[ -z "$SPECIFIED_NETWORK" ]] && \
   [[ "$NO_NETWORK_MODE" = false ]]; then
    # No flags provided - try to load config
    if load_launch_config ".claude/ccy"; then
        CONFIG_LOADED=true

        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "Quick Launch Available"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Found previous launch configuration (${LAST_LAUNCH_DATE:-unknown}):"
        echo "  Token:   ${LAST_TOKEN:-none}"
        echo "  SSH Key: ${LAST_SSH_KEYS:-none}"
        echo "  Network: ${LAST_NETWORK:-none}"
        echo ""

        while true; do
            read -p "Use same configuration? [Y/n] " use_config
            use_config=${use_config:-Y}
            echo ""

            case "$use_config" in
                Y|y|Yes|yes)
                    echo "Quick launching with previous configuration..."
                    echo ""

                    # Load config values
                    if [[ -n "$LAST_TOKEN" ]]; then
                        SPECIFIED_TOKEN="$LAST_TOKEN"
                    fi
                    if [[ -n "$LAST_SSH_KEYS" ]]; then
                        IFS=' ' read -ra SSH_KEYS <<< "$LAST_SSH_KEYS"
                    fi
                    if [[ -n "$LAST_NETWORK" ]]; then
                        SPECIFIED_NETWORK="$LAST_NETWORK"
                        NETWORK_FROM_CONFIG=true
                    fi
                    break
                    ;;
                N|n|No|no)
                    echo "Reconfiguring with interactive prompts..."
                    echo ""
                    CONFIG_LOADED=false
                    break
                    ;;
                *)
                    echo "Invalid choice. Please enter Y or n"
                    echo ""
                    ;;
            esac
        done

        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
    fi
fi

# Discover and select SSH keys (sets SSH_KEYS array)
# Only prompt for selection if no SSH keys specified and not in no-ssh mode
if [ "$NO_SSH_MODE" = false ] && [ ${#SSH_KEYS[@]} -eq 0 ]; then
    discover_and_select_ssh_keys "ccy"
fi

# Build SSH mounts and validate GitHub access
# This sets: SSH_MOUNTS, SSH_KEY_PATHS, GITHUB_USERNAME, GH_TOKEN
build_ssh_mounts_and_validate "ccy"

# Handle create token mode (requires SSH/GH setup for container functionality)
if [ "$CREATE_TOKEN_MODE" = true ]; then
    create_token "$TOKEN_DIR" "ccy" "$GH_TOKEN" "$IMAGE_NAME"
    exit 0
fi

# Token selection logic
SELECTED_TOKEN=""
CLAUDE_OAUTH_TOKEN=""

if [ -n "$SPECIFIED_TOKEN" ]; then
    # Token specified via --token flag
    if [[ "$SPECIFIED_TOKEN" =~ / ]]; then
        # Full path provided
        SELECTED_TOKEN="$SPECIFIED_TOKEN"
    else
        # Token name provided, find matching token with any expiry date
        matching_tokens=("$TOKEN_DIR/${SPECIFIED_TOKEN}".*.token)
        if [ -f "${matching_tokens[0]}" ]; then
            SELECTED_TOKEN="${matching_tokens[0]}"
        else
            print_error "No token found with name: $SPECIFIED_TOKEN"
            echo ""
            echo "Available tokens:"
            list_tokens "$TOKEN_DIR" "ccy"
            exit 1
        fi
    fi

    if [ ! -f "$SELECTED_TOKEN" ]; then
        print_error "Token file not found: $SELECTED_TOKEN"
        echo ""
        echo "Available tokens:"
        list_tokens "$TOKEN_DIR" "ccy"
        exit 1
    fi

    # Check if token is expired or expiring today
    if ! is_token_valid "$SELECTED_TOKEN"; then
        local filename=$(basename "$SELECTED_TOKEN")
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "âš   TOKEN EXPIRED OR EXPIRING TODAY"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Token: $filename"
        echo ""
        echo "This token cannot be used. You must create a new token."
        echo ""
        read -p "Create a new token now? (Y/n): " create_now
        if [ "$create_now" != "n" ] && [ "$create_now" != "N" ]; then
            create_token "$TOKEN_DIR" "ccy" "$GH_TOKEN" "$IMAGE_NAME"
        fi
        echo "Cancelled. Create a token with: ccy --create-token"
        exit 1
    fi

    filename=$(basename "$SELECTED_TOKEN")
    token_name="${filename%.*.token}"
    echo "âœ“ Using token: $token_name"
else
    # No token specified, check if tokens exist
    if [ ! -d "$TOKEN_DIR" ] || [ -z "$(ls -A "$TOKEN_DIR"/*.token 2>/dev/null)" ]; then
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "No Claude Code Tokens Found"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "ccy uses long-lived OAuth tokens for container authentication."
        echo ""
        echo "You need to create a token before using ccy."
        echo ""
        read -p "Create a token now? (Y/n): " create_now

        if [ "$create_now" = "n" ] || [ "$create_now" = "N" ]; then
            echo "Cancelled. Create a token later with: ccy --create-token"
            exit 0
        fi

        # Jump directly to token creation
        create_token "$TOKEN_DIR" "ccy" "$GH_TOKEN" "$IMAGE_NAME"
        exit 0
    else
        # Multiple tokens exist or single token - show selection
        select_token "$TOKEN_DIR" "ccy" || {
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "No Valid Tokens Available"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "All tokens are expired or expiring today."
            echo "You must create a new token."
            echo ""
            read -p "Create a token now? (Y/n): " create_now
            if [ "$create_now" != "n" ] && [ "$create_now" != "N" ]; then
                create_token "$TOKEN_DIR" "ccy" "$GH_TOKEN" "$IMAGE_NAME"
            fi
            echo "Cancelled. Create a token with: ccy --create-token"
            exit 1
        }
    fi
fi

# Load token content (it's just the token string)
CLAUDE_OAUTH_TOKEN=$(cat "$SELECTED_TOKEN")
if [ -z "$CLAUDE_OAUTH_TOKEN" ]; then
    print_error "Token file is empty: $SELECTED_TOKEN"
    exit 1
fi

if ! [[ "$CLAUDE_OAUTH_TOKEN" =~ ^sk-ant-oat01- ]]; then
    print_error "Invalid token format in file: $SELECTED_TOKEN"
    echo "Token must start with 'sk-ant-oat01-'"
    exit 1
fi

# Get current user's UID and GID for proper file ownership
HOST_UID=$(id -u)
HOST_GID=$(id -g)

# Safety check: Never run as root (UID 0)
if [ "$HOST_UID" -eq 0 ]; then
    print_error "Cannot run Claude Code YOLO mode as root user (UID 0)"
    echo "This is a security restriction for --dangerously-skip-permissions mode"
    echo "Please run this command as a regular user, not with sudo or as root"
    exit 1
fi

# Safety check: Only run in rootless mode
# Podman is rootless by default when run as non-root user
# Docker requires explicit rootless context setup
if [ "$CONTAINER_ENGINE" = "docker" ]; then
    DOCKER_CONTEXT=$(container_cmd context inspect 2>/dev/null | grep -o '"Name": *"[^"]*"' | head -1 | cut -d'"' -f4)
    if [ "$DOCKER_CONTEXT" != "rootless" ]; then
        print_error "Claude Code YOLO mode requires rootless Docker"
        echo "Current Docker context: ${DOCKER_CONTEXT:-default}"
        echo ""
        echo "This is a security requirement because:"
        echo "  â€¢ YOLO mode bypasses all permission checks"
        echo "  â€¢ Running in rootless Docker provides isolation"
        echo "  â€¢ Non-rootless Docker would give actual root privileges"
        echo ""
        echo "To set up rootless Docker:"
        echo "  1. Install: dockerd-rootless-setuptool.sh install"
        echo "  2. Switch context: docker context use rootless"
        echo ""
        echo "Or run the Docker playbook:"
        echo "  ansible-playbook playbooks/imports/optional/common/play-docker.yml"
        exit 1
    fi
fi
# Podman running as non-root is inherently rootless - no check needed

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# EXISTING CONTAINER CHECK
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Check for running containers for this project before starting a new session
# This helps users avoid accumulating containers they forgot about
if ! check_project_containers_startup "$PROJECT_NAME" "yolo"; then
    # User chose to quit
    exit 0
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# SESSION SELECTION
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Handle --new flag (force new session)
if [ "$NEW_SESSION_MODE" = true ]; then
    if [ -z "$SESSION_NAME" ]; then
        # Auto-generate name
        SESSION_NAME="$(date '+%Y-%m-%d_%H-%M')"
        echo ""
        echo "âœ“ Creating auto-named session: $SESSION_NAME"
    else
        echo ""
        echo "âœ“ Creating new session: $SESSION_NAME"
    fi
fi

# Session selection - depends on whether sessions are enabled
# Session flags (--session, --new, etc.) implicitly enable sessions
if [[ -n "$SESSION_NAME" ]] || [[ "$NEW_SESSION_MODE" = true ]]; then
    SESSIONS_ENABLED=true
fi

if [[ "$SESSIONS_ENABLED" = true ]]; then
    # Sessions enabled - show TUI if no session specified (with retry loop)
    while true; do
        if [ -z "$SESSION_NAME" ]; then
            # No session specified - show TUI
            SESSION_NAME=$(session_picker_tui ".claude/ccy")

            if [ -z "$SESSION_NAME" ]; then
                print_error "No session selected"
                exit 1
            fi
        fi

        # Check if session already exists
        SESSION_EXISTS=false
        if [ -d ".claude/ccy/sessions/$SESSION_NAME" ]; then
            SESSION_EXISTS=true
        fi

        # Ensure session exists and get directory
        SESSION_DIR=$(ensure_session "$SESSION_NAME" ".claude/ccy")

        if [ -z "$SESSION_DIR" ]; then
            # Validation failed - show TUI again
            echo ""
            print_error "Invalid session name, please try again"
            echo ""
            SESSION_NAME=""  # Reset to trigger TUI again
            continue
        fi

        # Valid session - break out of loop
        break
    done

    # Convert to absolute path for Docker mounts
    SESSION_DIR=$(cd "$SESSION_DIR" && pwd)

    # Check if session has messages for auto-resume
    SESSION_HAS_MESSAGES=false
    MESSAGE_COUNT=$(count_session_messages "$SESSION_DIR" | tail -1 | tr -d '[:space:]')

    debug "Session directory: $SESSION_DIR"
    debug "Raw message count output: '$MESSAGE_COUNT'"
    debug "history.jsonl exists: $([ -f "$SESSION_DIR/history.jsonl" ] && echo "YES" || echo "NO")"
    if [ "$DEBUG_MODE" = true ] && [ -f "$SESSION_DIR/history.jsonl" ]; then
        debug "history.jsonl size: $(wc -l < "$SESSION_DIR/history.jsonl") lines"
        debug "Lines with 'role': $(grep -c '"role":' "$SESSION_DIR/history.jsonl" 2>/dev/null || echo "0")"
    fi

    # Ensure MESSAGE_COUNT is a valid number
    if [[ "$MESSAGE_COUNT" =~ ^[0-9]+$ ]] && [[ "$MESSAGE_COUNT" -gt 0 ]]; then
        SESSION_HAS_MESSAGES=true
        debug "SESSION_HAS_MESSAGES=true (count: $MESSAGE_COUNT)"
    else
        debug "SESSION_HAS_MESSAGES=false (count: '$MESSAGE_COUNT')"
    fi

    # Show appropriate message
    echo ""
    if [ "$SESSION_EXISTS" = true ]; then
        echo "âœ“ Resuming session: $SESSION_NAME"
        if [ "$SESSION_HAS_MESSAGES" = true ]; then
            echo "  â””â”€ $MESSAGE_COUNT message(s) in history - will auto-resume conversation"
        fi
    else
        echo "âœ“ Created new session: $SESSION_NAME"
    fi

    # Set terminal title
    printf '\033]0;CCY: %s\007' "$SESSION_NAME"

    echo "âœ“ Session directory: $SESSION_DIR"
    echo ""
else
    # Sessions disabled - use persistent "default" session but don't auto-resume
    SESSION_NAME="default"

    # Ensure default session directory exists
    SESSION_DIR=$(ensure_session "$SESSION_NAME" ".claude/ccy")
    if [ -z "$SESSION_DIR" ]; then
        print_error "Failed to create default session directory"
        exit 1
    fi
    SESSION_DIR=$(cd "$SESSION_DIR" && pwd)

    # Don't auto-resume - user must explicitly pass --resume
    SESSION_HAS_MESSAGES=false
    SESSION_EXISTS=true

    # Set terminal title
    printf '\033]0;CCY: %s\007' "$PROJECT_NAME"

    # Show session info
    echo ""
    echo "âœ“ Using default session (history preserved, no auto-resume)"
    echo "  â””â”€ $SESSION_DIR"
    echo "  â””â”€ Pass --resume to continue previous conversation"
    echo "  â””â”€ Use --sessions for named session management"
    echo ""

    debug "Sessions disabled - using default session (no auto-resume): $SESSION_DIR"
fi

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# Function to check for Claude Code updates (cached daily)
check_claude_code_updates() {
    local image_name="$1"
    local cache_file="$VERSION_CHECK_CACHE"
    local cache_duration=$((24 * 60 * 60))  # 24 hours in seconds

    # Check if cache exists and is fresh (less than 24 hours old)
    if [ -f "$cache_file" ]; then
        local cache_age=$(( $(date +%s) - $(stat -c %Y "$cache_file" 2>/dev/null || echo 0) ))
        if [ "$cache_age" -lt "$cache_duration" ]; then
            # Cache is fresh, skip check
            return 0
        fi
    fi

    # Cache is stale or doesn't exist - perform check
    echo "Checking for Claude Code updates (daily check)..."

    # Get version from container
    local container_version=$(container_cmd run --rm --entrypoint claude "$image_name" --version 2>/dev/null | grep -oP '(?<=claude-code/)\d+\.\d+\.\d+' || echo "unknown")

    # Get latest version from npm (with timeout)
    local latest_version=$(timeout 5 npm view @anthropic-ai/claude-code version 2>/dev/null || echo "unknown")

    if [ "$container_version" = "unknown" ] || [ "$latest_version" = "unknown" ]; then
        # Can't determine versions, cache failure and skip notification
        mkdir -p "$(dirname "$cache_file")"
        touch "$cache_file"
        return 0
    fi

    # Cache the check result
    mkdir -p "$(dirname "$cache_file")"
    echo "container=$container_version,latest=$latest_version,checked=$(date +%s)" > "$cache_file"

    # Compare versions and notify if outdated
    if [ "$container_version" != "$latest_version" ]; then
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "ğŸ“¦ Claude Code Update Available"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "  Current version:  $container_version"
        echo "  Latest version:   $latest_version"
        echo ""
        echo "To update, rebuild the container:"
        echo "  ccy --rebuild"
        echo ""
        echo "This check runs once per day."
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
    else
        echo "âœ“ Claude Code is up to date ($container_version)"
    fi
}

# Ensure cache directory exists
mkdir -p "$(dirname "$VERSION_CHECK_CACHE")"

# Force rebuild if --rebuild flag was provided
if [ "$FORCE_REBUILD" = true ]; then
    echo "Forcing container rebuild..."
    if [ ! -f "$DOCKERFILE_DIR/Dockerfile" ]; then
        echo "Error: Dockerfile not found at $DOCKERFILE_DIR/Dockerfile"
        echo "Please run the ansible playbook: playbooks/imports/optional/common/play-install-claude-yolo.yml"
        exit 1
    fi
    build_container_with_hash "$IMAGE_NAME" "$DOCKERFILE_DIR" "--no-cache"
    # Clear version cache to force Claude Code update check
    rm -f "$VERSION_CHECK_CACHE"
    echo "âœ“ Container image rebuilt successfully"
fi

# Check if Docker image exists
if ! container_cmd image inspect "$IMAGE_NAME" &> /dev/null; then
    echo "Building Claude YOLO container image (first time setup)..."
    if [ ! -f "$DOCKERFILE_DIR/Dockerfile" ]; then
        echo "Error: Dockerfile not found at $DOCKERFILE_DIR/Dockerfile"
        echo "Please run the ansible playbook: playbooks/imports/optional/common/play-install-claude-yolo.yml"
        exit 1
    fi
    build_container_with_hash "$IMAGE_NAME" "$DOCKERFILE_DIR"
    echo "âœ“ Container image built successfully"
fi

# Validate container version and hash (auto-rebuild if needed)
if ! validate_container_version "$IMAGE_NAME" "$DOCKERFILE_DIR/Dockerfile" "$REQUIRED_CONTAINER_VERSION"; then
    # Version/hash mismatch - rebuild required
    build_container_with_hash "$IMAGE_NAME" "$DOCKERFILE_DIR"
    echo "âœ“ Container image rebuilt with version $REQUIRED_CONTAINER_VERSION"
    # Clear version cache so we check for updates after rebuild
    rm -f "$VERSION_CHECK_CACHE"
fi

# Check for Claude Code updates (cached daily)
check_claude_code_updates "$IMAGE_NAME"

# Function to find next available container name with suffix
# Note: get_next_container_name is now in lib/common.bash

# Check for project-specific Dockerfile extension
# (PROJECT_NAME already set earlier after git repo check)
PROJECT_DOCKERFILE=".claude/ccy/Dockerfile"
PROJECT_IMAGE_NAME="claude-yolo:${PROJECT_NAME}"
PROJECT_DOCKERFILE_HASH_FILE="$HOME/.cache/claude-yolo-${PROJECT_NAME}-dockerfile-hash"
PROJECT_BASE_VERSION_FILE="$HOME/.cache/claude-yolo-${PROJECT_NAME}-base-version"

if [ -f "$PROJECT_DOCKERFILE" ]; then
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âœ… Custom Dockerfile detected: .claude/ccy/Dockerfile"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "This project uses a custom container image with project-specific tools."
    echo "The container will automatically rebuild if the Dockerfile changes."
    echo ""
    echo "Project image: $PROJECT_IMAGE_NAME"
    echo "To modify: 'ccy --custom-docker' (AI-guided) or 'ccy --custom' (quick edit)"
    echo ""

    # Calculate hash of project Dockerfile (md5sum, 16 char - consistent with base)
    current_project_hash=$(md5sum "$PROJECT_DOCKERFILE" | cut -d' ' -f1 | cut -c1-16)
    previous_project_hash=""
    if [ -f "$PROJECT_DOCKERFILE_HASH_FILE" ]; then
        previous_project_hash=$(cat "$PROJECT_DOCKERFILE_HASH_FILE")
    fi

    # Get current base image version
    current_base_version=$(container_cmd image inspect "claude-yolo:latest" \
        --format '{{index .Config.Labels "claude-yolo-version"}}' 2>/dev/null || echo "unknown")

    # Get base version that project image was built with
    previous_base_version=""
    if [ -f "$PROJECT_BASE_VERSION_FILE" ]; then
        previous_base_version=$(cat "$PROJECT_BASE_VERSION_FILE")
    fi

    # Build if image doesn't exist, Dockerfile changed, base image updated, or --rebuild flag
    should_build=false
    rebuild_reason=""

    if ! container_cmd image inspect "$PROJECT_IMAGE_NAME" &> /dev/null; then
        echo "Building project-specific image (first time)..."
        should_build=true
        rebuild_reason="first time"
    elif [ "$current_project_hash" != "$previous_project_hash" ]; then
        echo "Project Dockerfile changed, rebuilding image..."
        should_build=true
        rebuild_reason="Dockerfile changed"
    elif [ "$current_base_version" != "$previous_base_version" ]; then
        echo ""
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "â„¹ï¸  Base image updated - rebuilding project image"
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo "Previous base: v$previous_base_version"
        echo "Current base:  v$current_base_version"
        echo ""
        echo "Project images inherit from claude-yolo:latest."
        echo "Rebuilding to include base image changes (e.g., tini, security fixes)..."
        echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        echo ""
        should_build=true
        rebuild_reason="base image updated"
    elif [ "$FORCE_REBUILD" = true ]; then
        echo "Force rebuild requested..."
        should_build=true
        rebuild_reason="--rebuild flag"
    else
        echo "âœ“ Using cached project image (Dockerfile and base unchanged)"
    fi

    if [ "$should_build" = true ]; then
        # Build with buildkit for better caching
        echo ""
        echo "Building with Docker BuildKit for optimal caching..."
        echo "Tip: apt/npm packages are cached between builds for speed"
        echo ""

        # Calculate project Dockerfile hash for build arg
        project_dockerfile_hash=$(md5sum "$PROJECT_DOCKERFILE" | cut -d' ' -f1 | cut -c1-16)

        # Use buildkit for cache mounts and pass Dockerfile hash
        if DOCKER_BUILDKIT=1 container_cmd build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            --build-arg DOCKERFILE_HASH="$project_dockerfile_hash" \
            -t "$PROJECT_IMAGE_NAME" \
            -f "$PROJECT_DOCKERFILE" \
            .; then

            # Save hashes and versions to track changes
            echo "$current_project_hash" > "$PROJECT_DOCKERFILE_HASH_FILE"
            echo "$current_base_version" > "$PROJECT_BASE_VERSION_FILE"
            echo ""
            echo "âœ“ Project image built successfully: $PROJECT_IMAGE_NAME"
            [ -n "$rebuild_reason" ] && echo "  Rebuild reason: $rebuild_reason"
        else
            echo ""
            print_error "Failed to build project-specific image"
            echo ""
            echo "Falling back to base image: claude-yolo:latest"
            echo ""
        fi
    fi

    # Use project-specific image if it exists
    if container_cmd image inspect "$PROJECT_IMAGE_NAME" &> /dev/null; then
        IMAGE_NAME="$PROJECT_IMAGE_NAME"
        echo "âœ“ Using project-specific image"
    fi

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
fi

# Session directory is already set from session selection above
# SESSION_DIR is set to .claude/ccy/sessions/<session-name>
echo "âœ“ Session directory: $SESSION_DIR"
echo "âœ“ Token: Long-lived OAuth (CLAUDE_CODE_OAUTH_TOKEN)"

if [ "$DEBUG_MODE" = true ]; then
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "DEBUG: Pre-mount setup"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Selected token file: $SELECTED_TOKEN"
    echo "Token exists: $([ -f "$SELECTED_TOKEN" ] && echo "YES" || echo "NO")"
    echo "Token size: $(stat -c%s "$SELECTED_TOKEN" 2>/dev/null || echo "N/A") bytes"
    echo ""
    echo "Session name: $SESSION_NAME"
    echo "Session directory: $SESSION_DIR"
    echo "Directory exists: $([ -d "$SESSION_DIR" ] && echo "YES" || echo "NO")"
    echo ""
    echo "Files in session directory:"
    ls -lah "$SESSION_DIR" 2>/dev/null || echo "  (empty or doesn't exist)"
    echo ""
fi

# Create .claude.json config in project root to skip onboarding
# Long-lived tokens via CLAUDE_CODE_OAUTH_TOKEN require this flag
project_config=".claude.json"  # In project root

if [ ! -f "$project_config" ]; then
    cat > "$project_config" <<'EOF'
{
  "hasCompletedOnboarding": true,
  "installMethod": "npm"
}
EOF
    chmod 600 "$project_config"
    debug "Created .claude.json with hasCompletedOnboarding=true"
else
    # Update existing config to ensure onboarding is complete
    if command_exists jq; then
        jq '.hasCompletedOnboarding = true' "$project_config" > "$project_config.tmp" && mv "$project_config.tmp" "$project_config"
        debug "Updated .claude.json to skip onboarding"
    fi
fi

# CRITICAL: Remove .credentials.json from session directory if it exists
# Credentials come via CLAUDE_CODE_OAUTH_TOKEN environment variable now
if [ -f "$SESSION_DIR/.credentials.json" ]; then
    debug "Found legacy .credentials.json in session directory - removing"
    rm -f "$SESSION_DIR/.credentials.json"
    debug "Removed legacy .credentials.json"
fi

if [ "$DEBUG_MODE" = true ]; then
    echo ""
    echo "Files in session directory (after setup):"
    ls -lah "$SESSION_DIR" 2>/dev/null || echo "  (empty)"
    if [ -f "$project_config" ]; then
        echo ""
        echo "Project .claude.json config:"
        ls -lh "$project_config"
    fi
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
fi

# Note:
# - Token passed via CLAUDE_CODE_OAUTH_TOKEN environment variable (no file mount)
# - Long-lived tokens (sk-ant-oat01-...) from `claude setup-token`
# - Config (.claude.json) in project root with hasCompletedOnboarding=true to skip setup
# - All Claude Code state (history, todos/, settings.json, etc.) persists in project directory
#
# This is the same approach GitHub Actions use:
# - Long-lived OAuth tokens via CLAUDE_CODE_OAUTH_TOKEN env var
# - No credential files, no refresh needed
# - Clean, simple, reliable

# Create temp directory ONLY for gitconfig (can't mount directly into container root)
CONFIG_TEMP="/tmp/claude-yolo-$$"
mkdir -p "$CONFIG_TEMP"
chmod 755 "$CONFIG_TEMP"

# Copy git config to temp location for entrypoint
if [ -f "$HOME/.gitconfig" ]; then
    cp "$HOME/.gitconfig" "$CONFIG_TEMP/gitconfig"
    chmod 644 "$CONFIG_TEMP/gitconfig"
else
    touch "$CONFIG_TEMP/gitconfig"
    chmod 644 "$CONFIG_TEMP/gitconfig"
fi

# Cleanup function
cleanup() {
    rm -rf "$CONFIG_TEMP"

    # Show debug log if in debug mode
    if [ "$DEBUG_MODE" = true ] && [ -n "$DEBUG_LOG" ]; then
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "DEBUG LOG (saved to $DEBUG_LOG)"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        cat "$DEBUG_LOG"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    fi
}
trap cleanup EXIT

# Convert SSH_KEY_PATHS array to colon-separated string
SSH_KEY_PATHS_STR=$(IFS=:; echo "${SSH_KEY_PATHS[*]}")

if [ "$DEBUG_MODE" = true ]; then
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "DEBUG: Docker run configuration"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Workspace: $PWD"
    echo "Session name: $SESSION_NAME"
    echo "Session dir: $SESSION_DIR"
    echo "Token file: $SELECTED_TOKEN"
    echo "Token type: Long-lived OAuth (CLAUDE_CODE_OAUTH_TOKEN)"
    echo "SSH keys mounted: ${#SSH_KEYS[@]}"
    echo ""
    echo "Docker command (simplified):"
    echo "  $CONTAINER_ENGINE run -it --rm \\"
    echo "    -e CLAUDE_CODE_OAUTH_TOKEN=sk-ant-oat01-... \\"
    echo "    -v $PWD:/workspace \\"
    if [ -f "$project_config" ]; then
        echo "    -v $project_config:/root/.claude.json \\"
    fi
    echo "    -v $SESSION_DIR:/root/.claude \\"
    echo "    ... (other mounts) ..."
    echo "    $IMAGE_NAME \\"
    echo "    claude --dangerously-skip-permissions ${CLAUDE_ARGS[@]}"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Debug log saved to: $DEBUG_LOG"
    echo ""
    echo "Container will start now. Once inside, you can check:"
    echo "  ls -la ~/.claude/"
    echo "  echo \$CLAUDE_CODE_OAUTH_TOKEN"
    echo ""
    echo "After exiting, review the debug log with:"
    echo "  cat $DEBUG_LOG"
    echo ""
    read -p "Press Enter to continue..."
fi

# Run container with session-specific state directory
# All Claude Code state (history, todos, conversations) persists per-session
#
# Authentication:
# - Long-lived OAuth token passed via CLAUDE_CODE_OAUTH_TOKEN environment variable
# - No credential files needed (same approach as GitHub Actions)
# - Token stored in ~/.claude-tokens/ccy/tokens/NAME.YYYY-MM-DD.token on host
#
# MOUNT ORDER MATTERS:
# 1. Config file to home directory root (RW - Claude updates numStartups, etc.)
# 2. Session directory - contains conversation history and state for this session
#
# No credentials mounted - token via environment variable

# Build mount arguments
DOCKER_MOUNTS=(
    -v "$PWD:/workspace"
)

# Mount config file if it exists (contains onboarding state, must be WRITABLE)
if [ -f "$project_config" ]; then
    DOCKER_MOUNTS+=(-v "$project_config:/root/.claude.json")
    debug "Mounting config file (writable): $project_config"
else
    debug "Config file not found: $project_config (will be created)"
fi

DOCKER_MOUNTS+=(
    -v "$SESSION_DIR:/root/.claude"
    -v "$CONFIG_TEMP:/tmp/claude-config-import:ro"
)

# Auto-detect and offer network connection
NETWORK_FLAG=""
AUTO_CONNECT_NETWORK=""

# Handle network flags
if [[ -n "$SPECIFIED_NETWORK" ]]; then
    # --network flag provided (or loaded from config)
    # Verify network exists
    if container_cmd network ls --format '{{.Name}}' | grep -q "^${SPECIFIED_NETWORK}$"; then
        # Network exists - check if services are running
        if check_and_start_compose_services "$SPECIFIED_NETWORK" "$PROJECT_NAME"; then
            # Services running (or were started)
            NETWORK_FLAG="--network $SPECIFIED_NETWORK"
            AUTO_CONNECT_NETWORK="$SPECIFIED_NETWORK"
            if [[ "$NETWORK_FROM_CONFIG" = true ]]; then
                echo "âœ“ Will connect to network: $SPECIFIED_NETWORK (from saved config)"
            else
                echo "âœ“ Will connect to network: $SPECIFIED_NETWORK (via --network flag)"
            fi
            echo ""
        else
            # No services running and user declined to start - continue without network
            echo "âš   Continuing without network connection (no services running)"
            echo ""
            SPECIFIED_NETWORK=""
        fi
    else
        # Network not found - different handling for config vs explicit flag
        if [[ "$NETWORK_FROM_CONFIG" = true ]]; then
            # From config - warn and offer to start compose
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "âš   WARNING: Saved network no longer exists"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "Network from config: $SPECIFIED_NETWORK"
            echo ""
            echo "This network was saved from your last launch but is no longer available."
            echo "Common causes:"
            echo "  â€¢ Docker Compose project stopped (docker-compose down)"
            echo "  â€¢ Docker daemon restarted"
            echo "  â€¢ Network manually deleted"
            echo ""

            # Try to restore network by starting compose
            if offer_compose_start "$SPECIFIED_NETWORK" "$PROJECT_NAME"; then
                # Compose started successfully and network found
                SPECIFIED_NETWORK="$COMPOSE_NETWORK"
                NETWORK_FLAG="--network $COMPOSE_NETWORK"
                AUTO_CONNECT_NETWORK="$COMPOSE_NETWORK"
                echo ""
            else
                # Compose not available or user declined
                echo ""
                echo "Available networks:"
                container_cmd network ls --format "  {{.Name}}" | grep -v "^bridge$\|^host$\|^none$" || echo "  (no user-defined networks found)"
                echo ""

                while true; do
                    read -p "Continue without network connection? [Y/n] " continue_choice
                    continue_choice=${continue_choice:-Y}
                    echo ""

                    case "$continue_choice" in
                        Y|y|Yes|yes)
                            echo "Continuing without network connection..."
                            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
                            echo ""
                            # Clear the network flag so we continue without it
                            SPECIFIED_NETWORK=""
                            break
                            ;;
                        N|n|No|no)
                            echo "Cancelled. Fix the network and try again:"
                            echo "  â€¢ Restart your docker-compose project"
                            echo "  â€¢ Or use: ccy --no-network"
                            echo "  â€¢ Or use: ccy --network <different-network>"
                            exit 0
                            ;;
                        *)
                            echo "Invalid choice. Please enter Y or n"
                            echo ""
                            ;;
                    esac
                done
            fi
        else
            # Explicit --network flag - this is an error
            print_error "Network not found: $SPECIFIED_NETWORK"
            echo "" >&2
            echo "Available networks:" >&2
            container_cmd network ls --format "  {{.Name}}" >&2
            exit 1
        fi
    fi
elif [[ "$NO_NETWORK_MODE" = true ]]; then
    # --no-network flag provided
    echo "âœ“ Skipping network connection (--no-network flag)"
    echo ""
else
    # No network flags - check for persisted network preference first
    PERSISTED_NETWORK=$(load_network_preference 2>/dev/null || echo "")

    if [[ -n "$PERSISTED_NETWORK" ]]; then
        # Found persisted network - verify it exists
        if container_cmd network ls --format '{{.Name}}' | grep -q "^${PERSISTED_NETWORK}$"; then
            # Network exists - check if services are running
            if check_and_start_compose_services "$PERSISTED_NETWORK" "$PROJECT_NAME"; then
                # Services running (or were started)
                SPECIFIED_NETWORK="$PERSISTED_NETWORK"
                NETWORK_FLAG="--network $PERSISTED_NETWORK"
                AUTO_CONNECT_NETWORK="$PERSISTED_NETWORK"
                echo "âœ“ Will connect to network: $PERSISTED_NETWORK (from saved preference)"
                echo ""
            else
                # No services running and user declined to start
                echo "âš   Network exists but no services running"
                echo ""
            fi
        else
            echo "âš   Saved network '$PERSISTED_NETWORK' no longer exists"
            echo ""

            # Try to restore network by starting compose
            if offer_compose_start "$PERSISTED_NETWORK" "$PROJECT_NAME"; then
                # Compose started successfully and network found
                SPECIFIED_NETWORK="$COMPOSE_NETWORK"
                NETWORK_FLAG="--network $COMPOSE_NETWORK"
                AUTO_CONNECT_NETWORK="$COMPOSE_NETWORK"
                echo ""
            fi
        fi
    fi

    # If no persisted network found, auto-detect and offer connection
    if [[ -z "$SPECIFIED_NETWORK" ]]; then
        # Check BOTH docker and podman to detect cross-engine issues
        MATCHING_NETWORKS=()
        DOCKER_NETWORKS=()
        PODMAN_NETWORKS=()
        CROSS_ENGINE_MISMATCH=false

        # Query current engine (podman or docker)
        while IFS= read -r net; do
            # Skip default networks
            if [[ "$net" != "bridge" ]] && [[ "$net" != "host" ]] && [[ "$net" != "none" ]] && [[ "$net" != "podman" ]]; then
                # Check if network name contains project name
                if [[ "$net" == *"$PROJECT_NAME"* ]]; then
                    MATCHING_NETWORKS+=("$net")
                fi
            fi
        done < <(container_cmd network ls --format "{{.Name}}" 2>/dev/null)

    # Query the OTHER engine to detect mismatches
    OTHER_ENGINE=""
    if [[ "$CONTAINER_ENGINE" = "podman" ]]; then
        OTHER_ENGINE="docker"
    else
        OTHER_ENGINE="podman"
    fi

    # Check if other engine is available
    if command -v "$OTHER_ENGINE" &>/dev/null; then
        # Get networks from other engine
        OTHER_ENGINE_NETWORKS=()
        while IFS= read -r net; do
            if [[ "$net" != "bridge" ]] && [[ "$net" != "host" ]] && [[ "$net" != "none" ]] && [[ "$net" != "podman" ]]; then
                OTHER_ENGINE_NETWORKS+=("$net")
                # Check if this network matches project name
                if [[ "$net" == *"$PROJECT_NAME"* ]]; then
                    # Found matching network in OTHER engine but not current engine
                    if [[ ${#MATCHING_NETWORKS[@]} -eq 0 ]]; then
                        CROSS_ENGINE_MISMATCH=true
                        if [[ "$CONTAINER_ENGINE" = "podman" ]]; then
                            DOCKER_NETWORKS+=("$net")
                        else
                            PODMAN_NETWORKS+=("$net")
                        fi
                    fi
                fi
            fi
        done < <("$OTHER_ENGINE" network ls --format "{{.Name}}" 2>/dev/null)
    fi

# Show cross-engine mismatch warning BEFORE normal network detection
if [[ "$CROSS_ENGINE_MISMATCH" = true ]]; then
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "âš ï¸  CROSS-ENGINE NETWORK MISMATCH DETECTED"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    if [[ "$CONTAINER_ENGINE" = "podman" ]]; then
        # CCY using Podman, but networks found in Docker
        echo "CCY is configured to use Podman, but project networks exist in Docker:"
        echo ""
        for net in "${DOCKER_NETWORKS[@]}"; do
            echo "  â€¢ $net (Docker only)"
        done
        echo ""
        echo "Problem:"
        echo "  â€¢ Docker and Podman have separate network namespaces"
        echo "  â€¢ CCY (using Podman) cannot see Docker networks"
        echo "  â€¢ Your compose setup is using Docker"
        echo ""
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "Options:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo ""
        echo "  1) Clean up Docker networks and start with Podman (recommended)"
        echo "  2) Switch CCY to use Docker instead (export CCY_CONTAINER_ENGINE=docker)"
        echo "  3) Continue without network connection"
        echo "  4) Quit"
        echo ""

        while true; do
            read -p "Select option [1-4]: " cleanup_choice
            echo ""

            case "$cleanup_choice" in
                1)
                    # Clean up Docker networks and switch to Podman
                    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                    echo "Docker Network Cleanup"
                    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                    echo ""
                    echo "  a) Remove project networks only:"
                    for net in "${DOCKER_NETWORKS[@]}"; do
                        echo "     docker network rm $net"
                    done
                    echo ""
                    echo "  b) Remove ALL unused Docker networks (docker network prune)"
                    echo ""

                    while true; do
                        read -p "Choose cleanup method [a/b]: " prune_choice
                        echo ""

                        case "$prune_choice" in
                            a|A)
                                echo "Stopping containers and removing project networks..."
                                # Stop containers on these networks first
                                for net in "${DOCKER_NETWORKS[@]}"; do
                                    # Get containers attached to this network
                                    containers=$(docker network inspect "$net" --format '{{range .Containers}}{{.Name}} {{end}}' 2>/dev/null || echo "")
                                    if [[ -n "$containers" ]]; then
                                        echo "  Stopping containers on $net: $containers"
                                        docker stop $containers 2>/dev/null || true
                                    fi
                                    echo "  Removing network: $net"
                                    docker network rm "$net" 2>/dev/null && echo "    âœ“ Removed" || echo "    âš  Could not remove (may still have containers)"
                                done
                                break
                                ;;
                            b|B)
                                echo "Stopping all Docker containers..."
                                docker ps -q | xargs -r docker stop 2>/dev/null || true
                                echo "Pruning all unused Docker networks..."
                                docker network prune -f
                                echo "âœ“ Docker networks pruned"
                                break
                                ;;
                            *)
                                echo "Invalid choice. Please enter a or b"
                                echo ""
                                ;;
                        esac
                    done
                    echo ""

                    # Now offer to start podman-compose
                    COMPOSE_FILES_FOUND=()
                    for pattern in "docker-compose.yml" "docker-compose.yaml" "podman-compose.yml" "podman-compose.yaml" "compose.yml" "compose.yaml"; do
                        if [ -f "$pattern" ]; then
                            COMPOSE_FILES_FOUND+=("$pattern")
                        fi
                    done

                    if [ ${#COMPOSE_FILES_FOUND[@]} -gt 0 ]; then
                        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                        echo "Start Podman Compose Services"
                        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                        echo ""
                        echo "Found compose files:"
                        for cf in "${COMPOSE_FILES_FOUND[@]}"; do
                            echo "  â€¢ $cf"
                        done
                        echo ""

                        if command -v podman-compose &>/dev/null; then
                            while true; do
                                read -p "Start services with podman-compose up -d? [Y/n]: " start_compose
                                start_compose=${start_compose:-Y}
                                echo ""

                                case "$start_compose" in
                                    Y|y|Yes|yes)
                                        echo "Starting podman-compose..."
                                        if podman-compose up -d; then
                                            echo ""
                                            echo "âœ“ Compose services started"
                                            echo ""
                                            echo "Waiting for networks..."
                                            sleep 2

                                            # Re-scan for Podman networks
                                            MATCHING_NETWORKS=()
                                            while IFS= read -r net; do
                                                if [[ "$net" != "bridge" ]] && [[ "$net" != "host" ]] && [[ "$net" != "none" ]] && [[ "$net" != "podman" ]]; then
                                                    if [[ "$net" == *"$PROJECT_NAME"* ]]; then
                                                        MATCHING_NETWORKS+=("$net")
                                                    fi
                                                fi
                                            done < <(podman network ls --format "{{.Name}}" 2>/dev/null)

                                            if [ ${#MATCHING_NETWORKS[@]} -gt 0 ]; then
                                                AUTO_CONNECT_NETWORK="${MATCHING_NETWORKS[0]}"
                                                NETWORK_FLAG="--network $AUTO_CONNECT_NETWORK"
                                                echo "âœ“ Found network: $AUTO_CONNECT_NETWORK"
                                                echo "âœ“ CCY will connect to this network"
                                                CROSS_ENGINE_MISMATCH=false  # Resolved!
                                            fi
                                            COMPOSE_ALREADY_HANDLED=true
                                        else
                                            echo "âš  podman-compose failed. Check errors above."
                                            COMPOSE_ALREADY_HANDLED=true
                                        fi
                                        break
                                        ;;
                                    N|n|No|no)
                                        echo "Skipping compose startup"
                                        echo "Run 'podman-compose up -d' manually when ready"
                                        COMPOSE_ALREADY_HANDLED=true
                                        break
                                        ;;
                                    *)
                                        echo "Invalid choice. Please enter y or n"
                                        echo ""
                                        ;;
                                esac
                            done
                        else
                            echo "âš  podman-compose not installed"
                            echo ""
                            echo "Install with:"
                            echo "  pip install podman-compose"
                            echo "  # Or: ansible-playbook playbooks/imports/optional/common/play-podman.yml"
                            echo ""
                            echo "Then run: podman-compose up -d"
                            COMPOSE_ALREADY_HANDLED=true
                        fi
                    else
                        COMPOSE_ALREADY_HANDLED=true  # No compose files found, mark as handled
                    fi
                    echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
                    break
                    ;;
                2)
                    echo "To use Docker instead, run:"
                    echo "  export CCY_CONTAINER_ENGINE=docker"
                    echo "  ccy"
                    echo ""
                    echo "Or add to ~/.bashrc:"
                    echo "  export CCY_CONTAINER_ENGINE=docker"
                    exit 0
                    ;;
                3)
                    echo "Continuing without network connection..."
                    COMPOSE_ALREADY_HANDLED=true
                    break
                    ;;
                4)
                    echo "Cancelled."
                    exit 0
                    ;;
                *)
                    echo "Invalid choice. Please enter 1-4"
                    echo ""
                    ;;
            esac
        done

        # Show tip about stopping Docker daemon (informational only)
        if [[ "$cleanup_choice" == "1" ]]; then
            echo ""
            echo "TIP: If you've fully switched to Podman, you can free resources by stopping Docker:"
            echo "  systemctl --user stop docker.socket docker.service"
            echo "  # Or disable permanently: systemctl --user disable --now docker.socket docker.service"
            echo ""
        fi
    else
        # CCY using Docker, but networks found in Podman
        echo "CCY is configured to use Docker, but project networks exist in Podman:"
        echo ""
        for net in "${PODMAN_NETWORKS[@]}"; do
            echo "  â€¢ $net (Podman only)"
        done
        echo ""
        echo "Problem:"
        echo "  â€¢ Docker and Podman have separate network namespaces"
        echo "  â€¢ CCY (using Docker) cannot see Podman networks"
        echo "  â€¢ Your compose setup is using Podman"
        echo ""
        echo "Choose one solution (both are valid):"
        echo ""
        echo "OPTION 1: Switch CCY to use Podman (match your compose setup)"
        echo ""
        echo "  â€¢ Remove CCY_CONTAINER_ENGINE override (defaults to Podman):"
        echo "    unset CCY_CONTAINER_ENGINE"
        echo "    ccy"
        echo ""
        echo "OPTION 2: Switch compose to use Docker (match CCY setting)"
        echo ""
        echo "  â€¢ Install Docker:"
        echo "    ansible-playbook playbooks/imports/optional/common/play-docker.yml"
        echo ""
        echo "  â€¢ Update your compose setup to use docker-compose"
        echo "  â€¢ Recreate networks with Docker"
        echo ""

        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""

        while true; do
            read -p "Continue without network connection? [Y/n] " mismatch_choice
            mismatch_choice=${mismatch_choice:-Y}
            echo ""

            case "$mismatch_choice" in
                Y|y|Yes|yes)
                    echo "Continuing without network connection..."
                    echo "Fix the mismatch and restart CCY to connect to project networks."
                    echo ""
                    break
                    ;;
                N|n|No|no)
                    echo "Cancelled. Fix the container engine mismatch first."
                    exit 0
                    ;;
                *)
                    echo "Invalid choice. Please enter Y or n"
                    echo ""
                    ;;
            esac
        done
    fi
fi

# Only prompt for network if we don't already have a persisted preference
if [ ${#MATCHING_NETWORKS[@]} -gt 0 ] && [ -z "$SPECIFIED_NETWORK" ]; then
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "Docker Network Auto-Detection"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""

    if [ ${#MATCHING_NETWORKS[@]} -eq 1 ]; then
        # Single match - offer to connect
        AUTO_CONNECT_NETWORK="${MATCHING_NETWORKS[0]}"
        echo "Found network: $AUTO_CONNECT_NETWORK"
        echo ""

        while true; do
            read -p "Connect to this network? (Y/n): " connect_choice
            connect_choice=${connect_choice:-Y}  # Default to Yes
            echo ""

            case "$connect_choice" in
                Y|y|Yes|yes)
                    # Check if services are running before connecting
                    if check_and_start_compose_services "$AUTO_CONNECT_NETWORK" "$PROJECT_NAME"; then
                        NETWORK_FLAG="--network $AUTO_CONNECT_NETWORK"
                        echo "âœ“ Will connect to: $AUTO_CONNECT_NETWORK"
                    else
                        echo "âš   Continuing without network (no services running)"
                        AUTO_CONNECT_NETWORK=""
                    fi
                    break
                    ;;
                N|n|No|no)
                    echo "Skipping network connection"
                    echo "Use 'ccy --connect' later to connect manually"
                    break
                    ;;
                *)
                    echo "Invalid choice. Please enter Y or n"
                    echo ""
                    ;;
            esac
        done
    else
        # Multiple matches - default to first, offer choice
        AUTO_CONNECT_NETWORK="${MATCHING_NETWORKS[0]}"
        echo "Found ${#MATCHING_NETWORKS[@]} matching networks"
        echo "Best match: $AUTO_CONNECT_NETWORK"
        echo ""

        while true; do
            read -p "Connect to this network? (Y/n/list): " connect_choice
            connect_choice=${connect_choice:-Y}
            echo ""

            case "$connect_choice" in
                Y|y|Yes|yes)
                    # Check if services are running before connecting
                    if check_and_start_compose_services "$AUTO_CONNECT_NETWORK" "$PROJECT_NAME"; then
                        NETWORK_FLAG="--network $AUTO_CONNECT_NETWORK"
                        echo "âœ“ Will connect to: $AUTO_CONNECT_NETWORK"
                    else
                        echo "âš   Continuing without network (no services running)"
                        AUTO_CONNECT_NETWORK=""
                    fi
                    break
                    ;;
                N|n|No|no)
                    echo "Skipping network connection"
                    echo "Use 'ccy --connect' later to connect manually"
                    AUTO_CONNECT_NETWORK=""
                    break
                    ;;
                list|l|List|L)
                    # Show full menu
                    echo "Available networks:"
                    echo ""
                    echo "  0) Don't connect"
                    for i in "${!MATCHING_NETWORKS[@]}"; do
                        echo "  $((i+1))) ${MATCHING_NETWORKS[$i]}"
                    done
                    echo ""

                    while true; do
                        read -p "Select [0-${#MATCHING_NETWORKS[@]}]: " net_choice
                        echo ""

                        if [ "$net_choice" = "0" ]; then
                            echo "Skipping network connection"
                            AUTO_CONNECT_NETWORK=""
                            break 2
                        elif [ "$net_choice" -ge 1 ] && [ "$net_choice" -le ${#MATCHING_NETWORKS[@]} ] 2>/dev/null; then
                            AUTO_CONNECT_NETWORK="${MATCHING_NETWORKS[$((net_choice-1))]}"
                            # Check if services are running before connecting
                            if check_and_start_compose_services "$AUTO_CONNECT_NETWORK" "$PROJECT_NAME"; then
                                NETWORK_FLAG="--network $AUTO_CONNECT_NETWORK"
                                echo "âœ“ Will connect to: $AUTO_CONNECT_NETWORK"
                            else
                                echo "âš   Continuing without network (no services running)"
                                AUTO_CONNECT_NETWORK=""
                            fi
                            break 2
                        else
                            echo "Invalid selection: $net_choice"
                            echo "Please enter 0-${#MATCHING_NETWORKS[@]}"
                            echo ""
                        fi
                    done
                    ;;
                *)
                    echo "Invalid choice. Please enter Y, n, or 'list'"
                    echo ""
                    ;;
            esac
        done
    fi

    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
else
    # No matching networks - offer to connect to ANY available network
    ALL_NETWORKS=()
    PODMAN_DEFAULT_DETECTED=false
    while IFS= read -r net; do
        # Skip default networks
        if [[ "$net" != "bridge" ]] && [[ "$net" != "host" ]] && [[ "$net" != "none" ]]; then
            ALL_NETWORKS+=("$net")
            # Detect Podman's default network (not project-specific)
            if [[ "$net" == "podman" ]]; then
                PODMAN_DEFAULT_DETECTED=true
            fi
        fi
    done < <(container_cmd network ls --format "{{.Name}}" 2>/dev/null)

    # Check for compose files if no matching network found (and not already handled)
    if [ ${#MATCHING_NETWORKS[@]} -eq 0 ] && [ -z "$SPECIFIED_NETWORK" ] && [ "$COMPOSE_ALREADY_HANDLED" != "true" ]; then
        # Scan for compose files in project root
        COMPOSE_FILES_FOUND=()
        for pattern in "docker-compose.yml" "docker-compose.yaml" "podman-compose.yml" "podman-compose.yaml" "compose.yml" "compose.yaml"; do
            if [ -f "$pattern" ]; then
                COMPOSE_FILES_FOUND+=("$pattern")
            fi
        done

        if [ ${#COMPOSE_FILES_FOUND[@]} -gt 0 ]; then
            echo ""
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo "Compose Files Detected"
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "Found compose files but no matching project networks are running:"
            for cf in "${COMPOSE_FILES_FOUND[@]}"; do
                echo "  â€¢ $cf"
            done
            echo ""
            echo "Would you like to start the compose services?"
            echo ""

            # Determine compose command based on engine
            COMPOSE_CMD=""
            if [[ "$CONTAINER_ENGINE" = "podman" ]]; then
                if command -v podman-compose &>/dev/null; then
                    COMPOSE_CMD="podman-compose"
                else
                    echo "Note: podman-compose not installed. Install with:"
                    echo "  pip install podman-compose"
                    echo ""
                fi
            else
                if command -v docker-compose &>/dev/null; then
                    COMPOSE_CMD="docker-compose"
                elif command -v docker &>/dev/null && docker compose version &>/dev/null 2>&1; then
                    COMPOSE_CMD="docker compose"
                fi
            fi

            if [ -n "$COMPOSE_CMD" ]; then
                while true; do
                    read -p "Start compose services? ($COMPOSE_CMD up -d) [y/N] " start_compose
                    start_compose=${start_compose:-N}
                    echo ""

                    case "$start_compose" in
                        Y|y|Yes|yes)
                            echo "Starting compose services..."
                            if $COMPOSE_CMD up -d; then
                                echo ""
                                echo "âœ“ Compose services started"
                                echo ""
                                echo "Waiting for networks to be created..."
                                sleep 2

                                # Re-scan for networks
                                MATCHING_NETWORKS=()
                                while IFS= read -r net; do
                                    if [[ "$net" != "bridge" ]] && [[ "$net" != "host" ]] && [[ "$net" != "none" ]] && [[ "$net" != "podman" ]]; then
                                        if [[ "$net" == *"$PROJECT_NAME"* ]]; then
                                            MATCHING_NETWORKS+=("$net")
                                        fi
                                    fi
                                done < <(container_cmd network ls --format "{{.Name}}" 2>/dev/null)

                                if [ ${#MATCHING_NETWORKS[@]} -gt 0 ]; then
                                    AUTO_CONNECT_NETWORK="${MATCHING_NETWORKS[0]}"
                                    NETWORK_FLAG="--network $AUTO_CONNECT_NETWORK"
                                    echo "âœ“ Found network: $AUTO_CONNECT_NETWORK"
                                    echo "âœ“ Will connect CCY to this network"
                                fi
                            else
                                echo ""
                                echo "âš  Compose failed to start. Check errors above."
                            fi
                            break
                            ;;
                        N|n|No|no|"")
                            echo "Skipping compose startup"
                            break
                            ;;
                        *)
                            echo "Invalid choice. Please enter y or n"
                            echo ""
                            ;;
                    esac
                done
            fi
            echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
        else
            # No compose files - show info message
            if [ ${#ALL_NETWORKS[@]} -gt 0 ]; then
                echo ""
                echo "No network found matching project name: $PROJECT_NAME"
                echo ""
                echo "Suggested network names:"
                echo "  â€¢ ${PROJECT_NAME}-network (folder name)"

                # Show parent-folder-repo-folder option if parent is not generic
                PARENT_FOLDER=$(basename "$(dirname "$PWD")")
                GENERIC_FOLDERS="projects|repos|work|src|code|dev|home"
                if ! echo "$PARENT_FOLDER" | grep -qiE "^($GENERIC_FOLDERS)$"; then
                    echo "  â€¢ ${PARENT_FOLDER}-${PROJECT_NAME}-network (parent-folder-repo)"
                fi

                echo ""
                echo "To connect to a network:"
                echo "  â€¢ Create: $CONTAINER_ENGINE network create ${PROJECT_NAME}-network"
                echo "  â€¢ Connect: ccy --network ${PROJECT_NAME}-network"
                echo "  â€¢ Or use: ccy --connect (interactive selection)"
                echo ""
            fi
        fi
    fi
    fi  # End of if [[ -z "$SPECIFIED_NETWORK" ]] (persisted network check)
fi
fi  # End of network flag handling (if/elif/else)

# Network Strategy: Use requested network but verify it has internet access
# =========================================================================
# Claude Code requires internet to communicate with Anthropic's API.
# Fail fast if the selected network doesn't have internet routing.

# Determine which network to use
if [[ -n "$NETWORK_FLAG" ]]; then
    SELECTED_NETWORK="${NETWORK_FLAG#--network }"
elif [[ "$CONTAINER_ENGINE" = "podman" ]] && [[ "$NO_NETWORK_MODE" != true ]]; then
    SELECTED_NETWORK="podman"
    NETWORK_FLAG="--network podman"
fi

# Ensure network has DNS servers configured (fixes WARP/localhost DNS issues)
if [[ -n "$SELECTED_NETWORK" ]] && [[ "$NO_NETWORK_MODE" != true ]]; then
    ensure_network_dns "$SELECTED_NETWORK"
fi

# Verify network has internet access (fail fast)
if [[ -n "$SELECTED_NETWORK" ]] && [[ "$NO_NETWORK_MODE" != true ]]; then
    echo "Verifying network '$SELECTED_NETWORK' has internet access..."

    # Test with google.com (simpler, more reliable than api.anthropic.com which needs proper TLS)
    if container_cmd run --rm --network "$SELECTED_NETWORK" alpine wget -q -O- --timeout=10 http://google.com >/dev/null 2>&1; then
        echo "âœ“ Network '$SELECTED_NETWORK' has internet access"
        echo ""
    else
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo "âŒ NETWORK ERROR: '$SELECTED_NETWORK' has no internet access"
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        echo ""
        echo "Claude Code requires internet to communicate with Anthropic's API."
        echo ""

        # Scan for compose files and check for common issues
        COMPOSE_FILES=$(find . -maxdepth 2 -name "*compose*.yml" -o -name "*compose*.yaml" 2>/dev/null)
        FOUND_ISSUES=false

        if [[ -n "$COMPOSE_FILES" ]]; then
            echo "Scanning compose files for common network issues..."
            echo ""

            for compose_file in $COMPOSE_FILES; do
                # Check for driver: bridge (breaks rootless podman)
                if grep -q "driver:\s*bridge" "$compose_file" 2>/dev/null; then
                    echo "  âš   $compose_file: Found 'driver: bridge'"
                    echo "     Rootless podman cannot create NAT rules for bridge networks."
                    echo "     FIX: Remove 'driver: bridge' from the networks section."
                    echo ""
                    FOUND_ISSUES=true
                fi

                # Check for internal: true
                if grep -q "internal:\s*true" "$compose_file" 2>/dev/null; then
                    echo "  âš   $compose_file: Found 'internal: true'"
                    echo "     Internal networks have no external connectivity by design."
                    echo "     FIX: Remove 'internal: true' or set to 'internal: false'."
                    echo ""
                    FOUND_ISSUES=true
                fi
            done
        fi

        if [[ "$FOUND_ISSUES" = false ]]; then
            echo "No obvious issues found in compose files."
            echo ""
        fi

        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo "Debugging steps:"
        echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
        echo ""
        echo "  1. Test the network manually:"
        echo "     podman run --rm --network $SELECTED_NETWORK alpine wget -q -O- --timeout=5 http://google.com"
        echo ""
        echo "  2. Check if rootless podman is using pasta (expected):"
        echo "     podman info | grep rootlessNetworkCmd"
        echo ""
        echo "  3. Recreate the network:"
        echo "     podman-compose down"
        echo "     podman network rm $SELECTED_NETWORK"
        echo "     podman-compose up -d"
        echo ""
        echo "  4. Use default podman network instead:"
        echo "     ccy --network podman"
        echo ""
        echo "  5. Check network config:"
        echo "     podman network inspect $SELECTED_NETWORK | grep -E 'internal|driver'"
        echo ""
        echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
        exit 1
    fi
fi

# Display command preview box and save configuration
# Extract token name from selected token file
TOKEN_NAME_FOR_CONFIG=""
if [[ -n "$SELECTED_TOKEN" ]]; then
    filename=$(basename "$SELECTED_TOKEN")
    TOKEN_NAME_FOR_CONFIG="${filename%.*.token}"
fi

# Build SSH keys string for config
SSH_KEYS_STR="${SSH_KEYS[*]}"

# Save configuration for next launch
save_launch_config ".claude/ccy" "$TOKEN_NAME_FOR_CONFIG" "$SSH_KEYS_STR" "$AUTO_CONNECT_NETWORK"
echo "âœ“ Configuration saved for quick launch next time"
echo "âœ“ CCY version: $CCY_VERSION"
echo ""

# Determine container name with appropriate suffix
CONTAINER_NAME=$(get_next_container_name "$PROJECT_NAME" "yolo")
echo "Container name: $CONTAINER_NAME"
echo ""

# Build Claude Code command arguments based on flags
CLAUDE_CMD_ARGS=()

# Auto-resume if session has existing messages (unless user provided explicit command)
if [ "$SESSION_HAS_MESSAGES" = true ] && [ "$HEADLESS_MODE" = false ] && [ -z "$PROMPT_TEXT" ] && [ ${#CLAUDE_ARGS[@]} -eq 0 ]; then
    # Session has messages - use --resume flag to enter resume UI
    CLAUDE_CMD_ARGS+=("--resume")
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo "ğŸ”„ Auto-Resume Enabled"
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
    echo "Session: $SESSION_NAME"
    echo "Messages: $MESSAGE_COUNT"
    echo "Passing: --resume flag to Claude Code"
    echo ""
    echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
    echo ""
elif [ "$HEADLESS_MODE" = true ]; then
    # Headless mode: use -p flag
    CLAUDE_CMD_ARGS+=("-p" "$PROMPT_TEXT")
elif [ -n "$PROMPT_TEXT" ]; then
    # Interactive mode with prompt: pass prompt as argument
    CLAUDE_CMD_ARGS+=("$PROMPT_TEXT")
elif [ ${#CLAUDE_ARGS[@]} -eq 0 ]; then
    # No user arguments - pass startup info via system prompt instead of user message
    # This prevents informational messages from triggering Claude thinking
    STARTUP_INFO_FILE="/opt/claude-yolo/ccy-startup-info.txt"
    if [ ! -f "$STARTUP_INFO_FILE" ]; then
        print_error "Startup info file not found: $STARTUP_INFO_FILE"
        exit 1
    fi
    # Read startup info and pass to Claude via --append-system-prompt
    # Replace placeholder with actual container engine (title case)
    CONTAINER_ENGINE_TITLE=$(echo "$CONTAINER_ENGINE" | sed 's/./\U&/')
    STARTUP_INFO=$(cat "$STARTUP_INFO_FILE" | sed "s/__CONTAINER_ENGINE__/${CONTAINER_ENGINE_TITLE}/")

    # Show tip about custom Dockerfile if not using one (custom Dockerfile info shown earlier in header)
    if [ ! -f ".claude/ccy/Dockerfile" ]; then
        # No custom Dockerfile - show helpful tip
        echo "
ğŸ’¡ TIP: This project doesn't have a custom Dockerfile yet!

You can create one to add project-specific tools (Python, Go, Rust, databases, cloud CLIs, etc.):
  â€¢ Quick setup: Exit and run 'ccy --custom' (template-based, fast)
  â€¢ AI-guided: Exit and run 'ccy --custom-docker' (investigates project, asks questions, proposes features)

Custom Dockerfiles get cached per-project and rebuild automatically when changed.
More info: https://github.com/LongTermSupport/fedora-desktop/blob/main/docs/containerization.md#custom-dockerfiles"
    fi
    echo ""

    # Also add Dockerfile info to system prompt for Claude
    if [ -f ".claude/ccy/Dockerfile" ]; then
        STARTUP_INFO+="

âœ… Custom Dockerfile detected: .claude/ccy/Dockerfile

This project uses a custom container image with project-specific tools.
The container will automatically rebuild if the Dockerfile changes.

To modify: 'ccy --custom-docker' (AI-guided) or 'ccy --custom' (quick edit)"
    else
        STARTUP_INFO+="

ğŸ’¡ TIP: This project doesn't have a custom Dockerfile yet!

You can create one to add project-specific tools (Python, Go, Rust, databases, cloud CLIs, etc.):
  â€¢ Quick setup: Exit and run 'ccy --custom' (template-based, fast)
  â€¢ AI-guided: Exit and run 'ccy --custom-docker' (investigates project, asks questions, proposes features)

Custom Dockerfiles get cached per-project and rebuild automatically when changed.
More info: https://github.com/LongTermSupport/fedora-desktop/blob/main/docs/containerization.md#custom-dockerfiles"
    fi

    CLAUDE_CMD_ARGS+=("--append-system-prompt" "$STARTUP_INFO")
fi

# Add any other arguments passed through
CLAUDE_CMD_ARGS+=("${CLAUDE_ARGS[@]}")

# Use -it for interactive, -i only for headless (no TTY required)
if [ "$HEADLESS_MODE" = true ]; then
    DOCKER_FLAGS="-i"
else
    DOCKER_FLAGS="-it"
fi

# Show the exact command that will be executed (for debugging)
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo "Executing Claude Code with arguments:"
echo "  claude --dangerously-skip-permissions ${CLAUDE_CMD_ARGS[*]}"
echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
echo ""

container_cmd run $DOCKER_FLAGS --rm \
    --name "$CONTAINER_NAME" \
    $NETWORK_FLAG \
    "${DOCKER_MOUNTS[@]}" \
    "${SSH_MOUNTS[@]}" \
    -e "CLAUDE_CODE_OAUTH_TOKEN=$CLAUDE_OAUTH_TOKEN" \
    -e "GH_TOKEN=$GH_TOKEN" \
    -e "GITHUB_USERNAME=$GITHUB_USERNAME" \
    -e "DEBUG_MODE=$DEBUG_MODE" \
    -e "SSH_KEY_PATHS=$SSH_KEY_PATHS_STR" \
    -e "CCY_SESSION_NAME=$SESSION_NAME" \
    -e "TERM=${TERM:-xterm}" \
    -e "COLORTERM=${COLORTERM:-truecolor}" \
    -e "FORCE_COLOR=1" \
    -w /workspace \
    "$IMAGE_NAME" \
    claude --dangerously-skip-permissions "${CLAUDE_CMD_ARGS[@]}"

# Capture exit code
CONTAINER_EXIT_CODE=$?

# After container exits, handle session cleanup (only for named sessions)
if [[ "$SESSIONS_ENABLED" = true ]]; then
    # Confirm session name (allows renaming auto-generated names)
    confirm_session_name "$SESSION_NAME" "$SESSION_DIR" ".claude/ccy"
fi
# Default session is persistent - no cleanup needed

# Exit with same code as container
exit $CONTAINER_EXIT_CODE
