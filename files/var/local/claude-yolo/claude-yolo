#!/bin/bash
# Claude Code YOLO Mode Wrapper
# Runs Claude Code with --dangerously-skip-permissions in isolated Docker container
# IMPORTANT: Uses separate token storage from desktop Claude Code to prevent OAuth conflicts

set -e

# Fail fast: Must be run from a git repository root
if [ ! -d .git ]; then
    echo "ERROR: Not in a git repository root directory" >&2
    echo "" >&2
    echo "Claude YOLO (ccy) must be run from the root of a git repository." >&2
    echo "This ensures Claude Code operates on the correct codebase." >&2
    echo "" >&2
    echo "Current directory: $PWD" >&2
    echo "" >&2
    echo "To fix:" >&2
    echo "  1. Navigate to your git repository root: cd /path/to/your/repo" >&2
    echo "  2. Verify .git exists: ls -la .git" >&2
    echo "  3. Run ccy from there: ccy" >&2
    exit 1
fi

IMAGE_NAME="claude-yolo:latest"
DOCKERFILE_DIR="/opt/claude-yolo"
VERSION_CACHE="$HOME/.cache/claude-yolo-version"
CACHE_DURATION=3600  # 1 hour in seconds
CCY_ROOT="$HOME/.claude-tokens/ccy"
TOKEN_DIR="$CCY_ROOT/tokens"
PROJECT_DIR="$CCY_ROOT/projects"

# Show help if requested
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    cat << 'EOF'
Claude Code YOLO Mode (ccy) - Container-based execution with --dangerously-skip-permissions

Usage: ccy [OPTIONS] [CLAUDE_ARGS...]

Wrapper Options:
  --rebuild         Force rebuild of container image (clears cache)
  --debug           Enable debug output (bash -x)
  --ssh-key PATH    SSH private key to mount (can be specified multiple times)
  --token NAME      Use specific named token
  --create-token    Create a new named token
  --refresh-token   Refresh an expired OAuth token (mounts token writable)
  --list-tokens     List available tokens
  --help, -h        Show this help message

All other arguments are passed directly to Claude Code with --dangerously-skip-permissions

Features:
  • Runs in isolated Docker container with git/gh
  • Separate token storage (no conflicts with desktop Claude Code)
  • Named tokens for multiple Claude accounts (personal/work)
  • Auto-updates Claude Code (cached for 1 hour)
  • Mounts current directory as /workspace
  • Files created have correct host user ownership

Security:
  ⚠  YOLO mode bypasses all permission checks
  ✓  Container isolation prevents unintended host access
  ✓  Cannot run as root user (safety check)
  ✓  Tokens isolated from desktop Claude Code

Examples:
  ccy                           # Start (prompts for token selection)
  ccy --create-token            # Create a new named token
  ccy --token personal          # Use "personal" token
  ccy --list-tokens             # List available tokens
  ccy --rebuild                 # Rebuild container and start
  ccy "implement feature X"     # Start with specific task

Token Management:
  Tokens are stored in: ~/.claude-tokens/ccy/
  Each token is a separate Claude account (prevents OAuth conflicts)
  Desktop Claude Code (~/.claude/) is NEVER modified

EOF

    # Check if container image exists to show Claude Code help
    if docker image inspect "$IMAGE_NAME" &> /dev/null 2>&1; then
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "Claude Code Help (from container):"
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo ""
        # Run claude --help in container to show actual Claude Code options
        docker run --rm --entrypoint claude "$IMAGE_NAME" --help 2>/dev/null || echo "Note: Container exists but Claude Code help unavailable"
    else
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "Claude Code Help:"
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo ""
        echo "Container image not built yet. Run 'ccy --rebuild' first to build the container,"
        echo "then run 'ccy --help' again to see Claude Code options."
    fi

    exit 0
fi

# Function to list available tokens
list_tokens() {
    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "Available Claude Code Tokens for YOLO Mode"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""

    if [ ! -d "$TOKEN_DIR" ] || [ -z "$(ls -A "$TOKEN_DIR"/*.token.json 2>/dev/null)" ]; then
        echo "No tokens found in: $TOKEN_DIR"
        echo ""
        echo "Create a token with: ccy --create-token"
        echo ""
        return 1
    fi

    echo "Token storage: $TOKEN_DIR"
    echo ""

    for token_file in "$TOKEN_DIR"/*.token.json; do
        if [ -f "$token_file" ]; then
            token_name=$(basename "$token_file" .token.json)
            file_size=$(stat -c%s "$token_file")
            mod_time=$(stat -c%y "$token_file" | cut -d' ' -f1,2 | cut -d: -f1,2)

            echo "  • $token_name"
            echo "    File: $token_file"
            echo "    Modified: $mod_time"
            echo "    Size: $file_size bytes"

            # Try to extract account info if available
            if command -v jq &> /dev/null; then
                expires=$(jq -r '.claudeAiOauth.expiresAt // empty' "$token_file" 2>/dev/null)
                if [ -n "$expires" ]; then
                    expires_date=$(date -d "@$((expires/1000))" "+%Y-%m-%d %H:%M" 2>/dev/null || echo "Unknown")
                    echo "    Expires: $expires_date"
                fi
            fi
            echo ""
        fi
    done

    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
}

# Function to create a new token
create_token() {
    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "Create New Claude Code Token for YOLO Mode"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
    echo "This will create a new OAuth token for ccy (Claude Code YOLO)."
    echo "This token is SEPARATE from your desktop Claude Code installation."
    echo ""
    echo "Use cases:"
    echo "  • Personal account for open source work"
    echo "  • Work account for company projects"
    echo "  • Separate account to isolate ccy from desktop"
    echo ""

    # Prompt for token name
    while true; do
        read -p "Enter a name for this token (e.g., 'personal', 'work', 'default'): " token_name

        if [ -z "$token_name" ]; then
            echo "ERROR: Token name cannot be empty"
            continue
        fi

        # Validate token name (alphanumeric, dash, underscore only)
        if ! [[ "$token_name" =~ ^[a-zA-Z0-9_-]+$ ]]; then
            echo "ERROR: Token name must contain only letters, numbers, dashes, and underscores"
            continue
        fi

        token_file="$TOKEN_DIR/${token_name}.token.json"

        if [ -f "$token_file" ]; then
            read -p "Token '$token_name' already exists. Overwrite? (y/N): " overwrite
            if [ "$overwrite" != "y" ] && [ "$overwrite" != "Y" ]; then
                echo "Cancelled. Token not created."
                exit 0
            fi
        fi

        break
    done

    echo ""
    echo "Creating token: $token_name"
    echo "Storage: $token_file"
    echo ""

    # Create temporary directory for token creation - mount entire /root
    tmp_token_dir="$TOKEN_DIR/.tmp-${token_name}-$$"
    mkdir -p "$tmp_token_dir/root"
    chmod 700 "$tmp_token_dir"
    chmod 700 "$tmp_token_dir/root"

    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
    echo "Launching Claude Code container for OAuth login..."
    echo ""
    echo "INSTRUCTIONS:"
    echo "  1. When Claude Code starts, use the /login command"
    echo "  2. Follow the OAuth flow to authenticate"
    echo "  3. After successful login, type /exit or press Ctrl+D"
    echo "  4. Your token will be saved automatically"
    echo ""
    echo "Press Enter to continue..."
    read

    # Run container with entire /root directory mounted
    # This captures ALL files Claude Code creates, not just .claude/
    # Use the GH_TOKEN that was already selected via SSH key selection
    # Override entrypoint to skip credential copying (we're creating them!)
    # DO NOT mount workspace - token creation doesn't need git repo access
    if docker run -it --rm \
        -v "$tmp_token_dir/root:/root" \
        -e "GH_TOKEN=$GH_TOKEN" \
        --entrypoint claude \
        "$IMAGE_NAME" 2>&1; then

        # After container exits, everything from /root is in tmp_token_dir/root
        echo ""
        echo "Debug: Checking what files were created in container's /root..."
        echo "Directory: $tmp_token_dir/root"
        echo ""
        echo "All files:"
        find "$tmp_token_dir/root" -type f 2>/dev/null | head -20
        echo ""
        echo ".claude directory contents:"
        ls -la "$tmp_token_dir/root/.claude/" 2>/dev/null || echo "(no .claude directory)"
        echo ""

        # Check if credentials were created
        if [ -f "$tmp_token_dir/root/.claude/.credentials.json" ]; then
            # Move credentials to final location
            mv "$tmp_token_dir/root/.claude/.credentials.json" "$token_file"
            chmod 600 "$token_file"
            echo "✓ Captured .credentials.json"

            # Save ALL Claude Code settings/state created during setup
            # This includes UI preferences, settings, etc.
            settings_file="$TOKEN_DIR/${token_name}.settings.json"
            if [ -f "$tmp_token_dir/root/.claude/settings.json" ]; then
                mv "$tmp_token_dir/root/.claude/settings.json" "$settings_file"
                chmod 600 "$settings_file"
                echo "✓ Captured settings.json"
            else
                echo "⚠ settings.json NOT created during setup"
                # Copy from desktop Claude as fallback template if it exists
                if [ -f "$HOME/.claude/settings.json" ]; then
                    cp "$HOME/.claude/settings.json" "$settings_file"
                    chmod 600 "$settings_file"
                    echo "✓ Copied settings.json template from desktop Claude"
                else
                    echo "⚠ No desktop Claude settings.json found - will show setup screen on first run"
                fi
            fi

            # Save .claude.json if it exists (config file)
            config_file="$TOKEN_DIR/${token_name}.config.json"
            if [ -f "$tmp_token_dir/root/.claude.json" ]; then
                mv "$tmp_token_dir/root/.claude.json" "$config_file"
                chmod 600 "$config_file"
                echo "✓ Captured .claude.json"
            else
                echo "⚠ .claude.json NOT created during setup"
                # Copy from desktop Claude as fallback if it exists
                if [ -f "$HOME/.claude.json" ]; then
                    cp "$HOME/.claude.json" "$config_file"
                    chmod 600 "$config_file"
                    echo "✓ Copied .claude.json template from desktop Claude"
                else
                    echo "⚠ No desktop Claude .claude.json found"
                fi
            fi

            echo ""
            echo "════════════════════════════════════════════════════════════════════════════"
            echo "✓ Token created successfully: $token_name"
            echo "════════════════════════════════════════════════════════════════════════════"
            echo ""
            echo "Saved files:"
            echo "  Credentials: $token_file"
            if [ -f "$settings_file" ]; then
                echo "  Settings: $settings_file"
            fi
            if [ -f "$config_file" ]; then
                echo "  Config: $config_file"
            fi
            echo ""
            echo "You can now use this token with:"
            echo "  ccy --token $token_name"
            echo ""
            echo "Or just run 'ccy' and select it from the menu."
            echo ""
        else
            echo ""
            echo "════════════════════════════════════════════════════════════════════════════"
            echo "⚠  WARNING: No credentials found"
            echo "════════════════════════════════════════════════════════════════════════════"
            echo ""
            echo "The login process did not create credentials."
            echo "This usually means:"
            echo "  • You didn't complete the /login command"
            echo "  • You exited before authentication completed"
            echo "  • There was an error during the OAuth flow"
            echo ""
            echo "Try again with: ccy --create-token"
            echo ""
        fi
    else
        echo ""
        echo "ERROR: Container execution failed"
        echo "Token creation cancelled."
        echo ""
    fi

    # Cleanup temporary directory
    rm -rf "$tmp_token_dir"

    exit 0
}

# Function to get project-specific state directory
# Returns path to project's .claude directory based on git repo identifier
# Note: Only called after git repo check passes (line 8-22)
get_project_state_dir() {
    local repo_path="$PWD"

    # Get git remote URL - fail fast if not configured
    local git_remote=$(git remote get-url origin 2>/dev/null)
    if [ -z "$git_remote" ]; then
        echo "ERROR: No git remote 'origin' configured" >&2
        echo "" >&2
        echo "Claude YOLO requires a git remote to identify the project." >&2
        echo "This ensures conversations are properly tied to the correct repository." >&2
        echo "" >&2
        echo "To fix:" >&2
        echo "  git remote add origin <url>" >&2
        echo "" >&2
        echo "Current directory: $repo_path" >&2
        exit 1
    fi

    # Extract repo name from git remote URL
    # Examples:
    #   git@github.com:user/repo.git -> user_repo
    #   https://github.com/user/repo.git -> user_repo
    local project_name=$(echo "$git_remote" | sed -E 's|.*[:/]([^/]+)/([^/]+)(\.git)?$|\1_\2|')

    local project_root="$PROJECT_DIR/$project_name"
    local project_claude_dir="$project_root/.claude"

    # Create project structure if it doesn't exist
    if [ ! -d "$project_root" ]; then
        mkdir -p "$project_root"
        chmod 700 "$project_root"

        # Create metadata file for reference
        cat > "$project_root/.project-info" <<EOF
# Claude Code YOLO Project State
Repository Path: $repo_path
Git Remote: $git_remote
Project Name: $project_name
Created: $(date -Iseconds)
EOF
        chmod 600 "$project_root/.project-info"
    fi

    # Create .claude directory if it doesn't exist
    if [ ! -d "$project_claude_dir" ]; then
        mkdir -p "$project_claude_dir"
        chmod 700 "$project_claude_dir"
    fi

    echo "$project_claude_dir"
}

# Function to select a token interactively
select_token() {
    if [ ! -d "$TOKEN_DIR" ]; then
        return 1
    fi

    # Get list of token files (only .token.json files)
    mapfile -t token_files < <(find "$TOKEN_DIR" -maxdepth 1 -name "*.token.json" -type f 2>/dev/null | sort)

    if [ ${#token_files[@]} -eq 0 ]; then
        return 1
    fi

    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "Claude Code Token Selection for YOLO Mode"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
    echo "Available tokens:"
    echo ""
    echo "  0) Create new token"
    echo ""

    for i in "${!token_files[@]}"; do
        token_name=$(basename "${token_files[$i]}" .token.json)
        echo "  $((i+1))) $token_name"
    done

    echo ""
    read -p "Select token [0-${#token_files[@]}]: " selection
    echo ""

    if [ -z "$selection" ]; then
        echo "No selection made. Exiting."
        exit 1
    fi

    if [ "$selection" = "0" ]; then
        create_token
        exit 0
    elif [ "$selection" -ge 1 ] && [ "$selection" -le ${#token_files[@]} ]; then
        SELECTED_TOKEN="${token_files[$((selection-1))]}"
        token_name=$(basename "$SELECTED_TOKEN" .token.json)
        echo "✓ Selected token: $token_name"
        echo ""
        echo "════════════════════════════════════════════════════════════════════════════"
        echo ""
        return 0
    else
        echo "ERROR: Invalid selection: $selection"
        exit 1
    fi
}

# Check for wrapper flags
FORCE_REBUILD=false
DEBUG_MODE=false
SSH_KEYS=()
CLAUDE_ARGS=()
NEXT_IS_SSH_KEY=false
NEXT_IS_TOKEN=false
SPECIFIED_TOKEN=""
CREATE_TOKEN_MODE=false
REFRESH_TOKEN_MODE=false
LIST_TOKENS_MODE=false

for arg in "$@"; do
    if [ "$NEXT_IS_SSH_KEY" = true ]; then
        if [ ! -f "$arg" ]; then
            echo "ERROR: SSH key not found: $arg"
            exit 1
        fi
        SSH_KEYS+=("$arg")
        NEXT_IS_SSH_KEY=false
    elif [ "$NEXT_IS_TOKEN" = true ]; then
        SPECIFIED_TOKEN="$arg"
        NEXT_IS_TOKEN=false
    elif [ "$arg" = "--rebuild" ]; then
        FORCE_REBUILD=true
    elif [ "$arg" = "--debug" ]; then
        DEBUG_MODE=true
        DEBUG_LOG="/tmp/ccy-debug-$(date +%Y%m%d-%H%M%S).log"
        # Redirect all output to both terminal and log file
        exec > >(tee -a "$DEBUG_LOG") 2>&1
        set -x
        echo "Debug logging to: $DEBUG_LOG"
    elif [ "$arg" = "--ssh-key" ]; then
        NEXT_IS_SSH_KEY=true
    elif [ "$arg" = "--token" ]; then
        NEXT_IS_TOKEN=true
    elif [ "$arg" = "--create-token" ]; then
        CREATE_TOKEN_MODE=true
    elif [ "$arg" = "--refresh-token" ]; then
        REFRESH_TOKEN_MODE=true
    elif [ "$arg" = "--list-tokens" ]; then
        LIST_TOKENS_MODE=true
    else
        CLAUDE_ARGS+=("$arg")
    fi
done

# Ensure directory structure exists early
mkdir -p "$CCY_ROOT"
chmod 700 "$CCY_ROOT"
mkdir -p "$TOKEN_DIR"
chmod 700 "$TOKEN_DIR"
mkdir -p "$PROJECT_DIR"
chmod 700 "$PROJECT_DIR"

# Handle list tokens mode (doesn't need SSH/GH setup)
if [ "$LIST_TOKENS_MODE" = true ]; then
    list_tokens
    exit 0
fi

# Discover github_ SSH keys if no --ssh-key was passed
# These keys are managed by play-github-cli-multi.yml which creates keys with
# the pattern ~/.ssh/github_<alias> for each configured GitHub account.
# See: playbooks/imports/optional/common/play-github-cli-multi.yml:163-183
if [ ${#SSH_KEYS[@]} -eq 0 ]; then
    GITHUB_KEYS=($(find "$HOME/.ssh" -type f -name "github_*" ! -name "*.pub" 2>/dev/null | sort))

    if [ ${#GITHUB_KEYS[@]} -gt 0 ]; then
        echo ""
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "SSH Key Selection for Claude YOLO"
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo ""
        echo "No SSH key was specified with --ssh-key flag."
        echo ""
        echo "Available GitHub SSH keys (managed by play-github-cli-multi.yml):"
        echo ""
        echo "  0) Continue without SSH key (git push will NOT work)"
        echo ""

        for i in "${!GITHUB_KEYS[@]}"; do
            key_name=$(basename "${GITHUB_KEYS[$i]}")
            echo "  $((i+1))) ${GITHUB_KEYS[$i]}"
        done

        echo ""
        echo "You can also specify keys manually with: ccy --ssh-key <path>"
        echo ""
        read -p "Select SSH key [0-${#GITHUB_KEYS[@]}]: " selection
        echo ""

        if [ -z "$selection" ]; then
            echo "No selection made. Exiting."
            exit 1
        fi

        if [ "$selection" = "0" ]; then
            echo "⚠  Continuing WITHOUT SSH key - git push operations will fail"
            echo ""
        elif [ "$selection" -ge 1 ] && [ "$selection" -le ${#GITHUB_KEYS[@]} ]; then
            SSH_KEYS+=("${GITHUB_KEYS[$((selection-1))]}")
            echo "✓ Selected: ${GITHUB_KEYS[$((selection-1))]}"
            echo ""
        else
            echo "ERROR: Invalid selection: $selection"
            exit 1
        fi

        echo "════════════════════════════════════════════════════════════════════════════════"
        echo ""
    else
        echo ""
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "⚠  WARNING: No SSH Keys Available"
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo ""
        echo "No github_ SSH keys found in ~/.ssh/"
        echo "Git push operations will NOT work without SSH keys."
        echo ""
        echo "To set up GitHub SSH keys, run:"
        echo "  ansible-playbook playbooks/imports/optional/common/play-github-cli-multi.yml"
        echo ""
        echo "Or specify a key manually:"
        echo "  ccy --ssh-key ~/.ssh/id_ed25519"
        echo ""
        read -p "Press Enter to continue WITHOUT SSH key, or Ctrl+C to cancel: "
        echo ""
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo ""
    fi
fi

# Build SSH key mount arguments and extract GitHub account
# This needs to happen early so GH_TOKEN is available for create_token
SSH_MOUNTS=()
SSH_KEY_PATHS=()
GITHUB_USERNAME=""

for i in "${!SSH_KEYS[@]}"; do
    SSH_MOUNTS+=("-v" "${SSH_KEYS[$i]}:/root/.ssh/key_$i:ro")
    SSH_KEY_PATHS+=("/root/.ssh/key_$i")

    # Extract GitHub username by testing SSH connection with the key
    # This works for any SSH key (github_ or otherwise)
    # ssh -T will respond with: "Hi <username>! You've successfully authenticated..."
    GITHUB_USERNAME=$(ssh -T -i "${SSH_KEYS[$i]}" -o IdentitiesOnly=yes -o StrictHostKeyChecking=no git@github.com 2>&1 | grep -oP "Hi \K[^!]+")

    if [ -z "$GITHUB_USERNAME" ]; then
        echo "ERROR: SSH key authentication to GitHub failed: ${SSH_KEYS[$i]}"
        echo ""
        echo "The selected SSH key is not registered with any GitHub account."
        echo ""
        echo "To fix this:"
        echo "  1. Go to https://github.com/settings/keys"
        echo "  2. Click 'New SSH key'"
        echo "  3. Add the public key from: ${SSH_KEYS[$i]}.pub"
        echo ""
        echo "Or set up GitHub keys with:"
        echo "  ansible-playbook playbooks/imports/optional/common/play-github-cli-multi.yml"
        exit 1
    fi

    echo "✓ Detected GitHub account for SSH key: $GITHUB_USERNAME"
done

# Get GitHub token from gh CLI
if ! command -v gh &> /dev/null; then
    echo "ERROR: gh (GitHub CLI) not found"
    echo "Install it with: ansible-playbook playbooks/imports/play-git-configure-and-tools.yml"
    exit 1
fi

# If we detected a GitHub username from SSH key, get the account-specific token
# This requires play-github-cli-multi.yml to be configured and shell reloaded
if [ -n "$GITHUB_USERNAME" ] && [ ${#SSH_KEYS[@]} -gt 0 ]; then
    # Extract alias from the first SSH key
    key_basename=$(basename "${SSH_KEYS[0]}")
    if [[ "$key_basename" =~ ^github_(.+)$ ]]; then
        alias="${BASH_REMATCH[1]}"
        token_func="gh-token-${alias}"

        # Load gh aliases if not already loaded (script runs in subshell)
        if ! type "$token_func" &>/dev/null; then
            if [ -f "$HOME/.bashrc-includes/gh-aliases.inc.bash" ]; then
                source "$HOME/.bashrc-includes/gh-aliases.inc.bash"
            fi
        fi

        # Check if the gh-token-<alias> function exists (from play-github-cli-multi.yml)
        if ! type "$token_func" &>/dev/null; then
            echo "ERROR: GitHub multi-account function not found: $token_func"
            echo ""
            echo "Selected SSH key: ${SSH_KEYS[0]}"
            echo "Expected file: ~/.bashrc-includes/gh-aliases.inc.bash"
            echo "Expected function: $token_func"
            echo ""
            echo "Required: gh-token-<alias> functions from play-github-cli-multi.yml"
            echo ""
            echo "To fix:"
            echo "  1. Run: ansible-playbook playbooks/imports/optional/common/play-github-cli-multi.yml"
            echo "  2. Verify: ls -la ~/.bashrc-includes/gh-aliases.inc.bash"
            echo "  3. Verify: grep $token_func ~/.bashrc-includes/gh-aliases.inc.bash"
            exit 1
        fi

        # Get the token for the specific account
        GH_TOKEN=$($token_func 2>/dev/null)
        if [ -z "$GH_TOKEN" ]; then
            echo "ERROR: Failed to retrieve token for account: $GITHUB_USERNAME"
            echo ""
            echo "Function $token_func returned no token."
            echo "Account is not authenticated with gh CLI."
            echo ""
            echo "Fix: ansible-playbook playbooks/imports/optional/common/play-github-cli-multi.yml"
            exit 1
        fi

        echo "✓ Retrieved token for GitHub account: $GITHUB_USERNAME (via $token_func)"
    fi
else
    # No GitHub username detected - fall back to default token
    GH_TOKEN=$(gh auth token 2>/dev/null)

    if [ -z "$GH_TOKEN" ]; then
        echo "ERROR: Not authenticated with GitHub CLI"
        echo ""
        echo "Run: gh auth login"
        echo ""
        echo "For multi-account setup with github_ SSH keys, run:"
        echo "  ansible-playbook playbooks/imports/optional/common/play-github-cli-multi.yml"
        exit 1
    fi
fi

# Token selection logic
SELECTED_TOKEN=""

if [ -n "$SPECIFIED_TOKEN" ]; then
    # Token specified via --token flag
    if [[ "$SPECIFIED_TOKEN" =~ / ]]; then
        # Full path provided
        SELECTED_TOKEN="$SPECIFIED_TOKEN"
    else
        # Token name provided, construct path
        SELECTED_TOKEN="$TOKEN_DIR/${SPECIFIED_TOKEN}.token.json"
    fi

    if [ ! -f "$SELECTED_TOKEN" ]; then
        echo "ERROR: Token not found: $SELECTED_TOKEN"
        echo ""
        echo "Available tokens:"
        list_tokens
        exit 1
    fi

    echo "✓ Using token: $(basename "$SELECTED_TOKEN" .token.json)"
else
    # No token specified, check if tokens exist
    if [ ! -d "$TOKEN_DIR" ] || [ -z "$(ls -A "$TOKEN_DIR"/*.token.json 2>/dev/null)" ]; then
        echo ""
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "No Claude Code Tokens Found"
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo ""
        echo "ccy uses separate tokens from desktop Claude Code to prevent OAuth conflicts."
        echo ""
        echo "You need to create a token before using ccy."
        echo ""
        read -p "Create a token now? (Y/n): " create_now

        if [ "$create_now" = "n" ] || [ "$create_now" = "N" ]; then
            echo "Cancelled. Create a token later with: ccy --create-token"
            exit 0
        fi

        # Set flag to create token after GH_TOKEN is set up
        CREATE_TOKEN_MODE=true
    else
        # Multiple tokens exist or single token - show selection
        select_token || {
            echo "ERROR: No tokens available"
            echo "Create a token with: ccy --create-token"
            exit 1
        }
    fi
fi

# Handle create token mode (after SSH/GH setup is complete, before token operations)
if [ "$CREATE_TOKEN_MODE" = true ]; then
    create_token
    exit 0
fi

# Handle refresh token mode (after SSH/GH setup and token selection)
if [ "$REFRESH_TOKEN_MODE" = true ]; then
    # Token already selected, just set flag to mount writable
    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "Token Refresh Mode"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
    echo "Token will be mounted WRITABLE to allow Claude Code to refresh OAuth credentials."
    echo ""
    echo "IMPORTANT: Only run this in ONE project at a time to avoid race conditions!"
    echo ""
    echo "After Claude Code refreshes the token, all other projects will use the new token."
    echo ""
    TOKEN_MOUNT_MODE="rw"
else
    # Normal mode - read-only token
    TOKEN_MOUNT_MODE="ro"
fi

# Get current user's UID and GID for proper file ownership
HOST_UID=$(id -u)
HOST_GID=$(id -g)

# Safety check: Never run as root (UID 0)
if [ "$HOST_UID" -eq 0 ]; then
    echo "ERROR: Cannot run Claude Code YOLO mode as root user (UID 0)"
    echo "This is a security restriction for --dangerously-skip-permissions mode"
    echo "Please run this command as a regular user, not with sudo or as root"
    exit 1
fi

# Safety check: Only run in rootless Docker
DOCKER_CONTEXT=$(docker context inspect 2>/dev/null | grep -o '"Name": *"[^"]*"' | head -1 | cut -d'"' -f4)
if [ "$DOCKER_CONTEXT" != "rootless" ]; then
    echo "ERROR: Claude Code YOLO mode requires rootless Docker"
    echo "Current Docker context: ${DOCKER_CONTEXT:-default}"
    echo ""
    echo "This is a security requirement because:"
    echo "  • YOLO mode bypasses all permission checks"
    echo "  • Running in rootless Docker provides isolation"
    echo "  • Non-rootless Docker would give actual root privileges"
    echo ""
    echo "To set up rootless Docker:"
    echo "  1. Install: dockerd-rootless-setuptool.sh install"
    echo "  2. Switch context: docker context use rootless"
    echo ""
    echo "Or run the Docker playbook:"
    echo "  ansible-playbook playbooks/imports/optional/common/play-docker.yml"
    exit 1
fi

# Ensure cache directory exists
mkdir -p "$(dirname "$VERSION_CACHE")"

# Force rebuild if --rebuild flag was provided
if [ "$FORCE_REBUILD" = true ]; then
    echo "Forcing container rebuild..."
    if [ ! -f "$DOCKERFILE_DIR/Dockerfile" ]; then
        echo "Error: Dockerfile not found at $DOCKERFILE_DIR/Dockerfile"
        echo "Please run the ansible playbook: playbooks/imports/optional/common/play-install-claude-yolo.yml"
        exit 1
    fi
    docker build --no-cache -t "$IMAGE_NAME" "$DOCKERFILE_DIR"
    # Clear version cache to force Claude Code update check
    rm -f "$VERSION_CACHE"
    echo "✓ Container image rebuilt successfully"
fi

# Check if Docker image exists
if ! docker image inspect "$IMAGE_NAME" &> /dev/null; then
    echo "Building Claude YOLO container image (first time setup)..."
    if [ ! -f "$DOCKERFILE_DIR/Dockerfile" ]; then
        echo "Error: Dockerfile not found at $DOCKERFILE_DIR/Dockerfile"
        echo "Please run the ansible playbook: playbooks/imports/optional/common/play-install-claude-yolo.yml"
        exit 1
    fi
    docker build -t "$IMAGE_NAME" "$DOCKERFILE_DIR"
    echo "✓ Container image built successfully"
fi

# Check if Claude Code needs updating (with caching to keep it fast)
should_update_claude=false
if [ -f "$VERSION_CACHE" ]; then
    # Check cache age
    cache_age=$(($(date +%s) - $(stat -c %Y "$VERSION_CACHE" 2>/dev/null || echo 0)))
    if [ $cache_age -gt $CACHE_DURATION ]; then
        should_update_claude=true
    fi
else
    should_update_claude=true
fi

# Update Claude Code in container if needed
if [ "$should_update_claude" = true ]; then
    echo "Checking for Claude Code updates..."
    docker run --rm --entrypoint sh "$IMAGE_NAME" -c "npm update -g @anthropic-ai/claude-code 2>&1" | grep -v "npm WARN" || true
    # Update cache timestamp
    touch "$VERSION_CACHE"
fi

# Get project-specific state directory (entire .claude directory)
PROJECT_CLAUDE_DIR=$(get_project_state_dir)
echo "✓ Project state: $PROJECT_CLAUDE_DIR"
echo "✓ Token mount mode: $TOKEN_MOUNT_MODE"

if [ "$DEBUG_MODE" = true ]; then
    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "DEBUG: Pre-mount setup"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "Selected token file: $SELECTED_TOKEN"
    echo "Token exists: $([ -f "$SELECTED_TOKEN" ] && echo "YES" || echo "NO")"
    echo "Token size: $(stat -c%s "$SELECTED_TOKEN" 2>/dev/null || echo "N/A") bytes"
    echo ""
    echo "Project .claude directory: $PROJECT_CLAUDE_DIR"
    echo "Directory exists: $([ -d "$PROJECT_CLAUDE_DIR" ] && echo "YES" || echo "NO")"
    echo ""
    echo "Files in project .claude directory:"
    ls -lah "$PROJECT_CLAUDE_DIR" 2>/dev/null || echo "  (empty or doesn't exist)"
    echo ""
fi

# Copy token settings template if project settings don't exist yet
# This ensures first run in a new project inherits UI preferences from token
token_name=$(basename "$SELECTED_TOKEN" .token.json)
token_settings="$TOKEN_DIR/${token_name}.settings.json"
project_settings="$PROJECT_CLAUDE_DIR/settings.json"

if [ "$DEBUG_MODE" = true ]; then
    echo "Token settings template: $token_settings"
    echo "Template exists: $([ -f "$token_settings" ] && echo "YES" || echo "NO")"
    echo "Project settings: $project_settings"
    echo "Project settings exists: $([ -f "$project_settings" ] && echo "YES" || echo "NO")"
    echo ""
fi

if [ ! -f "$project_settings" ] && [ -f "$token_settings" ]; then
    # First time in this project - copy settings template from token
    cp "$token_settings" "$project_settings"
    chmod 600 "$project_settings"
    [ "$DEBUG_MODE" = true ] && echo "✓ Copied settings template to project"
elif [ ! -f "$project_settings" ]; then
    [ "$DEBUG_MODE" = true ] && echo "⚠ No settings template available, Claude will show setup screen"
fi

# Copy .claude.json config to project if it doesn't exist
# This needs to be writable (Claude Code updates numStartups, etc.)
token_config="$TOKEN_DIR/${token_name}.config.json"
project_config="$PROJECT_CLAUDE_DIR/../.claude.json"  # In project root, not inside .claude/

if [ ! -f "$project_config" ] && [ -f "$token_config" ]; then
    cp "$token_config" "$project_config"
    chmod 600 "$project_config"
    [ "$DEBUG_MODE" = true ] && echo "✓ Copied .claude.json config to project"
elif [ ! -f "$project_config" ]; then
    [ "$DEBUG_MODE" = true ] && echo "⚠ No .claude.json config available"
fi

# CRITICAL: Remove .credentials.json from project directory if it exists
# Credentials should ONLY come from the file mount, never stored in project dir
if [ -f "$PROJECT_CLAUDE_DIR/.credentials.json" ]; then
    if [ "$DEBUG_MODE" = true ]; then
        echo "⚠ Found .credentials.json in project directory (should not exist)"
        echo "  Size: $(stat -c%s "$PROJECT_CLAUDE_DIR/.credentials.json") bytes"
        echo "  Removing to prevent mount conflicts..."
    fi
    rm -f "$PROJECT_CLAUDE_DIR/.credentials.json"
    [ "$DEBUG_MODE" = true ] && echo "✓ Removed .credentials.json from project directory"
fi

if [ "$DEBUG_MODE" = true ]; then
    echo ""
    echo "Files in project .claude directory (after setup):"
    ls -lah "$PROJECT_CLAUDE_DIR" 2>/dev/null || echo "  (empty)"
    if [ -f "$project_config" ]; then
        echo ""
        echo "Project .claude.json config:"
        ls -lh "$project_config"
    fi
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
fi

# Note:
# - Token (.credentials.json) mounted read-only from central storage (or writable with --refresh-token)
# - Config (.claude.json) copied to project directory and mounted writable (Claude updates numStartups, etc.)
# - All other files (history.jsonl, todos/, settings.json, etc.) persist in project directory

# Create temp directory ONLY for gitconfig (can't mount directly into container root)
CONFIG_TEMP="/tmp/claude-yolo-$$"
mkdir -p "$CONFIG_TEMP"
chmod 755 "$CONFIG_TEMP"

# Copy git config to temp location for entrypoint
if [ -f "$HOME/.gitconfig" ]; then
    cp "$HOME/.gitconfig" "$CONFIG_TEMP/gitconfig"
    chmod 644 "$CONFIG_TEMP/gitconfig"
else
    touch "$CONFIG_TEMP/gitconfig"
    chmod 644 "$CONFIG_TEMP/gitconfig"
fi

# Cleanup function
cleanup() {
    rm -rf "$CONFIG_TEMP"

    # Show debug log if in debug mode
    if [ "$DEBUG_MODE" = true ] && [ -n "$DEBUG_LOG" ]; then
        echo ""
        echo "════════════════════════════════════════════════════════════════════════════════"
        echo "DEBUG LOG (saved to $DEBUG_LOG)"
        echo "════════════════════════════════════════════════════════════════════════════════"
        cat "$DEBUG_LOG"
        echo "════════════════════════════════════════════════════════════════════════════════"
    fi
}
trap cleanup EXIT

# Convert SSH_KEY_PATHS array to colon-separated string
SSH_KEY_PATHS_STR=$(IFS=:; echo "${SSH_KEY_PATHS[*]}")

if [ "$DEBUG_MODE" = true ]; then
    echo ""
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "DEBUG: Docker run configuration"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo "Workspace: $PWD"
    echo "Project .claude dir: $PROJECT_CLAUDE_DIR"
    echo "Token file: $SELECTED_TOKEN (mode: $TOKEN_MOUNT_MODE)"
    echo "SSH keys mounted: ${#SSH_KEYS[@]}"
    echo ""
    echo "Docker command (simplified):"
    echo "  docker run -it --rm \\"
    echo "    -v $PWD:/workspace \\"
    echo "    -v $SELECTED_TOKEN:/root/.claude/.credentials.json:$TOKEN_MOUNT_MODE \\"
    if [ -f "$project_config" ]; then
        echo "    -v $project_config:/root/.claude.json \\"
    fi
    echo "    -v $PROJECT_CLAUDE_DIR:/root/.claude \\"
    echo "    ... (other mounts) ..."
    echo "    $IMAGE_NAME \\"
    echo "    claude --dangerously-skip-permissions ${CLAUDE_ARGS[@]}"
    echo "════════════════════════════════════════════════════════════════════════════════"
    echo ""
    echo "Debug log saved to: $DEBUG_LOG"
    echo ""
    echo "Container will start now. Once inside, you can check:"
    echo "  ls -la ~/.claude/"
    echo "  cat ~/.claude/settings.json"
    echo ""
    echo "After exiting, review the debug log with:"
    echo "  cat $DEBUG_LOG"
    echo ""
    read -p "Press Enter to continue..."
fi

# Run container with project-specific state directory
# All Claude Code state (history, todos, conversations) persists per-project
# Token and config are mounted separately
#
# MOUNT ORDER MATTERS:
# 1. Credentials file FIRST - creates the file at target path
# 2. Config file to home directory root (WRITABLE - Claude updates it)
# 3. Project directory LAST - overlays everything else but credentials already exists

# Build mount arguments
DOCKER_MOUNTS=(
    -v "$PWD:/workspace"
    -v "$SELECTED_TOKEN:/root/.claude/.credentials.json:$TOKEN_MOUNT_MODE"
)

# Mount config file if it exists (contains onboarding state, must be WRITABLE)
if [ -f "$project_config" ]; then
    DOCKER_MOUNTS+=(-v "$project_config:/root/.claude.json")
    [ "$DEBUG_MODE" = true ] && echo "✓ Mounting config file (writable): $project_config"
else
    [ "$DEBUG_MODE" = true ] && echo "⚠ Config file not found: $project_config (onboarding will be required)"
fi

DOCKER_MOUNTS+=(
    -v "$PROJECT_CLAUDE_DIR:/root/.claude"
    -v "$CONFIG_TEMP:/tmp/claude-config-import:ro"
)

docker run -it --rm \
    "${DOCKER_MOUNTS[@]}" \
    "${SSH_MOUNTS[@]}" \
    -e "GH_TOKEN=$GH_TOKEN" \
    -e "GITHUB_USERNAME=$GITHUB_USERNAME" \
    -e "DEBUG_MODE=$DEBUG_MODE" \
    -e "SSH_KEY_PATHS=$SSH_KEY_PATHS_STR" \
    -w /workspace \
    "$IMAGE_NAME" \
    claude --dangerously-skip-permissions "${CLAUDE_ARGS[@]}"
