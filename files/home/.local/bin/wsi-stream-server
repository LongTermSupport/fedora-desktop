#!/usr/bin/env python3
"""
WSI-Stream Server - Persistent Speech-to-Text Server
=====================================================
Keeps Whisper model hot in memory for instant recording startup.

Server listens on Unix socket for START/STOP commands from client.
Auto-shuts down after idle timeout (default: 20 minutes).

Memory cost: ~200MB (base) to ~600MB (small model)
Speed improvement: 3-6 seconds â†’ <0.3 seconds for subsequent recordings
"""

import os
import sys
import json
import socket
import threading
import time
import signal
import atexit
from pathlib import Path
from datetime import datetime

# Constants
SOCKET_PATH = Path(f"/run/user/{os.getuid()}/wsi-stream.socket")
LOG_DIR = Path.home() / ".local/share/speech-to-text"
LOG_FILE = LOG_DIR / "server.log"
PID_FILE = Path(f"/run/user/{os.getuid()}/wsi-stream-server.pid")

# Configuration
DEFAULT_IDLE_TIMEOUT = 1200  # 20 minutes
SOCKET_TIMEOUT = 0.5  # Check for shutdown every 0.5s

# Global state
recorder = None
debug_mode = False
shutdown_requested = False
last_activity_time = time.time()
idle_timeout = DEFAULT_IDLE_TIMEOUT
recording_active = False
current_client = None


def log(message, level="INFO"):
    """Log message to file and stderr if debug mode."""
    timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
    log_line = f"[{timestamp}] [SERVER] [{level}] {message}"

    if debug_mode:
        print(log_line, file=sys.stderr)

    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        with open(LOG_FILE, "a") as f:
            f.write(log_line + "\n")
    except Exception:
        pass


def update_activity():
    """Update last activity timestamp."""
    global last_activity_time
    last_activity_time = time.time()


def check_idle_timeout():
    """Check if server has been idle too long."""
    if recording_active:
        return False

    idle_time = time.time() - last_activity_time
    return idle_time >= idle_timeout


def initialize_recorder(model_size="base", language="en", device_type="auto"):
    """Initialize the AudioToTextRecorder - expensive operation done once."""
    global recorder

    try:
        from RealtimeSTT import AudioToTextRecorder

        log(f"Initializing recorder (model={model_size}, language={language}, device={device_type})")

        recorder_config = {
            "model": model_size,
            "language": language,
            "use_microphone": False,  # We'll feed audio manually
            "silero_sensitivity": 0.4,
            "enable_realtime_transcription": True,
            "realtime_processing_pause": 0.2,
            "spinner": False,
        }

        # Device selection
        if device_type == "auto":
            try:
                recorder_config["device"] = "cuda"
                recorder_config["compute_type"] = "float16"
                log("Using GPU (CUDA)")
            except Exception:
                recorder_config["device"] = "cpu"
                recorder_config["compute_type"] = "int8"
                log("Using CPU")
        elif device_type == "gpu":
            recorder_config["device"] = "cuda"
            recorder_config["compute_type"] = "float16"
        else:
            recorder_config["device"] = "cpu"
            recorder_config["compute_type"] = "int8"

        recorder = AudioToTextRecorder(**recorder_config)
        log("Recorder initialized successfully - ready for instant recording")
        return True

    except ImportError as e:
        log(f"RealtimeSTT not installed: {e}", "ERROR")
        return False
    except Exception as e:
        log(f"Recorder initialization failed: {e}", "ERROR")
        return False


def handle_start_command(client_socket, params):
    """Handle START recording command from client."""
    global recording_active, current_client

    update_activity()

    if recording_active:
        send_response(client_socket, {
            "status": "error",
            "message": "Recording already active"
        })
        return

    recording_active = True
    current_client = client_socket

    log("START command received - beginning recording")

    # TODO: Implement actual recording logic
    # For now, just acknowledge
    send_response(client_socket, {
        "status": "recording",
        "message": "Recording started"
    })


def handle_stop_command(client_socket, params):
    """Handle STOP recording command from client."""
    global recording_active, current_client

    update_activity()

    if not recording_active:
        send_response(client_socket, {
            "status": "error",
            "message": "No active recording"
        })
        return

    recording_active = False
    current_client = None

    log("STOP command received - stopping recording")

    # TODO: Implement actual stop logic
    # For now, just acknowledge
    send_response(client_socket, {
        "status": "stopped",
        "transcription": "Test transcription"
    })


def handle_ping_command(client_socket, params):
    """Handle PING command - used to check if server is alive."""
    update_activity()

    send_response(client_socket, {
        "status": "alive",
        "recording": recording_active,
        "uptime": time.time() - last_activity_time
    })


def handle_shutdown_command(client_socket, params):
    """Handle SHUTDOWN command - graceful server shutdown."""
    global shutdown_requested

    log("SHUTDOWN command received")
    shutdown_requested = True

    send_response(client_socket, {
        "status": "shutting_down"
    })


def send_response(client_socket, data):
    """Send JSON response to client."""
    try:
        message = json.dumps(data) + "\n"
        client_socket.sendall(message.encode())
    except Exception as e:
        log(f"Failed to send response: {e}", "ERROR")


def handle_client(client_socket):
    """Handle a client connection."""
    try:
        # Read command from client
        data = client_socket.recv(4096).decode().strip()
        if not data:
            return

        try:
            command = json.loads(data)
        except json.JSONDecodeError as e:
            send_response(client_socket, {
                "status": "error",
                "message": f"Invalid JSON: {e}"
            })
            return

        cmd_type = command.get("command")
        params = command.get("params", {})

        log(f"Received command: {cmd_type}")

        # Dispatch to handler
        if cmd_type == "START":
            handle_start_command(client_socket, params)
        elif cmd_type == "STOP":
            handle_stop_command(client_socket, params)
        elif cmd_type == "PING":
            handle_ping_command(client_socket, params)
        elif cmd_type == "SHUTDOWN":
            handle_shutdown_command(client_socket, params)
        else:
            send_response(client_socket, {
                "status": "error",
                "message": f"Unknown command: {cmd_type}"
            })

    except Exception as e:
        log(f"Error handling client: {e}", "ERROR")

    finally:
        try:
            client_socket.close()
        except Exception:
            pass


def idle_monitor_thread():
    """Monitor idle time and shutdown if exceeded."""
    global shutdown_requested

    while not shutdown_requested:
        time.sleep(10)  # Check every 10 seconds

        if check_idle_timeout():
            log(f"Idle timeout ({idle_timeout}s) exceeded - shutting down")
            shutdown_requested = True


def cleanup():
    """Cleanup on exit."""
    global recorder

    log("Server shutting down - cleaning up")

    # Shutdown recorder
    if recorder:
        try:
            recorder.shutdown()
        except Exception:
            pass
        recorder = None

    # Remove socket
    if SOCKET_PATH.exists():
        try:
            SOCKET_PATH.unlink()
        except Exception:
            pass

    # Remove PID file
    if PID_FILE.exists():
        try:
            PID_FILE.unlink()
        except Exception:
            pass

    log("Server shutdown complete")


def signal_handler(signum, frame):
    """Handle shutdown signals."""
    global shutdown_requested
    log(f"Received signal {signum} - shutting down")
    shutdown_requested = True


def main():
    global debug_mode, idle_timeout, shutdown_requested

    # Parse arguments
    import argparse
    parser = argparse.ArgumentParser(description="WSI-Stream persistent server")
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("-t", "--timeout", type=int, default=DEFAULT_IDLE_TIMEOUT,
                        help="Idle timeout in seconds (default: 300)")
    parser.add_argument("-m", "--model", type=str, default="base",
                        help="Whisper model size (default: base)")
    parser.add_argument("-l", "--language", type=str, default="en",
                        help="Language code (default: en)")
    parser.add_argument("--device", type=str, default="auto",
                        choices=["auto", "gpu", "cpu"],
                        help="Device type (default: auto)")

    args = parser.parse_args()
    debug_mode = args.debug
    idle_timeout = args.timeout

    log("=== WSI-Stream Server Starting ===")
    log(f"Model: {args.model}, Language: {args.language}, Device: {args.device}")
    log(f"Idle timeout: {idle_timeout}s")

    # Register cleanup handlers
    atexit.register(cleanup)
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    # Write PID file
    try:
        PID_FILE.write_text(str(os.getpid()))
    except Exception as e:
        log(f"Failed to write PID file: {e}", "WARN")

    # Initialize recorder (this is the expensive part - done once!)
    if not initialize_recorder(args.model, args.language, args.device):
        log("Failed to initialize recorder - exiting", "ERROR")
        return 1

    # Remove old socket if exists
    if SOCKET_PATH.exists():
        try:
            SOCKET_PATH.unlink()
        except Exception as e:
            log(f"Failed to remove old socket: {e}", "ERROR")
            return 1

    # Create Unix socket
    try:
        server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        server_socket.bind(str(SOCKET_PATH))
        server_socket.listen(5)
        server_socket.settimeout(SOCKET_TIMEOUT)  # Non-blocking accept
        log(f"Server listening on {SOCKET_PATH}")
    except Exception as e:
        log(f"Failed to create socket: {e}", "ERROR")
        return 1

    # Start idle monitor thread
    monitor = threading.Thread(target=idle_monitor_thread, daemon=True)
    monitor.start()

    log("Server ready - waiting for clients")

    # Main server loop
    try:
        while not shutdown_requested:
            try:
                client_socket, _ = server_socket.accept()
                # Handle client in current thread (simple sequential processing)
                handle_client(client_socket)
            except socket.timeout:
                # Normal timeout - check shutdown flag
                continue
            except Exception as e:
                if not shutdown_requested:
                    log(f"Accept error: {e}", "ERROR")

    finally:
        server_socket.close()
        cleanup()

    return 0


if __name__ == "__main__":
    sys.exit(main())
