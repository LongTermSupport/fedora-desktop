#!/usr/bin/env python3
"""
WSI-Stream Server - Persistent Speech-to-Text Server
=====================================================
Keeps Whisper model hot in memory for instant recording startup.

Server listens on Unix socket for START/STOP commands from client.
Auto-shuts down after idle timeout (default: 20 minutes).

Memory cost: ~200MB (base) to ~600MB (small model)
Speed improvement: 3-6 seconds â†’ <0.3 seconds for subsequent recordings
"""

import os
import sys
import json
import socket
import subprocess
import threading
import time
import signal
import array
from pathlib import Path
from datetime import datetime

# Constants
SOCKET_PATH = Path(f"/run/user/{os.getuid()}/wsi-stream.socket")
LOG_DIR = Path.home() / ".local/share/speech-to-text"
LOG_FILE = LOG_DIR / "server.log"
PID_FILE = Path(f"/run/user/{os.getuid()}/wsi-stream-server.pid")

# Configuration
DEFAULT_IDLE_TIMEOUT = 1200  # 20 minutes
SOCKET_TIMEOUT = 0.5  # Check for shutdown every 0.5s

# Global state
recorder = None
debug_mode = False
shutdown_requested = False
last_activity_time = time.time()
idle_timeout = DEFAULT_IDLE_TIMEOUT
recording_active = False
server_start_time = None

# Recording pipeline state (managed by START/STOP commands)
audio_process = None          # pw-record subprocess capturing microphone audio
audio_feed_thread = None      # Thread that reads audio chunks and feeds to recorder
audio_feed_stop = None        # threading.Event to signal the feeding thread to stop
transcription_text = ""       # Accumulated transcription from realtime callbacks
transcription_lock = threading.Lock()  # Protects transcription_text from concurrent access
active_client_addr = None     # Address of client that started current recording (for disconnect detection)
watchdog_timer = None         # Timer that enforces maximum recording duration (Layer 3 protection)
WATCHDOG_TIMEOUT = 125        # Maximum recording duration (5 seconds buffer beyond client timeout)


def log(message, level="INFO"):
    """Log message to file and stderr if debug mode."""
    timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
    log_line = f"[{timestamp}] [SERVER] [{level}] {message}"

    if debug_mode:
        print(log_line, file=sys.stderr)

    try:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        with open(LOG_FILE, "a") as f:
            f.write(log_line + "\n")
    except Exception:
        pass


def update_activity():
    """Update last activity timestamp."""
    global last_activity_time
    last_activity_time = time.time()


def check_idle_timeout():
    """Check if server has been idle too long."""
    if recording_active:
        return False

    idle_time = time.time() - last_activity_time
    return idle_time >= idle_timeout


def on_realtime_transcription_update(text):
    """Callback for real-time transcription updates from the recorder.

    Called by RealtimeSTT's realtime transcription worker whenever new partial
    transcription text is available. Accumulates text in a thread-safe manner
    so handle_stop_command() can retrieve the final result.
    """
    global transcription_text

    if not text:
        return

    text = text.strip()
    if not text:
        return

    with transcription_lock:
        transcription_text = text

    log(f"Realtime transcription update: '{text}'")


def initialize_recorder(model_size="base", language="en", device_type="auto"):
    """Initialize the AudioToTextRecorder - expensive operation done once."""
    global recorder

    try:
        from RealtimeSTT import AudioToTextRecorder

        log(f"Initializing recorder (model={model_size}, language={language}, device={device_type})")

        recorder_config = {
            "model": model_size,
            "language": language,
            "use_microphone": False,  # We'll feed audio manually
            "silero_sensitivity": 0.4,
            "enable_realtime_transcription": True,
            "realtime_processing_pause": 0.2,
            "on_realtime_transcription_update": on_realtime_transcription_update,
            "spinner": False,
        }

        # Device selection
        if device_type == "auto" or device_type == "gpu":
            recorder_config["device"] = "cuda"
            recorder_config["compute_type"] = "float16"
            log("Requesting GPU (CUDA)")
        else:
            recorder_config["device"] = "cpu"
            recorder_config["compute_type"] = "int8"
            log("Using CPU")

        recorder = AudioToTextRecorder(**recorder_config)
        log("Recorder initialized successfully - ready for instant recording")
        return True

    except ImportError as e:
        log(f"RealtimeSTT not installed: {e}", "ERROR")
        return False
    except Exception as e:
        log(f"Recorder initialization failed: {e}", "ERROR")
        return False


def audio_feeding_thread_func(proc, stop_event):
    """Read audio chunks from pw-record and feed them to the recorder.

    This function runs in a dedicated thread. It reads raw PCM audio data
    (16000 Hz, mono, S16_LE) from the pw-record subprocess stdout pipe and
    feeds it to the recorder via feed_audio(). The thread exits when the
    stop_event is set or the audio stream ends.

    Args:
        proc: The pw-record subprocess with audio data on stdout.
        stop_event: threading.Event that signals this thread to stop.
    """
    # 1024 samples * 2 bytes per sample (S16_LE) = 2048 bytes per chunk
    chunk_size = 1024 * 2
    chunks_fed = 0

    log("Audio feeding thread started")

    try:
        while not stop_event.is_set():
            chunk = proc.stdout.read(chunk_size)
            if not chunk:
                log("Audio stream ended (pw-record closed)")
                break

            if len(chunk) < 2:
                continue

            # Convert raw bytes to signed 16-bit integer array.
            # RealtimeSTT's feed_audio() expects array-like int16 data.
            try:
                audio_array = array.array('h', chunk)
                recorder.feed_audio(audio_array)
                chunks_fed += 1

                if chunks_fed % 50 == 0:
                    log(f"Fed {chunks_fed} audio chunks ({chunks_fed * chunk_size / 16000:.1f}s of audio)")
            except Exception as e:
                log(f"Error feeding audio chunk {chunks_fed}: {e}", "ERROR")
                break
    except Exception as e:
        log(f"Audio feeding thread error: {e}", "ERROR")
    finally:
        log(f"Audio feeding thread exiting (fed {chunks_fed} chunks total)")


def watchdog_timeout_handler():
    """LAYER 3 PROTECTION: Watchdog timer callback - force stop if recording runs too long.

    This is the last line of defense against microphone resource leaks.
    If the client crashes, disconnects, or fails to send STOP within the timeout,
    this timer will forcibly stop the recording pipeline.
    """
    global recording_active, active_client_addr, watchdog_timer

    log("LAYER 3 PROTECTION: Watchdog timeout triggered", "WARN")
    log(f"Recording exceeded {WATCHDOG_TIMEOUT}s without STOP - forcing cleanup")

    if recording_active:
        try:
            stop_recording_pipeline()
            recording_active = False
            active_client_addr = None
            log("Watchdog: Recording pipeline stopped successfully")
        except Exception as e:
            log(f"Watchdog: Error during forced stop: {e}", "ERROR")
    else:
        log("Watchdog: Recording already stopped (false alarm)")

    watchdog_timer = None


def stop_recording_pipeline():
    """Stop the active recording pipeline and clean up all resources.

    Terminates the pw-record process, signals the feeding thread to stop,
    calls recorder.stop() to finalize transcription, and returns the
    accumulated transcription text.

    Returns:
        The transcribed text string, or empty string if nothing was captured.
    """
    global audio_process, audio_feed_thread, audio_feed_stop, transcription_text

    # Step 1: Signal the feeding thread to stop reading audio
    if audio_feed_stop:
        audio_feed_stop.set()
        log("Signaled audio feeding thread to stop")

    # Step 2: Terminate pw-record so the feeding thread's read() unblocks
    if audio_process:
        try:
            audio_process.terminate()
            audio_process.wait(timeout=2)
            log(f"pw-record terminated (exit code: {audio_process.returncode})")
        except subprocess.TimeoutExpired:
            log("pw-record did not terminate in time, killing", "WARN")
            audio_process.kill()
            audio_process.wait(timeout=1)
            log("pw-record killed")
        except Exception as e:
            log(f"Error terminating pw-record: {e}", "WARN")
            try:
                audio_process.kill()
            except Exception:
                pass

    # Step 3: Wait for the feeding thread to finish
    if audio_feed_thread and audio_feed_thread.is_alive():
        audio_feed_thread.join(timeout=3)
        if audio_feed_thread.is_alive():
            log("Audio feeding thread did not exit in time", "WARN")
        else:
            log("Audio feeding thread joined successfully")

    # Step 4: Stop the recorder to finalize any pending transcription.
    # With use_microphone=False, do NOT call recorder.text() as it blocks
    # indefinitely. The realtime callback has already captured the text.
    if recorder:
        try:
            recorder.stop()
            log("Recorder stopped")
        except Exception as e:
            log(f"Error stopping recorder: {e}", "WARN")

    # Step 5: Wait for final transcription to complete
    # Poll transcription_text until it stops updating (max 2 seconds)
    # This ensures we capture the last spoken words
    last_text = ""
    stable_count = 0
    max_polls = 20  # 20 * 0.1s = 2 seconds max

    for _ in range(max_polls):
        time.sleep(0.1)
        with transcription_lock:
            current_text = transcription_text

        if current_text == last_text:
            stable_count += 1
            if stable_count >= 3:  # Stable for 0.3s
                break
        else:
            stable_count = 0
            last_text = current_text

    log(f"Final transcription stabilized after {(_ + 1) * 0.1:.1f}s")

    # Step 6: Retrieve accumulated transcription text
    with transcription_lock:
        result = transcription_text

    # Step 7: Reset pipeline state for next recording cycle
    audio_process = None
    audio_feed_thread = None
    audio_feed_stop = None
    with transcription_lock:
        transcription_text = ""

    return result


def handle_start_command(client_socket, params):
    """Handle START recording command from client.

    Spawns a pw-record process to capture microphone audio, starts the
    recorder's realtime transcription, and launches a feeding thread that
    reads audio chunks from pw-record and feeds them to the recorder.

    The audio pipeline:
      microphone -> pw-record (16kHz mono S16_LE) -> feeding thread -> recorder.feed_audio() -> realtime callback -> transcription_text
    """
    global recording_active, active_client_addr
    global audio_process, audio_feed_thread, audio_feed_stop, transcription_text

    update_activity()

    if recording_active:
        send_response(client_socket, {
            "status": "error",
            "message": "Recording already active"
        })
        return

    if not recorder:
        send_response(client_socket, {
            "status": "error",
            "message": "Recorder not initialized"
        })
        return

    log("START command received - beginning recording")

    # Track the client that started this recording (for disconnect detection)
    try:
        active_client_addr = client_socket.getpeername()
        log(f"Tracking client: {active_client_addr}")
    except Exception:
        active_client_addr = "unknown"

    # Reset transcription accumulator for this new recording session
    with transcription_lock:
        transcription_text = ""

    # Start pw-record to capture microphone audio as raw PCM data.
    # Format: 16000 Hz sample rate, 1 channel (mono), signed 16-bit little-endian.
    # This matches the format RealtimeSTT expects for feed_audio().
    pw_record_cmd = [
        "pw-record",
        "--rate", "16000",
        "--channels", "1",
        "--format", "s16",
        "-"  # Output raw PCM to stdout
    ]

    try:
        audio_process = subprocess.Popen(
            pw_record_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL
        )
        log(f"pw-record started (PID {audio_process.pid})")
    except FileNotFoundError:
        log("pw-record not found - PipeWire not installed", "ERROR")
        send_response(client_socket, {
            "status": "error",
            "message": "pw-record not found (PipeWire required)"
        })
        return
    except Exception as e:
        log(f"Failed to start pw-record: {e}", "ERROR")
        send_response(client_socket, {
            "status": "error",
            "message": f"Audio capture failed: {e}"
        })
        return

    # Verify pw-record is actually running (check for immediate exit due to
    # audio device busy, permission errors, etc.)
    time.sleep(0.1)
    if audio_process.poll() is not None:
        exit_code = audio_process.returncode
        log(f"pw-record exited immediately with code {exit_code}", "ERROR")
        audio_process = None
        send_response(client_socket, {
            "status": "error",
            "message": f"Audio capture failed (pw-record exit code: {exit_code})"
        })
        return

    # Start the recorder's realtime transcription processing.
    # This sets is_recording=True internally so feed_audio() data gets processed.
    try:
        recorder.start()
        log("Recorder started (realtime transcription active)")
    except Exception as e:
        log(f"Failed to start recorder: {e}", "ERROR")
        # Clean up pw-record since we can't proceed
        try:
            audio_process.terminate()
            audio_process.wait(timeout=2)
        except Exception:
            try:
                audio_process.kill()
            except Exception:
                pass
        audio_process = None
        send_response(client_socket, {
            "status": "error",
            "message": f"Recorder start failed: {e}"
        })
        return

    # Launch the audio feeding thread to continuously read from pw-record
    # and push chunks into the recorder
    audio_feed_stop = threading.Event()
    audio_feed_thread = threading.Thread(
        target=audio_feeding_thread_func,
        args=(audio_process, audio_feed_stop),
        daemon=True
    )
    audio_feed_thread.start()
    log("Audio feeding thread launched")

    recording_active = True

    # LAYER 3 PROTECTION: Start watchdog timer
    # If client crashes or fails to send STOP, this will force cleanup
    global watchdog_timer
    watchdog_timer = threading.Timer(WATCHDOG_TIMEOUT, watchdog_timeout_handler)
    watchdog_timer.daemon = True
    watchdog_timer.start()
    log(f"Watchdog timer started ({WATCHDOG_TIMEOUT}s timeout)")

    send_response(client_socket, {
        "status": "recording",
        "message": "Recording started"
    })


def handle_stop_command(client_socket, params):
    """Handle STOP recording command from client.

    Stops the pw-record audio capture, waits for the feeding thread to finish,
    finalizes transcription via recorder.stop(), and returns the accumulated
    transcription text to the client.
    """
    global recording_active, active_client_addr, watchdog_timer

    update_activity()

    if not recording_active:
        send_response(client_socket, {
            "status": "error",
            "message": "No active recording"
        })
        return

    log("STOP command received - stopping recording")

    # Cancel watchdog timer since we're stopping gracefully
    if watchdog_timer:
        watchdog_timer.cancel()
        watchdog_timer = None
        log("Watchdog timer cancelled (graceful stop)")

    # Stop the entire recording pipeline and get the transcribed text
    text = stop_recording_pipeline()

    recording_active = False
    active_client_addr = None

    log(f"Recording stopped, transcription: '{text}' ({len(text)} chars)")

    send_response(client_socket, {
        "status": "stopped",
        "transcription": text
    })


def handle_ping_command(client_socket, params):
    """Handle PING command - used to check if server is alive."""
    update_activity()

    send_response(client_socket, {
        "status": "alive",
        "recording": recording_active,
        "uptime_seconds": time.time() - server_start_time,
        "idle_seconds": time.time() - last_activity_time
    })


def handle_shutdown_command(client_socket, params):
    """Handle SHUTDOWN command - graceful server shutdown."""
    global shutdown_requested

    log("SHUTDOWN command received")
    shutdown_requested = True

    send_response(client_socket, {
        "status": "shutting_down"
    })


def send_response(client_socket, data):
    """Send JSON response to client."""
    try:
        message = json.dumps(data) + "\n"
        client_socket.sendall(message.encode())
    except Exception as e:
        log(f"Failed to send response: {e}", "ERROR")


def handle_client(client_socket):
    """Handle a client connection."""
    global recording_active, active_client_addr

    client_addr = None
    try:
        client_addr = client_socket.getpeername()
    except Exception:
        client_addr = "unknown"

    try:
        # Read command from client
        data = client_socket.recv(4096).decode().strip()
        if not data:
            log(f"Client {client_addr} disconnected (empty data)")
            # Check if this is the active recording client
            if recording_active and client_addr == active_client_addr:
                log("LAYER 2 PROTECTION: Active recording client disconnected without STOP", "WARN")
                log("Automatically stopping recording pipeline to release microphone")
                stop_recording_pipeline()
                recording_active = False
                active_client_addr = None
            return

        try:
            command = json.loads(data)
        except json.JSONDecodeError as e:
            send_response(client_socket, {
                "status": "error",
                "message": f"Invalid JSON: {e}"
            })
            return

        cmd_type = command.get("command")
        params = command.get("params", {})

        log(f"Received command: {cmd_type} from {client_addr}")

        # Dispatch to handler
        if cmd_type == "START":
            handle_start_command(client_socket, params)
        elif cmd_type == "STOP":
            handle_stop_command(client_socket, params)
        elif cmd_type == "PING":
            handle_ping_command(client_socket, params)
        elif cmd_type == "SHUTDOWN":
            handle_shutdown_command(client_socket, params)
        else:
            send_response(client_socket, {
                "status": "error",
                "message": f"Unknown command: {cmd_type}"
            })

    except (ConnectionResetError, BrokenPipeError) as e:
        log(f"Client {client_addr} connection lost: {e}", "WARN")
        # LAYER 2 PROTECTION: Client crashed or was killed
        if recording_active and client_addr == active_client_addr:
            log("LAYER 2 PROTECTION: Active recording client lost connection", "WARN")
            log("Automatically stopping recording pipeline to release microphone")
            stop_recording_pipeline()
            recording_active = False
            active_client_addr = None

    except Exception as e:
        log(f"Error handling client {client_addr}: {e}", "ERROR")

    finally:
        try:
            client_socket.close()
        except Exception:
            pass


def idle_monitor_thread():
    """Monitor idle time and shutdown if exceeded."""
    global shutdown_requested

    while not shutdown_requested:
        time.sleep(10)  # Check every 10 seconds

        if check_idle_timeout():
            log(f"Idle timeout ({idle_timeout}s) exceeded - shutting down")
            shutdown_requested = True


cleanup_done = False


def cleanup():
    """Cleanup on exit."""
    global recorder, recording_active, cleanup_done, watchdog_timer, active_client_addr

    if cleanup_done:
        return
    cleanup_done = True

    log("Server shutting down - cleaning up")

    # Cancel watchdog timer if running
    if watchdog_timer:
        watchdog_timer.cancel()
        watchdog_timer = None
        log("Watchdog timer cancelled (server shutdown)")

    # If a recording is active, stop the pipeline first
    if recording_active:
        log("Active recording detected during shutdown - stopping pipeline")
        stop_recording_pipeline()
        recording_active = False
        active_client_addr = None

    # Shutdown recorder (releases model memory and audio resources)
    if recorder:
        try:
            recorder.shutdown()
        except Exception:
            pass
        recorder = None

    # Remove socket
    if SOCKET_PATH.exists():
        try:
            SOCKET_PATH.unlink()
        except Exception:
            pass

    # Remove PID file
    if PID_FILE.exists():
        try:
            PID_FILE.unlink()
        except Exception:
            pass

    log("Server shutdown complete")


def signal_handler(signum, frame):
    """Handle shutdown signals."""
    global shutdown_requested
    log(f"Received signal {signum} - shutting down")
    shutdown_requested = True


def main():
    global debug_mode, idle_timeout, shutdown_requested, server_start_time

    # Parse arguments
    import argparse
    parser = argparse.ArgumentParser(description="WSI-Stream persistent server")
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("-t", "--timeout", type=int, default=DEFAULT_IDLE_TIMEOUT,
                        help="Idle timeout in seconds (default: 300)")
    parser.add_argument("-m", "--model", type=str, default="base",
                        help="Whisper model size (default: base)")
    parser.add_argument("-l", "--language", type=str, default="en",
                        help="Language code (default: en)")
    parser.add_argument("--device", type=str, default="auto",
                        choices=["auto", "gpu", "cpu"],
                        help="Device type (default: auto)")

    args = parser.parse_args()
    debug_mode = args.debug
    idle_timeout = args.timeout

    server_start_time = time.time()
    log("=== WSI-Stream Server Starting ===")
    log(f"Model: {args.model}, Language: {args.language}, Device: {args.device}")
    log(f"Idle timeout: {idle_timeout}s")

    # Register signal handlers
    signal.signal(signal.SIGTERM, signal_handler)
    signal.signal(signal.SIGINT, signal_handler)

    # SINGLETON ENFORCEMENT: Check if another instance is already running
    if PID_FILE.exists():
        try:
            existing_pid = int(PID_FILE.read_text().strip())
            # Check if that PID is actually running
            try:
                os.kill(existing_pid, 0)  # Signal 0 just checks if process exists
                # Process exists - another instance is running
                log(f"ERROR: Server already running (PID {existing_pid})", "ERROR")
                log(f"PID file: {PID_FILE}", "ERROR")
                log("To force restart, kill the existing server first:", "ERROR")
                log(f"  kill {existing_pid}", "ERROR")
                sys.exit(1)
            except OSError:
                # Process doesn't exist - stale PID file
                log(f"Removing stale PID file (PID {existing_pid} not running)", "WARN")
                PID_FILE.unlink()
        except (ValueError, OSError) as e:
            log(f"Invalid PID file, removing: {e}", "WARN")
            PID_FILE.unlink()

    # Check if socket already exists (shouldn't happen but be safe)
    if SOCKET_PATH.exists():
        log(f"Removing stale socket: {SOCKET_PATH}", "WARN")
        SOCKET_PATH.unlink()

    # Write PID file
    try:
        PID_FILE.write_text(str(os.getpid()))
    except Exception as e:
        log(f"Failed to write PID file: {e}", "WARN")

    # Initialize recorder (this is the expensive part - done once!)
    if not initialize_recorder(args.model, args.language, args.device):
        log("Failed to initialize recorder - exiting", "ERROR")
        return 1

    # Remove old socket if exists
    if SOCKET_PATH.exists():
        try:
            SOCKET_PATH.unlink()
        except Exception as e:
            log(f"Failed to remove old socket: {e}", "ERROR")
            return 1

    # Create Unix socket
    try:
        server_socket = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        server_socket.bind(str(SOCKET_PATH))
        server_socket.listen(5)
        server_socket.settimeout(SOCKET_TIMEOUT)  # Non-blocking accept
        log(f"Server listening on {SOCKET_PATH}")
    except Exception as e:
        log(f"Failed to create socket: {e}", "ERROR")
        return 1

    # Start idle monitor thread
    monitor = threading.Thread(target=idle_monitor_thread, daemon=True)
    monitor.start()

    log("Server ready - waiting for clients")

    # Main server loop
    try:
        while not shutdown_requested:
            try:
                client_socket, _ = server_socket.accept()
                # Handle client in current thread (simple sequential processing)
                handle_client(client_socket)
            except socket.timeout:
                # Normal timeout - check shutdown flag
                continue
            except Exception as e:
                if not shutdown_requested:
                    log(f"Accept error: {e}", "ERROR")

    finally:
        server_socket.close()
        cleanup()

    return 0


if __name__ == "__main__":
    sys.exit(main())
