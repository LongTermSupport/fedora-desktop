#!/usr/bin/env python3
"""
WSI-Article - Article Mode: Looped Streaming Speech-to-Text
============================================================
Records indefinitely in 120-second chunks. Each chunk is appended to a raw
article file. wsi-article-window displays the raw text and a Claude-polished
version, re-polishing after each chunk.
"""

SCRIPT_VERSION = "1.2.0"

import os
import sys
import subprocess
import signal
import time
import threading
import argparse
import atexit
from pathlib import Path
from datetime import datetime

# Suppress HuggingFace Hub rate-limit warnings - model downloads are deliberate
os.environ.setdefault("HF_TOKEN", "")
os.environ.setdefault("TRANSFORMERS_OFFLINE", "1")
os.environ.setdefault("HF_DATASETS_OFFLINE", "1")

# Constants
LOG_DIR = Path.home() / ".local/share/speech-to-text"
LOG_FILE = LOG_DIR / "debug.log"
CACHE_DIR = Path.home() / ".cache/speech-to-text"

# Use same PID file as wsi-stream so Escape keybinding can stop us
PID_FILE = Path("/dev/shm") / f"stt-recording-{os.getenv('USER')}.pid"

# Article-specific files
ARTICLE_RAW_FILE = CACHE_DIR / "article-raw.txt"
ARTICLE_BUFFER_FILE = CACHE_DIR / "article-buffer.txt"   # within-chunk phrases
ARTICLE_PARTIAL_FILE = CACHE_DIR / "article-partial.txt"  # real-time partial
ARTICLE_TRIGGER_FILE = CACHE_DIR / "article-chunk.trigger"

DBUS_PATH = "/org/fedoradesktop/SpeechToText"
DBUS_INTERFACE = "org.fedoradesktop.SpeechToText"

CHUNK_DURATION = 120  # seconds per chunk before flushing

# Global state
debug_mode = False
no_notify = False
stop_requested = False
recorder = None


def cleanup_on_exit():
    """Ensure IDLE signal is sent and mic is released on any exit."""
    global recorder
    try:
        emit_dbus_signal("StateChanged", "IDLE")
    except Exception:
        pass
    _release_recorder()
    for f in (PID_FILE, ARTICLE_PARTIAL_FILE, ARTICLE_BUFFER_FILE):
        if f.exists():
            try:
                f.unlink()
            except Exception:
                pass


def _release_recorder():
    """Shut down recorder and release audio device."""
    global recorder
    if recorder is None:
        return
    r = recorder
    recorder = None
    for method in ('stop', 'abort', 'shutdown'):
        try:
            getattr(r, method)()
        except Exception:
            pass
    del r
    import gc
    gc.collect()


atexit.register(cleanup_on_exit)


def log(message, level="INFO"):
    timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
    log_line = f"[{timestamp}] [ARTICLE] [{level}] {message}"
    if debug_mode:
        print(log_line, file=sys.stderr)
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        with open(LOG_FILE, "a") as f:
            f.write(log_line + "\n")


def emit_dbus_signal(signal_name, value):
    try:
        subprocess.run([
            "gdbus", "emit", "--session",
            "--object-path", DBUS_PATH,
            "--signal", f"{DBUS_INTERFACE}.{signal_name}",
            value
        ], capture_output=True, timeout=1)
    except Exception as e:
        log(f"DBus signal failed: {e}", "WARN")


def notify(state, message):
    log(f"State: {state} - {message}")
    emit_dbus_signal("StateChanged", state)
    if no_notify:
        return
    try:
        subprocess.run([
            "gdbus", "call", "--session",
            "--dest", "org.freedesktop.Notifications",
            "--object-path", "/org/freedesktop/Notifications",
            "--method", "org.freedesktop.Notifications.Notify",
            "speech-to-text-article", "0", "audio-input-microphone",
            "Article Mode", message, "[]", "{}", "2000"
        ], capture_output=True, timeout=1)
    except Exception:
        pass


def on_partial_update(new_text):
    """Real-time transcription callback - writes current partial to file."""
    if not new_text or not new_text.strip():
        return
    try:
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        ARTICLE_PARTIAL_FILE.write_text(new_text.strip())
    except Exception:
        pass


def write_buffer(chunk_texts):
    """Write accumulated within-chunk phrases so the window can display them."""
    try:
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        ARTICLE_BUFFER_FILE.write_text("\n".join(chunk_texts))
    except Exception as e:
        log(f"Buffer write failed: {e}", "WARN")


def flush_chunk(chunk_texts, chunk_num):
    """Append current chunk to the raw article file and signal the window."""
    if not chunk_texts:
        log(f"Chunk {chunk_num}: nothing to flush")
        return
    chunk_text = " ".join(chunk_texts)
    if chunk_text:
        chunk_text = chunk_text[0].upper() + chunk_text[1:]
    log(f"Flushing chunk {chunk_num} ({len(chunk_text)} chars)")
    try:
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        with open(ARTICLE_RAW_FILE, "a") as f:
            f.write(chunk_text + "\n\n")
        ARTICLE_BUFFER_FILE.write_text("")  # clear buffer — now in raw
        ARTICLE_TRIGGER_FILE.write_text(str(time.time()))
        log(f"Chunk {chunk_num} written, trigger updated")
    except Exception as e:
        log(f"Chunk flush failed: {e}", "ERROR")


def check_dependencies():
    try:
        import RealtimeSTT  # noqa: F401
        return True
    except ImportError as e:
        log(f"RealtimeSTT not installed: {e}", "ERROR")
        notify("ERROR", "RealtimeSTT not installed\n\npip install --user RealtimeSTT")
        return False


def run_article_mode(args):
    global debug_mode, no_notify, stop_requested, recorder

    if not check_dependencies():
        return 1

    from RealtimeSTT import AudioToTextRecorder

    print(f"wsi-article v{SCRIPT_VERSION} starting (pid={os.getpid()})", file=sys.stderr)
    PID_FILE.write_text(str(os.getpid()))
    log(f"PID file written: {PID_FILE} (pid={os.getpid()})")

    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    ARTICLE_RAW_FILE.write_text("")
    ARTICLE_BUFFER_FILE.write_text("")
    ARTICLE_PARTIAL_FILE.write_text("")
    if ARTICLE_TRIGGER_FILE.exists():
        ARTICLE_TRIGGER_FILE.unlink()

    model_size = os.environ.get("WHISPER_MODEL", "base")
    language = args.language or os.environ.get("WHISPER_LANGUAGE", "en") or None
    log(f"Model: {model_size}, language: {language or 'auto-detect'}")

    # Shared event to unblock the recording loop cleanly
    phrase_unblock = threading.Event()

    def handle_signal(signum, frame):
        global stop_requested
        log(f"Signal {signum} received — stopping")
        stop_requested = True
        phrase_unblock.set()  # unblock any wait()
        if recorder:
            try:
                recorder.stop()
                log("Called recorder.stop()")
            except Exception as e:
                log(f"recorder.stop() failed: {e}", "WARN")

    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    try:
        notify("PREPARING", "Loading model...")

        recorder_config = {
            "model": model_size,
            "language": language,
            "silero_sensitivity": 0.4,
            # Short silence so phrases are returned promptly in the loop
            "post_speech_silence_duration": 1.5,
            "min_length_of_recording": 0.3,
            "min_gap_between_recordings": 0.1,
            "enable_realtime_transcription": True,
            "realtime_processing_pause": 0.2,
            "on_realtime_transcription_update": on_partial_update,
            "spinner": False,
        }
        recorder_config["device"] = "cuda"
        recorder_config["compute_type"] = "float16"

        recorder = AudioToTextRecorder(**recorder_config)
        log("Recorder initialized")

        notify("PREPARING", "Initializing audio...")
        time.sleep(0.5)

        # Do NOT emit RECORDING via DBus — the old extension (before logout)
        # has no _isArticleMode guard and would start a countdown that calls
        # _stopRecording() at ~117s, killing the process. The panel indicator
        # is handled by the window's _launchArticleMode() spinner instead.
        log("Article mode recording started")
        if not no_notify:
            try:
                subprocess.run([
                    "gdbus", "call", "--session",
                    "--dest", "org.freedesktop.Notifications",
                    "--object-path", "/org/freedesktop/Notifications",
                    "--method", "org.freedesktop.Notifications.Notify",
                    "speech-to-text-article", "0", "audio-input-microphone",
                    "Article Mode", "Recording…", "[]", "{}", "2000"
                ], capture_output=True, timeout=1)
            except Exception:
                pass

        chunk_texts = []
        chunk_start = time.time()
        chunk_num = 0

        # Shared phrase state — only ONE phrase thread runs at a time.
        # Creating these outside the loop avoids the Python late-binding closure
        # bug where a new iteration's reassignment clobbers the old thread's
        # phrase_done/phrase_result references, leading to concurrent
        # recorder.text() calls that corrupt the recorder after ~120s.
        phrase_done = threading.Event()
        phrase_result = [None]

        def _phrase_thread_fn():
            try:
                phrase_result[0] = recorder.text()
            except Exception as e:
                log(f"recorder.text() error: {e}", "WARN")
                phrase_result[0] = None
            finally:
                phrase_done.set()
                phrase_unblock.set()

        def _start_phrase_thread():
            phrase_done.clear()
            phrase_result[0] = None
            t = threading.Thread(target=_phrase_thread_fn, daemon=True)
            t.start()

        # Start the first phrase before entering the loop
        _start_phrase_thread()

        while not stop_requested:
            # Wait for phrase completion, stop signal, or periodic chunk-timer
            # check. Short timeout (5s) keeps chunk flush responsive.
            phrase_unblock.wait(timeout=5)
            phrase_unblock.clear()

            if stop_requested:
                # Give the phrase thread a moment to return final text
                phrase_done.wait(timeout=3)

            # If a phrase completed, collect it and start the next one
            if phrase_done.is_set():
                phrase = phrase_result[0]
                if phrase and phrase.strip():
                    chunk_texts.append(phrase.strip())
                    write_buffer(chunk_texts)
                    log(f"Phrase collected: {len(phrase)} chars")
                if not stop_requested:
                    _start_phrase_thread()

            # Flush chunk every CHUNK_DURATION seconds
            elapsed = time.time() - chunk_start
            if not stop_requested and elapsed >= CHUNK_DURATION and chunk_texts:
                chunk_num += 1
                flush_chunk(chunk_texts, chunk_num)
                chunk_texts = []
                chunk_start = time.time()
                log(f"Starting chunk {chunk_num + 1}")

            if stop_requested:
                break

        # Final flush of any remaining phrases
        if chunk_texts:
            chunk_num += 1
            flush_chunk(chunk_texts, chunk_num)

        log("Article recording ended cleanly")

    except Exception as e:
        log(f"Article mode error: {e}", "ERROR")
        notify("ERROR", f"Article recording failed: {e}")
        return 1

    finally:
        if PID_FILE.exists():
            PID_FILE.unlink()
        _release_recorder()
        for f in (ARTICLE_PARTIAL_FILE, ARTICLE_BUFFER_FILE):
            if f.exists():
                try:
                    f.unlink()
                except Exception:
                    pass
        emit_dbus_signal("StateChanged", "IDLE")
        log("Mic released, IDLE signal sent")

    return 0


def main():
    global debug_mode, no_notify

    parser = argparse.ArgumentParser(description="Article mode: looped speech-to-text")
    parser.add_argument("-d", "--debug", action="store_true")
    parser.add_argument("-l", "--language", type=str, default=None)
    parser.add_argument("--no-notify", action="store_true")

    args = parser.parse_args()
    debug_mode = args.debug
    no_notify = args.no_notify

    try:
        return run_article_mode(args)
    except Exception as e:
        debug_mode = True
        log(f"FATAL: {e}", "CRITICAL")
        import traceback
        log(traceback.format_exc(), "CRITICAL")
        notify("ERROR", f"Article mode crashed: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
