#!/usr/bin/env python3
"""
WSI-Stream - Streaming Speech-to-Text with Real-time Transcription
===================================================================
Transcribes in real-time to a buffer file, then pastes instantly on stop.

WORKFLOW:
  1. Press Insert -> starts recording, transcription runs in parallel
  2. Partial results stream to buffer file (user can watch if desired)
  3. Press Insert again -> instantly pastes final text (no transcription wait)

The key benefit: transcription happens DURING recording, so paste is instant.
"""

import os
import sys
import subprocess
import signal
import time
import argparse
import atexit
import socket
import json
from pathlib import Path
from datetime import datetime

# Suppress HuggingFace Hub rate-limit warnings - model downloads are deliberate
os.environ.setdefault("HF_TOKEN", "")
os.environ.setdefault("TRANSFORMERS_OFFLINE", "1")
os.environ.setdefault("HF_DATASETS_OFFLINE", "1")

# Constants
LOG_DIR = Path.home() / ".local/share/speech-to-text"
LOG_FILE = LOG_DIR / "debug.log"
CACHE_DIR = Path.home() / ".cache/speech-to-text"
TRANSCRIPTION_FILE = CACHE_DIR / "last-transcription.txt"
BUFFER_FILE = CACHE_DIR / "streaming-buffer.txt"
# Use same PID file as wsi so extension can stop us
PID_FILE = Path("/dev/shm") / f"stt-recording-{os.getenv('USER')}.pid"

# Server mode constants
SERVER_SOCKET = Path(f"/run/user/{os.getuid()}/wsi-stream.socket")
SERVER_SCRIPT = Path.home() / ".local/bin/wsi-stream-server"
SERVER_PID_FILE = Path(f"/run/user/{os.getuid()}/wsi-stream-server.pid")

DBUS_PATH = "/org/fedoradesktop/SpeechToText"
DBUS_INTERFACE = "org.fedoradesktop.SpeechToText"

# Global state
debug_mode = False
no_notify = False
stop_requested = False
recorder = None
current_text = ""


def cleanup_on_exit():
    """Ensure IDLE signal is sent and mic is released on any exit."""
    global recorder
    try:
        emit_dbus_signal("StateChanged", "IDLE")
    except Exception:
        pass
    if recorder:
        try:
            recorder.shutdown()
        except Exception:
            pass
    # Clean up PID file
    if PID_FILE.exists():
        try:
            PID_FILE.unlink()
        except Exception:
            pass


atexit.register(cleanup_on_exit)


def log(message, level="INFO"):
    """Log message to file and stderr if debug mode."""
    timestamp = datetime.now().strftime("%Y-%m-%dT%H:%M:%S")
    log_line = f"[{timestamp}] [STREAM] [{level}] {message}"

    if debug_mode:
        print(log_line, file=sys.stderr)
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        with open(LOG_FILE, "a") as f:
            f.write(log_line + "\n")


def emit_dbus_signal(signal_name, value):
    """Emit DBus signal for extension communication."""
    try:
        subprocess.run([
            "gdbus", "emit", "--session",
            "--object-path", DBUS_PATH,
            "--signal", f"{DBUS_INTERFACE}.{signal_name}",
            value
        ], capture_output=True, timeout=1)
    except Exception as e:
        log(f"DBus signal failed: {e}", "WARN")


def notify(state, message):
    """Send notification and DBus state signal."""
    log(f"State: {state} - {message}")
    emit_dbus_signal("StateChanged", state)

    # Skip desktop notification if --no-notify was passed
    if no_notify:
        return

    try:
        subprocess.run([
            "gdbus", "call", "--session",
            "--dest", "org.freedesktop.Notifications",
            "--object-path", "/org/freedesktop/Notifications",
            "--method", "org.freedesktop.Notifications.Notify",
            "speech-to-text-stream",
            "0",
            "audio-input-microphone",
            "Speech to Text (Streaming)",
            message,
            "[]", "{}", "2000"
        ], capture_output=True, timeout=1)
    except Exception:
        pass


def copy_to_clipboard(text, use_clipboard=False):
    """Copy text to clipboard selection."""
    wm = os.environ.get("XDG_SESSION_TYPE", "unknown")

    if wm == "wayland":
        cmd = ["wl-copy"] if use_clipboard else ["wl-copy", "-p"]
    elif wm == "x11":
        cmd = ["xsel", "-ib"] if use_clipboard else ["xsel", "-ip"]
    else:
        log(f"Unknown window manager: {wm}", "ERROR")
        return False

    try:
        # Do NOT use communicate() - it waits for wl-copy to exit, which drops
        # clipboard ownership before we can paste. Instead, write to stdin and
        # leave the process running so it holds clipboard ownership until pasted.
        proc = subprocess.Popen(cmd, stdin=subprocess.PIPE)
        proc.stdin.write(text.encode())
        proc.stdin.close()

        # Brief wait for wl-copy to register with the compositor
        time.sleep(0.1)

        # Check process status (but don't wait for it - it should stay alive)
        rc = proc.poll()
        if rc is not None and rc != 0:
            log(f"Clipboard copy failed with exit code {rc}", "ERROR")
            return False

        # Verify clipboard was actually set (debug only)
        try:
            verify = subprocess.run(["wl-paste"], capture_output=True, timeout=1)
            if verify.returncode == 0 and verify.stdout:
                log(f"Clipboard copy successful ({len(text)} chars to {'CLIPBOARD' if use_clipboard else 'PRIMARY'})")
                log(f"Clipboard verified: {len(verify.stdout.decode())} chars readable")
            else:
                log(f"Clipboard copy: wl-copy started but clipboard empty (rc={verify.returncode})", "WARN")
        except Exception as e:
            log(f"Clipboard copy successful ({len(text)} chars) - verify skipped: {e}")

        return True
    except Exception as e:
        log(f"Clipboard copy failed: {e}", "ERROR")
        return False


def auto_paste(text, skip_enter=False, paste_with_shift=True):
    """Paste text at cursor using ydotool."""
    # Copy to CLIPBOARD (Ctrl+Shift+V / Ctrl+V both read from CLIPBOARD)
    if not copy_to_clipboard(text, use_clipboard=True):
        return False

    # Wait for clipboard to be ready
    time.sleep(0.3)

    env = os.environ.copy()
    env["YDOTOOL_SOCKET"] = "/run/ydotool.socket"

    try:
        if paste_with_shift:
            # Ctrl+Shift+V (29=Ctrl, 42=Shift, 47=V) - correct for terminals
            subprocess.run(
                ["ydotool", "key", "29:1", "42:1", "47:1", "47:0", "42:0", "29:0"],
                env=env, check=True, timeout=5
            )
            log("Paste simulated via Ctrl+Shift+V")
        else:
            # Ctrl+V (29=Ctrl, 47=V) - correct for browsers and most GUI apps
            subprocess.run(
                ["ydotool", "key", "29:1", "47:1", "47:0", "29:0"],
                env=env, check=True, timeout=5
            )
            log("Paste simulated via Ctrl+V")

        # Longer delay for longer text
        delay = min(0.3 + len(text) * 0.002, 1.0)
        time.sleep(delay)

        if not skip_enter:
            subprocess.run(
                ["ydotool", "key", "28:1", "28:0"],
                env=env, check=True, timeout=5
            )
            log("Enter key sent")

        return True
    except Exception as e:
        log(f"Auto-paste failed: {e}", "ERROR")
        return False


def on_realtime_update(new_text):
    """
    Callback for real-time transcription - writes to buffer file.
    File is completely replaced each time (no append/diff needed).
    """
    global current_text

    if not new_text:
        return

    new_text = new_text.strip()
    if not new_text:
        return

    # Capitalize first letter
    new_text = new_text[0].upper() + new_text[1:] if len(new_text) > 1 else new_text.upper()

    current_text = new_text
    log(f"Partial: '{new_text}'")

    # Write complete current transcription to buffer file
    # This overwrites previous content - clean and simple
    try:
        CACHE_DIR.mkdir(parents=True, exist_ok=True)
        BUFFER_FILE.write_text(new_text)
    except Exception as e:
        log(f"Buffer write failed: {e}", "WARN")


def check_dependencies():
    """Verify RealtimeSTT and ydotool are available."""
    # Check ydotool for auto-paste mode
    if not Path("/run/ydotool.socket").exists():
        log("ydotool socket not found (needed for auto-paste)", "WARN")

    try:
        import RealtimeSTT
        log("RealtimeSTT imported successfully")
        return True
    except ImportError as e:
        log(f"RealtimeSTT not installed: {e}", "ERROR")
        notify("ERROR", "RealtimeSTT not installed\n\npip install --user RealtimeSTT")
        return False


def run_claude_processing(text, args):
    """Post-process transcription through Claude Code."""
    log(f"Post-processing through Claude Code (model: {args.claude_model}, style: {args.claude_style})")
    # Log raw transcription being sent to Claude
    preview = text[:100] + "..." if len(text) > 100 else text
    log(f"Raw transcription to Claude ({len(text)} chars): {preview}")
    try:
        cmd = ["wsi-claude-process", "--model", args.claude_model, "--style", args.claude_style]
        if args.debug:
            cmd.append("--debug")
        cmd.append(text)

        result = subprocess.run(cmd, capture_output=True, text=True, timeout=60)
        if result.returncode == 0 and result.stdout.strip():
            log("Claude processing successful")
            return result.stdout.strip()
        else:
            log(f"Claude processing failed (exit: {result.returncode}), using original text", "WARN")
            if result.stderr:
                log(f"Claude stderr: {result.stderr}", "WARN")
            return text
    except Exception as e:
        log(f"Claude processing error: {e}, using original text", "WARN")
        return text


def is_server_running():
    """Check if wsi-stream-server is running."""
    if not SERVER_SOCKET.exists():
        return False

    sock = None
    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.settimeout(1)
        sock.connect(str(SERVER_SOCKET))

        # Send PING command
        command = json.dumps({"command": "PING"}) + "\n"
        sock.sendall(command.encode())

        # Read response
        response = sock.recv(4096).decode().strip()
        data = json.loads(response)
        return data.get("status") == "alive"
    except Exception as e:
        log(f"Server ping failed: {e}", "DEBUG")
        return False
    finally:
        if sock:
            try:
                sock.close()
            except Exception:
                pass


def start_server(model_size="base", language="en"):
    """Start the persistent server if not already running."""
    if is_server_running():
        log("Server already running")
        return True

    log(f"Starting persistent server (model={model_size}, language={language})...")

    # Check if server script exists
    if not SERVER_SCRIPT.exists():
        log(f"Server script not found: {SERVER_SCRIPT}", "ERROR")
        return False

    # Build server command
    cmd = [str(SERVER_SCRIPT), "--model", model_size, "--language", language]
    if debug_mode:
        cmd.append("--debug")

    try:
        # Start server in background
        subprocess.Popen(
            cmd,
            stdout=subprocess.DEVNULL if not debug_mode else None,
            stderr=subprocess.DEVNULL if not debug_mode else None,
            start_new_session=True  # Detach from parent
        )

        # Wait for server to be ready (up to 45 seconds for model loading)
        # Model loading can take 20-30 seconds on first start
        log("Waiting for server to load model (this may take 20-30 seconds)...")
        for i in range(90):  # 90 * 0.5s = 45 seconds max
            time.sleep(0.5)
            if is_server_running():
                log(f"Server started successfully (took {(i+1)*0.5:.1f}s)")
                return True
            # Log progress every 5 seconds so user knows it's working
            if (i + 1) % 10 == 0:
                log(f"Still waiting for server... ({(i+1)*0.5:.0f}s elapsed)")

        log("Server failed to start (timeout after 45s)", "ERROR")
        return False

    except Exception as e:
        log(f"Failed to start server: {e}", "ERROR")
        return False


def send_server_command(command, params=None):
    """Send command to server and return response."""
    if params is None:
        params = {}

    try:
        sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect(str(SERVER_SOCKET))

        # Send command
        message = json.dumps({"command": command, "params": params}) + "\n"
        sock.sendall(message.encode())

        # Read response
        response = sock.recv(4096).decode().strip()
        sock.close()

        return json.loads(response)

    except Exception as e:
        log(f"Server command failed: {e}", "ERROR")
        return {"status": "error", "message": str(e)}


def run_server_mode(args):
    """Run in server mode - use persistent server for instant startup."""
    global debug_mode, no_notify

    debug_mode = args.debug
    no_notify = args.no_notify

    if debug_mode:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        LOG_FILE.write_text("")  # Fresh log each session

    log("=== Server mode requested ===")

    # Track whether recording is active (for cleanup)
    recording_active = False
    cleanup_done = False

    def ensure_stop_sent():
        """Ensure STOP command is sent to server - called on exit or signal."""
        nonlocal cleanup_done
        if cleanup_done:
            return
        cleanup_done = True

        if recording_active:
            log("Cleanup: Sending STOP to server")
            try:
                send_server_command("STOP")
                log("Cleanup: STOP sent successfully")
            except Exception as e:
                log(f"Cleanup: Failed to send STOP: {e}", "ERROR")

        # Clean up PID file
        if PID_FILE.exists():
            try:
                PID_FILE.unlink()
            except Exception:
                pass

        # Send IDLE signal to extension
        try:
            emit_dbus_signal("StateChanged", "IDLE")
        except Exception:
            pass

    # Register cleanup function to run on ANY exit (normal or abnormal)
    atexit.register(ensure_stop_sent)

    # Determine model and language
    model_size = os.environ.get("WHISPER_MODEL", "base")
    language = args.language or os.environ.get("WHISPER_LANGUAGE", "en") or "en"

    # Start server if not running
    if not is_server_running():
        notify("PREPARING", "Starting server...")
        if not start_server(model_size, language):
            notify("ERROR", "Failed to start server")
            return 1

    log("Server ready - instant recording startup!")

    # Write PID file so extension can stop us
    PID_FILE.write_text(str(os.getpid()))

    # Clear buffer file
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    BUFFER_FILE.write_text("")

    # Start recording via server
    notify("RECORDING", "Recording... (server mode)")

    response = send_server_command("START")

    if response.get("status") != "recording":
        log(f"Server START failed: {response}", "ERROR")
        notify("ERROR", "Failed to start recording")
        if PID_FILE.exists():
            PID_FILE.unlink()
        return 1

    log("Recording active (server mode)")
    recording_active = True  # Mark as active for cleanup

    # Wait for user to press Insert again (or timeout)
    stop_requested = False

    def handle_signal(signum, frame):
        nonlocal stop_requested, recording_active
        log(f"Signal {signum} received, requesting stop")
        stop_requested = True
        # Mark as inactive so atexit doesn't try to send STOP again
        recording_active = False

    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    # Wait for stop signal (extension will kill this process)
    # Use short sleep intervals so signal can interrupt quickly
    timeout = args.timeout or 120
    start_time = time.monotonic()
    try:
        while (time.monotonic() - start_time) < timeout and not stop_requested:
            time.sleep(0.1)  # Check every 100ms
        if (time.monotonic() - start_time) >= timeout:
            log("Timeout reached, stopping recording")
        else:
            log("Stop signal received, stopping recording")
    except KeyboardInterrupt:
        log("Interrupted, stopping recording")
        # Let the signal handler or normal flow handle it
        # Don't exit here - continue to normal STOP flow

    # INSTANT VISUAL FEEDBACK: Change to spinner IMMEDIATELY
    # This happens BEFORE server cleanup, so user sees instant response to Insert key
    emit_dbus_signal("StateChanged", "TRANSCRIBING")
    log("Changed to spinner (instant feedback - processing)")

    # Stop recording
    response = send_server_command("STOP")

    # Mark as inactive immediately after STOP sent
    # This prevents atexit handler from trying to send STOP again
    recording_active = False

    if PID_FILE.exists():
        PID_FILE.unlink()

    if response.get("status") != "stopped":
        log(f"Server STOP failed: {response}", "ERROR")
        notify("ERROR", "Failed to stop recording")
        return 1

    # Get transcription
    text = response.get("transcription", "").strip()

    if not text:
        log("No speech detected", "WARN")
        notify("ERROR", "No speech detected")
        if BUFFER_FILE.exists():
            BUFFER_FILE.unlink()
        return 1

    # Capitalize first letter
    text = text[0].upper() + text[1:] if len(text) > 1 else text.upper()

    # Post-process through Claude Code if requested
    if args.claude_process:
        text = run_claude_processing(text, args)

    # Wrap with marker if requested
    if args.wrap_marker and not args.claude_process:
        text = f'speech-to-text:"{text}"'

    log(f"Final text ({len(text)} chars): {text}")

    # Save to last-transcription file
    TRANSCRIPTION_FILE.write_text(text)

    # Cleanup buffer file
    if BUFFER_FILE.exists():
        BUFFER_FILE.unlink()

    # Output
    if args.auto_paste:
        log("Auto-pasting")
        time.sleep(0.2)
        success = auto_paste(text, skip_enter=args.no_auto_enter, paste_with_shift=args.paste_with_shift)
        if success:
            preview = text[:60] + "..." if len(text) > 60 else text
            notify("SUCCESS", preview)
        else:
            notify("ERROR", "Auto-paste failed")
            return 1
    else:
        log("Copying to clipboard")
        if copy_to_clipboard(text, use_clipboard=args.clipboard):
            preview = text[:60] + "..." if len(text) > 60 else text
            paste_hint = "Ctrl+V" if args.clipboard else "Middle-click"
            notify("SUCCESS", f"{preview}\n\n{paste_hint} to paste")
        else:
            notify("ERROR", "Clipboard copy failed")
            return 1

    # Send IDLE to clear the spinner and return to normal state
    time.sleep(1)
    emit_dbus_signal("StateChanged", "IDLE")

    log("Server mode recording complete!")
    return 0


def run_streaming(args):
    """Main streaming transcription."""
    global debug_mode, no_notify, stop_requested, recorder, current_text
    debug_mode = args.debug
    no_notify = args.no_notify
    stop_requested = False
    current_text = ""

    if debug_mode:
        LOG_DIR.mkdir(parents=True, exist_ok=True)
        LOG_FILE.write_text("")  # Fresh log each session

    log(f"Starting streaming transcription (pre-buffer: {args.pre_buffer})...")

    # Route to appropriate implementation
    if args.pre_buffer:
        return run_prebuffered_streaming(args)
    else:
        return run_standard_streaming(args)


def run_standard_streaming(args):
    """Standard streaming mode - RealtimeSTT manages audio."""
    global debug_mode, no_notify, stop_requested, recorder, current_text

    if not check_dependencies():
        return 1

    from RealtimeSTT import AudioToTextRecorder
    import threading

    # Write PID file
    PID_FILE.write_text(str(os.getpid()))
    log(f"PID file written: {PID_FILE}")

    # Clear buffer file
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    BUFFER_FILE.write_text("")

    # Use "base" model for streaming by default (faster loading)
    # "base" (74M params, ~142MB) loads ~3x faster than "small" (244M params, ~466MB)
    # with minimal accuracy trade-off. Override with WHISPER_MODEL env var if needed.
    model_size = os.environ.get("WHISPER_MODEL", "base")
    # Language from arg, then env, then default to English
    language = args.language or os.environ.get("WHISPER_LANGUAGE", "en") or None
    log(f"Using model: {model_size}, language: {language or 'auto-detect'}")

    final_text = ""
    recorder_error = None
    recording_done = threading.Event()

    def recording_thread():
        """Run recorder in thread so main thread can handle signals."""
        nonlocal final_text, recorder_error
        try:
            # Blocks until stop() or shutdown() is called
            final_text = recorder.text()
            log(f"Final from recorder: {final_text}")
        except Exception as e:
            recorder_error = e
            log(f"Recorder thread error: {e}", "ERROR")
        finally:
            recording_done.set()

    # Signal handler - stop recording on SIGINT/SIGTERM
    def handle_signal(signum, frame):
        global stop_requested, recorder
        log(f"Signal {signum} received, stopping...")
        stop_requested = True
        if recorder:
            try:
                recorder.stop()
                log("Called recorder.stop()")
            except Exception as e:
                log(f"stop() failed: {e}", "WARN")
        # DON'T set recording_done here - let the recording thread set it
        # after recorder.text() returns with the final transcription.
        # Setting it here causes a race where we proceed before the last
        # audio chunk is transcribed, losing the final word(s).

    signal.signal(signal.SIGINT, handle_signal)
    signal.signal(signal.SIGTERM, handle_signal)

    try:
        # Signal PREPARING state (orange icon) while initializing
        notify("PREPARING", "Loading model...")

        recorder_config = {
            "model": model_size,
            "language": language,
            "silero_sensitivity": 0.4,
            # Very long silence duration - manual stop via signal
            "post_speech_silence_duration": 300.0,
            "min_length_of_recording": 0.3,
            "min_gap_between_recordings": 0.1,
            # Real-time transcription streams to buffer file
            "enable_realtime_transcription": True,
            "realtime_processing_pause": 0.2,
            "on_realtime_transcription_update": on_realtime_update,
            "spinner": False,
        }

        # Request GPU - let AudioToTextRecorder handle fallback internally
        recorder_config["device"] = "cuda"
        recorder_config["compute_type"] = "float16"
        log("Requesting GPU (CUDA)")

        recorder = AudioToTextRecorder(**recorder_config)
        log("Recorder initialized, waiting for audio pipeline...")

        # Notify user that model is loaded, now initializing audio
        notify("PREPARING", "Initializing audio...")

        # Brief delay to let microphone and audio pipeline fully initialize
        # RealtimeSTT needs time to open audio device and start processing
        time.sleep(0.5)
        log("Audio pipeline ready, starting recording")

        # Now signal RECORDING state (red icon + countdown)
        notify("RECORDING", "Recording... (transcribing live)")

        # Start recording in thread
        rec_thread = threading.Thread(target=recording_thread, daemon=True)
        rec_thread.start()

        # Wait for either completion or timeout (main thread handles signals)
        timeout = args.timeout or 30
        recording_done.wait(timeout=timeout)

        # If stop was requested but recording thread hasn't finished yet,
        # give it a few more seconds for the final transcription
        if stop_requested and not recording_done.is_set():
            log("Waiting for final transcription after stop...")
            recording_done.wait(timeout=5)

        if not recording_done.is_set():
            log(f"Timeout after {timeout}s, stopping gracefully...")
            stop_requested = True
            if recorder:
                try:
                    # First try graceful stop to get final transcription
                    recorder.stop()
                    log("Called recorder.stop() on timeout")
                except Exception as e:
                    log(f"Warning: recorder.stop() failed: {e}")

                # Wait for final transcription
                recording_done.wait(timeout=3)

                # Only abort if stop didn't work
                if not recording_done.is_set():
                    log("Graceful stop failed, aborting...")
                    try:
                        recorder.abort()
                    except Exception:
                        pass
                    try:
                        recorder.shutdown()
                    except Exception:
                        pass
                    # Give thread a moment to finish
                    recording_done.wait(timeout=2)

        # Only raise error if it wasn't a user-requested stop
        if recorder_error and not stop_requested:
            raise recorder_error
        elif recorder_error:
            log(f"Recorder error during stop (expected): {recorder_error}")

    except Exception as e:
        log(f"Recording error: {e}", "ERROR")
        notify("ERROR", f"Recording failed: {e}")
        return 1
    finally:
        if PID_FILE.exists():
            PID_FILE.unlink()
        # Ensure recorder is fully cleaned up - RealtimeSTT can leak audio resources
        if recorder:
            try:
                recorder.abort()
            except Exception:
                pass
            try:
                recorder.stop()
            except Exception:
                pass
            try:
                recorder.shutdown()
            except Exception:
                pass
            # Force garbage collection to release audio resources
            del recorder
            recorder = None
            import gc
            gc.collect()
            log("Recorder cleanup complete")
        # Always send IDLE signal on cleanup so extension resets
        emit_dbus_signal("StateChanged", "IDLE")
        log("Sent IDLE signal")

    # Use final text from recorder, fall back to buffer if empty
    if final_text and final_text.strip():
        text = final_text.strip()
    elif current_text:
        text = current_text
        log("Using buffered text (recorder returned empty)")
    else:
        # Try reading from buffer file as last resort
        try:
            text = BUFFER_FILE.read_text().strip()
            log("Using text from buffer file")
        except Exception:
            text = ""

    if not text:
        log("No speech detected", "WARN")
        notify("ERROR", "No speech detected")
        # Cleanup buffer
        if BUFFER_FILE.exists():
            BUFFER_FILE.unlink()
        return 1

    # Capitalize first letter
    text = text[0].upper() + text[1:] if len(text) > 1 else text.upper()

    # Post-process through Claude Code if requested
    if args.claude_process:
        text = run_claude_processing(text, args)

    # Wrap with marker if requested
    # BUT: Don't wrap Claude-processed text - it's already clean and formatted
    if args.wrap_marker and not args.claude_process:
        text = f'speech-to-text:"{text}"'
        log(f"Wrapped: {text}")
    elif args.wrap_marker and args.claude_process:
        log("Skipping marker wrap - Claude processed text is already clean")

    log(f"Final text ({len(text)} chars): {text}")

    # Save to last-transcription file
    TRANSCRIPTION_FILE.write_text(text)

    # Cleanup buffer file
    if BUFFER_FILE.exists():
        BUFFER_FILE.unlink()

    # Output - instant because transcription already done!
    if args.auto_paste:
        log("Auto-pasting (instant - transcription was real-time)")
        # Small delay to ensure any focus changes from recorder shutdown settle
        time.sleep(0.2)
        success = auto_paste(text, skip_enter=args.no_auto_enter, paste_with_shift=args.paste_with_shift)
        if success:
            preview = text[:60] + "..." if len(text) > 60 else text
            notify("SUCCESS", preview)
        else:
            notify("ERROR", "Auto-paste failed")
            return 1
    else:
        log("Copying to clipboard (instant - transcription was real-time)")
        if copy_to_clipboard(text, use_clipboard=args.clipboard):
            preview = text[:60] + "..." if len(text) > 60 else text
            paste_hint = "Ctrl+V" if args.clipboard else "Middle-click"
            notify("SUCCESS", f"{preview}\n\n{paste_hint} to paste")
        else:
            notify("ERROR", "Clipboard copy failed")
            return 1

    time.sleep(1)
    emit_dbus_signal("StateChanged", "IDLE")

    log("Streaming complete - paste was instant!")
    return 0


def run_prebuffered_streaming(args):
    """
    Pre-buffered streaming mode - starts audio capture immediately while model loads.
    Provides instant startup by recording audio to buffer during model initialization.
    """
    global debug_mode, no_notify, stop_requested, recorder, current_text

    if not check_dependencies():
        return 1

    from RealtimeSTT import AudioToTextRecorder
    import threading
    import struct
    import array

    # Write PID file (use main process PID)
    PID_FILE.write_text(str(os.getpid()))
    log(f"PID file written: {PID_FILE}")

    # Clear buffer file
    CACHE_DIR.mkdir(parents=True, exist_ok=True)
    BUFFER_FILE.write_text("")

    model_size = os.environ.get("WHISPER_MODEL", "base")
    language = args.language or os.environ.get("WHISPER_LANGUAGE", "en") or None
    log(f"Using model: {model_size}, language: {language or 'auto-detect'}")

    # Start audio recording IMMEDIATELY (before model loads!)
    notify("PREPARING", "Starting recorder...")
    log("Starting pw-record immediately (pre-buffering enabled)")

    try:
        # Start pw-record to stdout pipe: 16000 Hz, mono, S16_LE format
        # This is the format RealtimeSTT expects for feed_audio()
        pw_record_cmd = [
            "pw-record",
            "--rate", "16000",
            "--channels", "1",
            "--format", "s16",
            "-"  # Output to stdout
        ]

        audio_process = subprocess.Popen(
            pw_record_cmd,
            stdout=subprocess.PIPE,
            stderr=subprocess.DEVNULL if not debug_mode else None
        )
        log(f"pw-record started with PID {audio_process.pid}")

        # Audio buffer for chunks captured while model loads
        audio_buffer = []
        chunk_size = 1024 * 2  # 1024 samples * 2 bytes per sample (S16_LE)
        model_ready = threading.Event()
        model_error = None

        def load_model_thread():
            """Load Whisper model in background thread."""
            global recorder
            nonlocal model_error
            try:
                notify("PREPARING", "Loading model...")
                log("Loading model in background thread...")

                recorder_config = {
                    "model": model_size,
                    "language": language,
                    "use_microphone": False,  # We'll feed audio manually
                    "silero_sensitivity": 0.4,
                    "enable_realtime_transcription": True,
                    "realtime_processing_pause": 0.2,
                    "on_realtime_transcription_update": on_realtime_update,
                    "spinner": False,
                }

                # Request GPU - let AudioToTextRecorder handle fallback internally
                recorder_config["device"] = "cuda"
                recorder_config["compute_type"] = "float16"
                log("Requesting GPU (CUDA)")

                recorder = AudioToTextRecorder(**recorder_config)
                log("Model loaded successfully!")
                model_ready.set()
            except Exception as e:
                model_error = e
                log(f"Model loading error: {e}", "ERROR")
                model_ready.set()

        # Start model loading in background
        model_thread = threading.Thread(target=load_model_thread, daemon=True)
        model_thread.start()

        # Buffer audio chunks while model loads
        log("Buffering audio while model loads...")
        while not model_ready.is_set():
            try:
                chunk = audio_process.stdout.read(chunk_size)
                if not chunk:
                    break
                audio_buffer.append(chunk)
                if len(audio_buffer) % 10 == 0:
                    log(f"Buffered {len(audio_buffer)} chunks ({len(audio_buffer) * chunk_size / 16000:.1f}s)")
            except Exception as e:
                log(f"Buffering error: {e}", "WARN")
                break

        # Check if model loaded successfully
        if model_error:
            raise model_error

        if not recorder:
            raise RuntimeError("Model failed to load")

        log(f"Model ready! Buffered {len(audio_buffer)} chunks ({len(audio_buffer) * chunk_size / 16000:.2f}s)")
        notify("RECORDING", "Recording... (transcribing live)")

        # Start the recorder so realtime worker processes audio (sets is_recording=True)
        recorder.start()
        log("Recorder started (realtime transcription active)")

        # Feed buffered chunks to model
        log("Feeding buffered audio to model...")
        for i, chunk in enumerate(audio_buffer):
            if stop_requested:
                break
            # Convert bytes to numpy-like array that RealtimeSTT expects
            audio_array = array.array('h', chunk)  # 'h' = signed short (int16)
            recorder.feed_audio(audio_array)
            if (i + 1) % 20 == 0:
                log(f"Fed {i + 1}/{len(audio_buffer)} buffered chunks")

        audio_buffer.clear()  # Free memory
        log("All buffered audio fed to model")

        # Continue feeding real-time audio until stop
        log("Feeding real-time audio...")
        timeout_time = time.time() + args.timeout
        while not stop_requested and time.time() < timeout_time:
            try:
                chunk = audio_process.stdout.read(chunk_size)
                if not chunk:
                    log("Audio stream ended")
                    break
                audio_array = array.array('h', chunk)
                recorder.feed_audio(audio_array)
            except Exception as e:
                log(f"Real-time feed error: {e}", "WARN")
                break

        # Stop recording
        log("Stopping audio capture...")
        stop_requested = True

        # Stop pw-record gracefully
        try:
            audio_process.terminate()
            audio_process.wait(timeout=2)
        except Exception:
            audio_process.kill()

        # Get final transcription
        # In prebuffered mode with use_microphone=False, recorder.text() would block
        # forever waiting for audio. The realtime callbacks have already captured
        # the transcription in current_text, so we use that directly.
        log("Getting final transcription...")
        notify("TRANSCRIBING", "Finalizing transcription...")

        try:
            recorder.stop()
            # Use current_text from realtime callbacks - don't call recorder.text()
            # as it blocks indefinitely with use_microphone=False
            final_text = current_text
            log(f"Final text from realtime callbacks: {final_text}")
        except Exception as e:
            log(f"Transcription error: {e}", "ERROR")
            final_text = current_text

        # Cleanup
        if PID_FILE.exists():
            PID_FILE.unlink()

        recorder.shutdown()
        recorder = None

        # Process final text (same as standard mode)
        if not final_text and current_text:
            final_text = current_text
            log("Using buffered text (recorder returned empty)")

        text = final_text.strip() if final_text else ""

        if not text:
            log("No speech detected", "WARN")
            notify("ERROR", "No speech detected")
            if BUFFER_FILE.exists():
                BUFFER_FILE.unlink()
            return 1

        # Capitalize first letter
        text = text[0].upper() + text[1:] if len(text) > 1 else text.upper()

        # Post-process through Claude Code if requested
        if args.claude_process:
            text = run_claude_processing(text, args)

        # Wrap with marker if requested
        # BUT: Don't wrap Claude-processed text - it's already clean and formatted
        if args.wrap_marker and not args.claude_process:
            text = f'speech-to-text:"{text}"'
            log(f"Wrapped: {text}")
        elif args.wrap_marker and args.claude_process:
            log("Skipping marker wrap - Claude processed text is already clean")

        log(f"Final text ({len(text)} chars): {text}")

        # Save to last-transcription file
        TRANSCRIPTION_FILE.write_text(text)

        # Cleanup buffer file
        if BUFFER_FILE.exists():
            BUFFER_FILE.unlink()

        # Output
        if args.auto_paste:
            log("Auto-pasting (instant - transcription was real-time)")
            time.sleep(0.2)
            success = auto_paste(text, skip_enter=args.no_auto_enter, paste_with_shift=args.paste_with_shift)
            if success:
                preview = text[:60] + "..." if len(text) > 60 else text
                notify("SUCCESS", preview)
            else:
                notify("ERROR", "Auto-paste failed")
                return 1
        else:
            log("Copying to clipboard (instant - transcription was real-time)")
            if copy_to_clipboard(text, use_clipboard=args.clipboard):
                preview = text[:60] + "..." if len(text) > 60 else text
                paste_hint = "Ctrl+V" if args.clipboard else "Middle-click"
                notify("SUCCESS", f"{preview}\n\n{paste_hint} to paste")
            else:
                notify("ERROR", "Clipboard copy failed")
                return 1

        time.sleep(1)
        emit_dbus_signal("StateChanged", "IDLE")

        log("Pre-buffered streaming complete!")
        return 0

    except Exception as e:
        log(f"Pre-buffer streaming error: {e}", "ERROR")
        notify("ERROR", f"Recording failed: {e}")

        # Cleanup
        if 'audio_process' in locals() and audio_process:
            try:
                audio_process.kill()
            except Exception:
                pass
        if PID_FILE.exists():
            PID_FILE.unlink()
        if recorder:
            try:
                recorder.shutdown()
            except Exception:
                pass

        emit_dbus_signal("StateChanged", "IDLE")
        return 1


def main():
    parser = argparse.ArgumentParser(
        description="Streaming speech-to-text with real-time transcription"
    )
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("-c", "--clipboard", action="store_true",
                        help="Use CLIPBOARD instead of PRIMARY selection")
    parser.add_argument("-a", "--auto-paste", action="store_true",
                        help="Auto-paste at cursor position")
    parser.add_argument("--no-auto-enter", action="store_true",
                        help="Skip Enter key after auto-paste")
    parser.add_argument("-w", "--wrap-marker", action="store_true",
                        help="Wrap text with speech-to-text:\"...\"")
    parser.add_argument("-l", "--language", type=str, default=None,
                        help="Language code for transcription (e.g., 'en')")
    parser.add_argument("--timeout", type=int, default=120,
                        help="Maximum recording time in seconds (default: 120 for streaming)")
    parser.add_argument("--no-notify", action="store_true",
                        help="Suppress desktop notifications")
    parser.add_argument("--pre-buffer", action="store_true",
                        help="Start recording immediately while model loads (faster startup)")
    parser.add_argument("--server-mode", action="store_true",
                        help="Use persistent server for instant startup (keeps model in memory)")
    parser.add_argument("--claude-process", action="store_true",
                        help="Post-process transcription through Claude Code")
    parser.add_argument("--claude-model", type=str, default="sonnet",
                        help="Claude model for processing (sonnet/opus/haiku)")
    parser.add_argument("--claude-style", type=str, default="corporate",
                        help="Claude processing style (corporate/natural)")
    parser.add_argument("--paste-with-shift", type=int, default=1,
                        help="Paste key: 1=Ctrl+Shift+V (terminals), 0=Ctrl+V (browsers/GUI apps)")

    args = parser.parse_args()

    try:
        # Route to server mode if requested
        if args.server_mode:
            return run_server_mode(args)
        else:
            return run_streaming(args)
    except Exception as e:
        # Ensure critical errors are ALWAYS logged, even without debug mode
        global debug_mode
        debug_mode = True  # Force logging for crash reports
        log(f"FATAL ERROR: {e}", "CRITICAL")
        import traceback
        log(traceback.format_exc(), "CRITICAL")
        notify("ERROR", f"Script crashed: {e}")
        return 1


if __name__ == "__main__":
    sys.exit(main())
