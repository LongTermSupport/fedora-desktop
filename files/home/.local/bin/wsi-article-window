#!/usr/bin/env python3
"""
WSI-Article-Window - Two-pane article drafting UI
==================================================
Launched by the GNOME Shell extension via 'Create Article...' in the panel menu.
Opens a GTK4 window, launches wsi-article as a subprocess, and runs a two-stage
Claude polish after each 120-second chunk (and on stop):

  Stage 1 — Structure:  raw transcript → coherent article  (Structured tab)
  Stage 2 — Humanize:   article → LLM-giveaway-free prose  (Humanized tab)
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
from gi.repository import Gtk, GLib, Gio

import os
import sys
import subprocess
import threading
import time
import argparse
from pathlib import Path

# File paths
CACHE_DIR = Path.home() / ".cache/speech-to-text"
ARTICLE_RAW_FILE = CACHE_DIR / "article-raw.txt"
ARTICLE_BUFFER_FILE = CACHE_DIR / "article-buffer.txt"
ARTICLE_PARTIAL_FILE = CACHE_DIR / "article-partial.txt"
ARTICLE_TRIGGER_FILE = CACHE_DIR / "article-chunk.trigger"
ARTICLE_SCRIPT = Path.home() / ".local/bin/wsi-article"

# Pass through offline mode env vars so wsi-article inherits them
_RECORDER_ENV = {
    **os.environ,
    "HF_TOKEN": "",
    "TRANSFORMERS_OFFLINE": "1",
    "HF_DATASETS_OFFLINE": "1",
}


class ArticleWindow(Gtk.ApplicationWindow):
    def __init__(self, app, args):
        super().__init__(application=app)
        self.args = args
        self.article_proc = None
        self.last_trigger_mtime = 0.0
        self.last_partial_mtime = 0.0
        self.last_buffer_mtime = 0.0
        self.is_polishing = False
        self.chunk_count = 0
        self.poll_timer_id = None
        self._force_kill_timer = None
        self._final_polish_done = False

        # Skip any pre-existing trigger file from a previous session
        if ARTICLE_TRIGGER_FILE.exists():
            try:
                self.last_trigger_mtime = ARTICLE_TRIGGER_FILE.stat().st_mtime
            except Exception:
                pass

        self.set_title("Article Mode — Speech to Text")
        self.set_default_size(1200, 700)

        self._build_ui()
        self._start_recorder()
        self._start_polling()
        self.connect("close-request", self._on_close)

    def _build_ui(self):
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_child(main_box)

        # ── Header bar ──────────────────────────────────────────────────────
        header = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        header.set_margin_top(8)
        header.set_margin_bottom(8)
        header.set_margin_start(12)
        header.set_margin_end(12)

        self.stop_btn = Gtk.Button(label="■ Stop Recording")
        self.stop_btn.add_css_class("destructive-action")
        self.stop_btn.connect("clicked", self._on_stop)
        header.append(self.stop_btn)

        self.status_label = Gtk.Label(label="Starting…")
        self.status_label.set_hexpand(True)
        self.status_label.set_halign(Gtk.Align.CENTER)
        header.append(self.status_label)

        main_box.append(header)
        main_box.append(Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL))

        # ── Paned content ────────────────────────────────────────────────────
        paned = Gtk.Paned(orientation=Gtk.Orientation.HORIZONTAL)
        paned.set_vexpand(True)
        paned.set_position(480)
        paned.set_wide_handle(True)
        main_box.append(paned)

        # Left pane: Raw transcript
        left_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        left_box.set_margin_top(10)
        left_box.set_margin_start(10)
        left_box.set_margin_end(6)
        left_box.set_margin_bottom(10)

        raw_label = Gtk.Label(label="Raw Transcript")
        raw_label.set_halign(Gtk.Align.START)
        raw_label.add_css_class("heading")
        left_box.append(raw_label)

        raw_scroll = Gtk.ScrolledWindow()
        raw_scroll.set_vexpand(True)
        raw_scroll.set_hexpand(True)
        raw_scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

        self.raw_buffer = Gtk.TextBuffer()
        self.raw_view = Gtk.TextView(buffer=self.raw_buffer)
        self.raw_view.set_editable(False)
        self.raw_view.set_cursor_visible(False)
        self.raw_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        self.raw_view.set_left_margin(8)
        self.raw_view.set_right_margin(8)
        self.raw_view.set_top_margin(8)
        self.raw_view.set_bottom_margin(8)
        raw_scroll.set_child(self.raw_view)
        left_box.append(raw_scroll)
        paned.set_start_child(left_box)

        # Right pane: Tabbed polished views + tweak controls
        right_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        right_box.set_margin_top(10)
        right_box.set_margin_start(6)
        right_box.set_margin_end(10)
        right_box.set_margin_bottom(10)

        # Notebook with Structured and Humanized tabs
        self.notebook = Gtk.Notebook()
        self.notebook.set_vexpand(True)

        # Tab 1: Structured (stage 1 — article polish)
        structured_scroll = Gtk.ScrolledWindow()
        structured_scroll.set_vexpand(True)
        structured_scroll.set_hexpand(True)
        structured_scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.structured_buffer = Gtk.TextBuffer()
        self.structured_view = Gtk.TextView(buffer=self.structured_buffer)
        self.structured_view.set_editable(False)
        self.structured_view.set_cursor_visible(False)
        self.structured_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        self.structured_view.set_left_margin(8)
        self.structured_view.set_right_margin(8)
        self.structured_view.set_top_margin(8)
        self.structured_view.set_bottom_margin(8)
        structured_scroll.set_child(self.structured_view)
        self.notebook.append_page(structured_scroll, Gtk.Label(label="Structured"))

        # Tab 2: Humanized (stage 2 — LLM-giveaway removal)
        humanized_scroll = Gtk.ScrolledWindow()
        humanized_scroll.set_vexpand(True)
        humanized_scroll.set_hexpand(True)
        humanized_scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)
        self.polished_buffer = Gtk.TextBuffer()
        self.polished_view = Gtk.TextView(buffer=self.polished_buffer)
        self.polished_view.set_editable(False)
        self.polished_view.set_cursor_visible(False)
        self.polished_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        self.polished_view.set_left_margin(8)
        self.polished_view.set_right_margin(8)
        self.polished_view.set_top_margin(8)
        self.polished_view.set_bottom_margin(8)
        humanized_scroll.set_child(self.polished_view)
        self.notebook.append_page(humanized_scroll, Gtk.Label(label="Humanized"))

        right_box.append(self.notebook)

        # Tweak controls
        right_box.append(Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL))

        tweak_label = Gtk.Label(label="Prompt tweak (optional):")
        tweak_label.set_halign(Gtk.Align.START)
        tweak_label.set_margin_top(4)
        right_box.append(tweak_label)

        self.tweak_entry = Gtk.Entry()
        self.tweak_entry.set_placeholder_text(
            "e.g. use bullet points, add a summary, make it more formal…"
        )
        right_box.append(self.tweak_entry)

        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        btn_box.set_margin_top(4)

        self.repolish_btn = Gtk.Button(label="Re-polish")
        self.repolish_btn.set_hexpand(True)
        self.repolish_btn.connect("clicked", self._on_repolish)
        btn_box.append(self.repolish_btn)

        copy_btn = Gtk.Button(label="Copy Article")
        copy_btn.set_hexpand(True)
        copy_btn.connect("clicked", self._on_copy)
        btn_box.append(copy_btn)

        right_box.append(btn_box)
        paned.set_end_child(right_box)

    def _start_recorder(self):
        cmd = [str(ARTICLE_SCRIPT)]
        if self.args.debug:
            cmd.append("--debug")
        if self.args.language:
            cmd.extend(["--language", self.args.language])
        if self.args.no_notify:
            cmd.append("--no-notify")
        try:
            self.article_proc = subprocess.Popen(cmd, env=_RECORDER_ENV)
            self._set_status("Loading model… (first start may take a few seconds)")
        except Exception as e:
            self._set_status(f"Failed to start recorder: {e}")
            self.stop_btn.set_sensitive(False)

    def _start_polling(self):
        self.poll_timer_id = GLib.timeout_add(500, self._poll_files)

    def _poll_files(self):
        # ── Check if wsi-article has exited ─────────────────────────────────
        if self.article_proc is not None and self.article_proc.poll() is not None:
            self.article_proc = None
            self.stop_btn.set_sensitive(False)
            self.stop_btn.set_label("■ Stopped")
            # Cancel force-kill timer if it was pending
            if self._force_kill_timer:
                GLib.Source.remove(self._force_kill_timer)
                self._force_kill_timer = None
            # Trigger final polish from whatever has been accumulated
            if not self._final_polish_done:
                self._final_polish_done = True
                self._on_process_stopped()
            return True

        # ── Trigger file: new 120s chunk flushed ────────────────────────────
        if ARTICLE_TRIGGER_FILE.exists():
            try:
                mtime = ARTICLE_TRIGGER_FILE.stat().st_mtime
                if mtime > self.last_trigger_mtime:
                    self.last_trigger_mtime = mtime
                    self.chunk_count += 1
                    self._on_new_chunk()
            except Exception:
                pass

        # ── Buffer file: within-chunk accumulated phrases ────────────────────
        if ARTICLE_BUFFER_FILE.exists():
            try:
                mtime = ARTICLE_BUFFER_FILE.stat().st_mtime
                if mtime > self.last_buffer_mtime:
                    self.last_buffer_mtime = mtime
                    self._update_display()
            except Exception:
                pass

        # ── Partial file: real-time phrase fragment ──────────────────────────
        if ARTICLE_PARTIAL_FILE.exists():
            try:
                mtime = ARTICLE_PARTIAL_FILE.stat().st_mtime
                if mtime > self.last_partial_mtime:
                    self.last_partial_mtime = mtime
                    self._update_display()
            except Exception:
                pass

        return True  # GLib.SOURCE_CONTINUE

    def _read_all_raw(self):
        """Return the combined raw text: completed chunks + current buffer."""
        raw = ""
        buf = ""
        try:
            if ARTICLE_RAW_FILE.exists():
                raw = ARTICLE_RAW_FILE.read_text()
        except Exception:
            pass
        try:
            if ARTICLE_BUFFER_FILE.exists():
                buf = ARTICLE_BUFFER_FILE.read_text()
        except Exception:
            pass
        combined = raw
        if buf.strip():
            if combined and not combined.endswith("\n"):
                combined += "\n"
            combined += buf
        return combined

    def _update_display(self):
        """Refresh left pane: completed raw + buffer + [current partial]."""
        combined = self._read_all_raw()
        partial = ""
        try:
            if ARTICLE_PARTIAL_FILE.exists():
                partial = ARTICLE_PARTIAL_FILE.read_text().strip()
        except Exception:
            pass
        display = combined
        if partial:
            if display and not display.endswith("\n"):
                display += "\n"
            display += f"[{partial}]"
        self._set_raw_text(display)

    def _on_new_chunk(self):
        """Called when a 120-second chunk is flushed."""
        self._update_display()
        self._set_status(f"Chunk {self.chunk_count} complete — polishing…")
        if not self.is_polishing:
            self._run_polish(self._read_all_raw())

    def _on_process_stopped(self):
        """Called when wsi-article exits. Resets panel indicator and polishes."""
        # Emit IDLE so the extension panel resets even if wsi-article was
        # force-killed and its atexit handler never ran.
        try:
            subprocess.run([
                "gdbus", "emit", "--session",
                "--object-path", "/org/fedoradesktop/SpeechToText",
                "--signal", "org.fedoradesktop.SpeechToText.StateChanged",
                "IDLE",
            ], capture_output=True, timeout=1)
        except Exception:
            pass
        combined = self._read_all_raw()
        if combined.strip():
            self._set_raw_text(combined)
            self._set_status("Recording stopped — polishing final article…")
            self._run_polish(combined)
        else:
            self._set_status("Recording stopped — no text captured")

    def _on_repolish(self, _btn):
        if not self.is_polishing:
            self._set_status("Re-polishing…")
            self._run_polish(self._read_all_raw())

    def _run_polish(self, raw_text):
        if self.is_polishing or not raw_text.strip():
            return
        self.is_polishing = True
        self.repolish_btn.set_sensitive(False)
        tweak = self.tweak_entry.get_text().strip()

        def polish_thread():
            # ── Stage 1: structure the transcript into an article ────────────
            cmd1 = [
                "wsi-claude-process",
                "--style", "article",
                "--model", self.args.model,
            ]
            if tweak:
                cmd1.extend(["--tweak", tweak])
            if self.args.debug:
                cmd1.append("--debug")
            cmd1.append(raw_text)
            try:
                result1 = subprocess.run(
                    cmd1, capture_output=True, text=True, timeout=120
                )
                stage1 = result1.stdout.strip() if result1.returncode == 0 else ""
            except Exception:
                stage1 = ""

            if not stage1:
                GLib.idle_add(self._on_polish_done, "")
                return

            # Show stage 1 result immediately; signal stage 2 is starting
            GLib.idle_add(self._on_stage1_done, stage1)

            # ── Stage 2: humanize (remove LLM giveaways) ────────────────────
            cmd2 = [
                "wsi-claude-process",
                "--style", "humanize",
                "--model", self.args.model,
            ]
            if self.args.debug:
                cmd2.append("--debug")
            cmd2.append(stage1)
            try:
                result2 = subprocess.run(
                    cmd2, capture_output=True, text=True, timeout=120
                )
                stage2 = result2.stdout.strip() if result2.returncode == 0 else ""
            except Exception:
                stage2 = ""

            # Fall back to stage 1 if humanization fails
            GLib.idle_add(self._on_polish_done, stage2 or stage1)

        threading.Thread(target=polish_thread, daemon=True).start()

    def _on_stage1_done(self, text):
        """Stage 1 complete: show structured result and signal stage 2 running."""
        self._set_structured_text(text)
        self.notebook.set_current_page(0)
        self._set_status("Structured ✓ — humanizing… (stage 2/2)")
        return False

    def _on_polish_done(self, polished_text):
        self.is_polishing = False
        self.repolish_btn.set_sensitive(True)
        if polished_text:
            self._set_polished_text(polished_text)
            self.notebook.set_current_page(1)
            n = self.chunk_count
            self._set_status(
                f"Polished ✓  ({n} chunk{'s' if n != 1 else ''} recorded)"
            )
        else:
            self._set_status("Polishing failed — is Claude (claude CLI) available?")
        return False

    def _on_stop(self, _btn):
        """Terminate wsi-article; force-kill after 3 seconds if needed."""
        proc = self.article_proc
        if proc and proc.poll() is None:
            proc.terminate()
            self._set_status("Stopping…")
            # Schedule a force-kill in case terminate doesn't unblock the recorder
            self._force_kill_timer = GLib.timeout_add(3000, self._force_kill)

    def _force_kill(self):
        """Force-kill wsi-article if it hasn't exited after terminate()."""
        self._force_kill_timer = None
        proc = self.article_proc
        if proc and proc.poll() is None:
            proc.kill()
        return False  # GLib.SOURCE_REMOVE

    def _on_copy(self, _btn):
        """Copy from whichever tab is currently active."""
        active = self.notebook.get_current_page()
        if active == 0:
            buf = self.structured_buffer
            src = "structured"
        else:
            buf = self.polished_buffer
            src = "humanized"
        text = buf.get_text(buf.get_start_iter(), buf.get_end_iter(), False).strip()
        if not text:
            # Fall back to raw if the active tab is empty
            text = self.raw_buffer.get_text(
                self.raw_buffer.get_start_iter(),
                self.raw_buffer.get_end_iter(), False
            ).strip()
            src = "raw"
        if not text:
            self._set_status("Nothing to copy yet")
            return
        try:
            proc = subprocess.Popen(["wl-copy"], stdin=subprocess.PIPE)
            proc.stdin.write(text.encode())
            proc.stdin.close()
            self._set_status(f"Copied {src} article to clipboard ✓")
        except Exception as e:
            self._set_status(f"Copy failed: {e}")

    def _on_close(self, _window):
        if self.poll_timer_id:
            GLib.Source.remove(self.poll_timer_id)
            self.poll_timer_id = None
        if self._force_kill_timer:
            GLib.Source.remove(self._force_kill_timer)
            self._force_kill_timer = None
        proc = self.article_proc
        if proc and proc.poll() is None:
            proc.terminate()
            # Give it a moment, then kill
            GLib.timeout_add(1000, lambda: proc.kill() if proc.poll() is None else None)
        return False

    def _set_status(self, text):
        self.status_label.set_text(text)

    def _set_raw_text(self, text):
        self.raw_buffer.set_text(text)
        GLib.idle_add(self._scroll_raw_to_bottom)

    def _scroll_raw_to_bottom(self):
        end = self.raw_buffer.get_end_iter()
        self.raw_view.scroll_to_iter(end, 0.0, False, 0.0, 1.0)
        return False

    def _set_structured_text(self, text):
        self.structured_buffer.set_text(text)
        GLib.idle_add(self._scroll_structured_to_top)

    def _scroll_structured_to_top(self):
        start = self.structured_buffer.get_start_iter()
        self.structured_view.scroll_to_iter(start, 0.0, False, 0.0, 0.0)
        return False

    def _set_polished_text(self, text):
        self.polished_buffer.set_text(text)
        GLib.idle_add(self._scroll_polished_to_top)

    def _scroll_polished_to_top(self):
        start = self.polished_buffer.get_start_iter()
        self.polished_view.scroll_to_iter(start, 0.0, False, 0.0, 0.0)
        return False


def main():
    parser = argparse.ArgumentParser(description="Article mode two-pane UI")
    parser.add_argument("-d", "--debug", action="store_true")
    parser.add_argument("-l", "--language", type=str, default=None)
    parser.add_argument("--no-notify", action="store_true")
    parser.add_argument("--model", type=str, default="sonnet",
                        choices=["sonnet", "opus", "haiku"])
    args = parser.parse_args()

    app = Gtk.Application(
        application_id="org.fedoradesktop.ArticleMode",
        flags=Gio.ApplicationFlags.FLAGS_NONE
    )

    def on_activate(application):
        win = ArticleWindow(application, args)
        win.present()

    app.connect("activate", on_activate)
    return app.run([sys.argv[0]])


if __name__ == "__main__":
    sys.exit(main())
