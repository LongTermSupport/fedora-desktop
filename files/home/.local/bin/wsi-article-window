#!/usr/bin/env python3
"""
WSI-Article-Window - Two-pane article drafting UI
==================================================
Launched by the GNOME Shell extension via 'Create Article...' in the panel menu.
Opens a GTK4 window, launches wsi-article as a subprocess, and re-polishes via
Claude after each 120-second chunk (and on stop).
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
from gi.repository import Gtk, GLib, Gio

import os
import sys
import subprocess
import threading
import time
import argparse
from pathlib import Path

# File paths
CACHE_DIR = Path.home() / ".cache/speech-to-text"
ARTICLE_RAW_FILE = CACHE_DIR / "article-raw.txt"
ARTICLE_BUFFER_FILE = CACHE_DIR / "article-buffer.txt"
ARTICLE_PARTIAL_FILE = CACHE_DIR / "article-partial.txt"
ARTICLE_TRIGGER_FILE = CACHE_DIR / "article-chunk.trigger"
ARTICLE_SCRIPT = Path.home() / ".local/bin/wsi-article"

# Pass through offline mode env vars so wsi-article inherits them
_RECORDER_ENV = {
    **os.environ,
    "HF_TOKEN": "",
    "TRANSFORMERS_OFFLINE": "1",
    "HF_DATASETS_OFFLINE": "1",
}


class ArticleWindow(Gtk.ApplicationWindow):
    def __init__(self, app, args):
        super().__init__(application=app)
        self.args = args
        self.article_proc = None
        self.last_trigger_mtime = 0.0
        self.last_partial_mtime = 0.0
        self.last_buffer_mtime = 0.0
        self.is_polishing = False
        self.chunk_count = 0
        self.poll_timer_id = None
        self._force_kill_timer = None
        self._final_polish_done = False

        self.set_title("Article Mode — Speech to Text")
        self.set_default_size(1100, 700)

        self._build_ui()
        self._start_recorder()
        self._start_polling()
        self.connect("close-request", self._on_close)

    def _build_ui(self):
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_child(main_box)

        # ── Header bar ──────────────────────────────────────────────────────
        header = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        header.set_margin_top(8)
        header.set_margin_bottom(8)
        header.set_margin_start(12)
        header.set_margin_end(12)

        self.stop_btn = Gtk.Button(label="■ Stop Recording")
        self.stop_btn.add_css_class("destructive-action")
        self.stop_btn.connect("clicked", self._on_stop)
        header.append(self.stop_btn)

        self.status_label = Gtk.Label(label="Starting…")
        self.status_label.set_hexpand(True)
        self.status_label.set_halign(Gtk.Align.CENTER)
        header.append(self.status_label)

        main_box.append(header)
        main_box.append(Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL))

        # ── Paned content ────────────────────────────────────────────────────
        paned = Gtk.Paned(orientation=Gtk.Orientation.HORIZONTAL)
        paned.set_vexpand(True)
        paned.set_position(480)
        paned.set_wide_handle(True)
        main_box.append(paned)

        # Left pane: Raw transcript
        left_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        left_box.set_margin_top(10)
        left_box.set_margin_start(10)
        left_box.set_margin_end(6)
        left_box.set_margin_bottom(10)

        raw_label = Gtk.Label(label="Raw Transcript")
        raw_label.set_halign(Gtk.Align.START)
        raw_label.add_css_class("heading")
        left_box.append(raw_label)

        raw_scroll = Gtk.ScrolledWindow()
        raw_scroll.set_vexpand(True)
        raw_scroll.set_hexpand(True)
        raw_scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

        self.raw_buffer = Gtk.TextBuffer()
        self.raw_view = Gtk.TextView(buffer=self.raw_buffer)
        self.raw_view.set_editable(False)
        self.raw_view.set_cursor_visible(False)
        self.raw_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        self.raw_view.set_left_margin(8)
        self.raw_view.set_right_margin(8)
        self.raw_view.set_top_margin(8)
        self.raw_view.set_bottom_margin(8)
        raw_scroll.set_child(self.raw_view)
        left_box.append(raw_scroll)
        paned.set_start_child(left_box)

        # Right pane: Polished article + tweak controls
        right_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        right_box.set_margin_top(10)
        right_box.set_margin_start(6)
        right_box.set_margin_end(10)
        right_box.set_margin_bottom(10)

        polished_label = Gtk.Label(label="Polished Article")
        polished_label.set_halign(Gtk.Align.START)
        polished_label.add_css_class("heading")
        right_box.append(polished_label)

        polished_scroll = Gtk.ScrolledWindow()
        polished_scroll.set_vexpand(True)
        polished_scroll.set_hexpand(True)
        polished_scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

        self.polished_buffer = Gtk.TextBuffer()
        self.polished_view = Gtk.TextView(buffer=self.polished_buffer)
        self.polished_view.set_editable(False)
        self.polished_view.set_cursor_visible(False)
        self.polished_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        self.polished_view.set_left_margin(8)
        self.polished_view.set_right_margin(8)
        self.polished_view.set_top_margin(8)
        self.polished_view.set_bottom_margin(8)
        polished_scroll.set_child(self.polished_view)
        right_box.append(polished_scroll)

        # Tweak controls
        right_box.append(Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL))

        tweak_label = Gtk.Label(label="Prompt tweak (optional):")
        tweak_label.set_halign(Gtk.Align.START)
        tweak_label.set_margin_top(4)
        right_box.append(tweak_label)

        self.tweak_entry = Gtk.Entry()
        self.tweak_entry.set_placeholder_text(
            "e.g. use bullet points, add a summary, make it more formal…"
        )
        right_box.append(self.tweak_entry)

        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        btn_box.set_margin_top(4)

        self.repolish_btn = Gtk.Button(label="Re-polish")
        self.repolish_btn.set_hexpand(True)
        self.repolish_btn.connect("clicked", self._on_repolish)
        btn_box.append(self.repolish_btn)

        copy_btn = Gtk.Button(label="Copy Article")
        copy_btn.set_hexpand(True)
        copy_btn.connect("clicked", self._on_copy)
        btn_box.append(copy_btn)

        right_box.append(btn_box)
        paned.set_end_child(right_box)

    def _start_recorder(self):
        cmd = [str(ARTICLE_SCRIPT)]
        if self.args.debug:
            cmd.append("--debug")
        if self.args.language:
            cmd.extend(["--language", self.args.language])
        if self.args.no_notify:
            cmd.append("--no-notify")
        try:
            self.article_proc = subprocess.Popen(cmd, env=_RECORDER_ENV)
            self._set_status("Loading model… (first start may take a few seconds)")
        except Exception as e:
            self._set_status(f"Failed to start recorder: {e}")
            self.stop_btn.set_sensitive(False)

    def _start_polling(self):
        self.poll_timer_id = GLib.timeout_add(500, self._poll_files)

    def _poll_files(self):
        # ── Check if wsi-article has exited ─────────────────────────────────
        if self.article_proc is not None and self.article_proc.poll() is not None:
            self.article_proc = None
            self.stop_btn.set_sensitive(False)
            self.stop_btn.set_label("■ Stopped")
            # Cancel force-kill timer if it was pending
            if self._force_kill_timer:
                GLib.Source.remove(self._force_kill_timer)
                self._force_kill_timer = None
            # Trigger final polish from whatever has been accumulated
            if not self._final_polish_done:
                self._final_polish_done = True
                self._on_process_stopped()
            return True

        # ── Trigger file: new 120s chunk flushed ────────────────────────────
        if ARTICLE_TRIGGER_FILE.exists():
            try:
                mtime = ARTICLE_TRIGGER_FILE.stat().st_mtime
                if mtime > self.last_trigger_mtime:
                    self.last_trigger_mtime = mtime
                    self.chunk_count += 1
                    self._on_new_chunk()
            except Exception:
                pass

        # ── Buffer file: within-chunk accumulated phrases ────────────────────
        if ARTICLE_BUFFER_FILE.exists():
            try:
                mtime = ARTICLE_BUFFER_FILE.stat().st_mtime
                if mtime > self.last_buffer_mtime:
                    self.last_buffer_mtime = mtime
                    self._update_display()
            except Exception:
                pass

        # ── Partial file: real-time phrase fragment ──────────────────────────
        if ARTICLE_PARTIAL_FILE.exists():
            try:
                mtime = ARTICLE_PARTIAL_FILE.stat().st_mtime
                if mtime > self.last_partial_mtime:
                    self.last_partial_mtime = mtime
                    self._update_display()
            except Exception:
                pass

        return True  # GLib.SOURCE_CONTINUE

    def _read_all_raw(self):
        """Return the combined raw text: completed chunks + current buffer."""
        raw = ""
        buf = ""
        try:
            if ARTICLE_RAW_FILE.exists():
                raw = ARTICLE_RAW_FILE.read_text()
        except Exception:
            pass
        try:
            if ARTICLE_BUFFER_FILE.exists():
                buf = ARTICLE_BUFFER_FILE.read_text()
        except Exception:
            pass
        combined = raw
        if buf.strip():
            if combined and not combined.endswith("\n"):
                combined += "\n"
            combined += buf
        return combined

    def _update_display(self):
        """Refresh left pane: completed raw + buffer + [current partial]."""
        combined = self._read_all_raw()
        partial = ""
        try:
            if ARTICLE_PARTIAL_FILE.exists():
                partial = ARTICLE_PARTIAL_FILE.read_text().strip()
        except Exception:
            pass
        display = combined
        if partial:
            if display and not display.endswith("\n"):
                display += "\n"
            display += f"[{partial}]"
        self._set_raw_text(display)

    def _on_new_chunk(self):
        """Called when a 120-second chunk is flushed."""
        self._update_display()
        self._set_status(f"Chunk {self.chunk_count} complete — polishing…")
        if not self.is_polishing:
            self._run_polish(self._read_all_raw())

    def _on_process_stopped(self):
        """Called when wsi-article exits. Triggers a final polish."""
        combined = self._read_all_raw()
        if combined.strip():
            self._set_raw_text(combined)
            self._set_status("Recording stopped — polishing final article…")
            self._run_polish(combined)
        else:
            self._set_status("Recording stopped — no text captured")

    def _on_repolish(self, _btn):
        if not self.is_polishing:
            self._set_status("Re-polishing…")
            self._run_polish(self._read_all_raw())

    def _run_polish(self, raw_text):
        if self.is_polishing or not raw_text.strip():
            return
        self.is_polishing = True
        self.repolish_btn.set_sensitive(False)
        tweak = self.tweak_entry.get_text().strip()

        def polish_thread():
            cmd = [
                "wsi-claude-process",
                "--style", "article",
                "--model", self.args.model,
            ]
            if tweak:
                cmd.extend(["--tweak", tweak])
            if self.args.debug:
                cmd.append("--debug")
            cmd.append(raw_text)
            try:
                result = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=120
                )
                polished = result.stdout.strip() if result.returncode == 0 else ""
            except Exception:
                polished = ""
            GLib.idle_add(self._on_polish_done, polished)

        threading.Thread(target=polish_thread, daemon=True).start()

    def _on_polish_done(self, polished_text):
        self.is_polishing = False
        self.repolish_btn.set_sensitive(True)
        if polished_text:
            self._set_polished_text(polished_text)
            n = self.chunk_count
            self._set_status(
                f"Polished ✓  ({n} chunk{'s' if n != 1 else ''} recorded)"
            )
        else:
            self._set_status("Polishing failed — is Claude (claude CLI) available?")
        return False

    def _on_stop(self, _btn):
        """Terminate wsi-article; force-kill after 3 seconds if needed."""
        proc = self.article_proc
        if proc and proc.poll() is None:
            proc.terminate()
            self._set_status("Stopping…")
            # Schedule a force-kill in case terminate doesn't unblock the recorder
            self._force_kill_timer = GLib.timeout_add(3000, self._force_kill)

    def _force_kill(self):
        """Force-kill wsi-article if it hasn't exited after terminate()."""
        self._force_kill_timer = None
        proc = self.article_proc
        if proc and proc.poll() is None:
            proc.kill()
        return False  # GLib.SOURCE_REMOVE

    def _on_copy(self, _btn):
        polished = self.polished_buffer.get_text(
            self.polished_buffer.get_start_iter(),
            self.polished_buffer.get_end_iter(), False
        ).strip()
        raw = self.raw_buffer.get_text(
            self.raw_buffer.get_start_iter(),
            self.raw_buffer.get_end_iter(), False
        ).strip()
        text = polished or raw
        if not text:
            self._set_status("Nothing to copy yet")
            return
        try:
            proc = subprocess.Popen(["wl-copy"], stdin=subprocess.PIPE)
            proc.stdin.write(text.encode())
            proc.stdin.close()
            src = "polished" if polished else "raw"
            self._set_status(f"Copied {src} article to clipboard ✓")
        except Exception as e:
            self._set_status(f"Copy failed: {e}")

    def _on_close(self, _window):
        if self.poll_timer_id:
            GLib.Source.remove(self.poll_timer_id)
            self.poll_timer_id = None
        if self._force_kill_timer:
            GLib.Source.remove(self._force_kill_timer)
            self._force_kill_timer = None
        proc = self.article_proc
        if proc and proc.poll() is None:
            proc.terminate()
            # Give it a moment, then kill
            GLib.timeout_add(1000, lambda: proc.kill() if proc.poll() is None else None)
        return False

    def _set_status(self, text):
        self.status_label.set_text(text)

    def _set_raw_text(self, text):
        self.raw_buffer.set_text(text)
        GLib.idle_add(self._scroll_raw_to_bottom)

    def _scroll_raw_to_bottom(self):
        end = self.raw_buffer.get_end_iter()
        self.raw_view.scroll_to_iter(end, 0.0, False, 0.0, 1.0)
        return False

    def _set_polished_text(self, text):
        self.polished_buffer.set_text(text)
        GLib.idle_add(self._scroll_polished_to_top)

    def _scroll_polished_to_top(self):
        start = self.polished_buffer.get_start_iter()
        self.polished_view.scroll_to_iter(start, 0.0, False, 0.0, 0.0)
        return False


def main():
    parser = argparse.ArgumentParser(description="Article mode two-pane UI")
    parser.add_argument("-d", "--debug", action="store_true")
    parser.add_argument("-l", "--language", type=str, default=None)
    parser.add_argument("--no-notify", action="store_true")
    parser.add_argument("--model", type=str, default="sonnet",
                        choices=["sonnet", "opus", "haiku"])
    args = parser.parse_args()

    app = Gtk.Application(
        application_id="org.fedoradesktop.ArticleMode",
        flags=Gio.ApplicationFlags.FLAGS_NONE
    )

    def on_activate(application):
        win = ArticleWindow(application, args)
        win.present()

    app.connect("activate", on_activate)
    return app.run([sys.argv[0]])


if __name__ == "__main__":
    sys.exit(main())
