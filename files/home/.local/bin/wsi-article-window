#!/usr/bin/env python3
"""
WSI-Article-Window - Two-pane article drafting UI
==================================================
Launched by the GNOME Shell extension (Shift+Insert).
Opens a GTK4 window with raw transcript and polished article panes,
launches wsi-article as a subprocess, and re-polishes via Claude after
each 120-second chunk.

LAYOUT:
  ┌──────────────────────────────────────────────────┐
  │  [■ Stop Recording]     Status: Recording…       │
  ├─────────────────────┬────────────────────────────┤
  │  Raw Transcript     │  Polished Article           │
  │  (auto-updates      │  (auto-polished per chunk)  │
  │  in real-time)      │                             │
  │                     ├────────────────────────────┤
  │                     │  Prompt tweak (optional):   │
  │                     │  [___________________]      │
  │                     │  [Re-polish]  [Copy]        │
  └─────────────────────┴────────────────────────────┘
"""

import gi
gi.require_version('Gtk', '4.0')
gi.require_version('Gdk', '4.0')
from gi.repository import Gtk, GLib, Gio

import os
import sys
import subprocess
import threading
import time
import argparse
from pathlib import Path

# File paths
CACHE_DIR = Path.home() / ".cache/speech-to-text"
ARTICLE_RAW_FILE = CACHE_DIR / "article-raw.txt"
ARTICLE_PARTIAL_FILE = CACHE_DIR / "article-partial.txt"
ARTICLE_TRIGGER_FILE = CACHE_DIR / "article-chunk.trigger"
ARTICLE_SCRIPT = Path.home() / ".local/bin/wsi-article"


class ArticleWindow(Gtk.ApplicationWindow):
    def __init__(self, app, args):
        super().__init__(application=app)
        self.args = args
        self.article_proc = None
        self.last_trigger_mtime = 0.0
        self.last_partial_mtime = 0.0
        self.is_polishing = False
        self.chunk_count = 0
        self.poll_timer_id = None

        self.set_title("Article Mode — Speech to Text")
        self.set_default_size(1100, 700)

        self._build_ui()
        self._start_recorder()
        self._start_polling()
        self.connect("close-request", self._on_close)

    def _build_ui(self):
        """Build the two-pane interface."""
        main_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=0)
        self.set_child(main_box)

        # ── Header bar ──────────────────────────────────────────────────────
        header = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        header.set_margin_top(8)
        header.set_margin_bottom(8)
        header.set_margin_start(12)
        header.set_margin_end(12)

        self.stop_btn = Gtk.Button(label="■ Stop Recording")
        self.stop_btn.add_css_class("destructive-action")
        self.stop_btn.connect("clicked", self._on_stop)
        header.append(self.stop_btn)

        self.status_label = Gtk.Label(label="Starting…")
        self.status_label.set_hexpand(True)
        self.status_label.set_halign(Gtk.Align.CENTER)
        header.append(self.status_label)

        main_box.append(header)

        sep = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        main_box.append(sep)

        # ── Paned content ────────────────────────────────────────────────────
        paned = Gtk.Paned(orientation=Gtk.Orientation.HORIZONTAL)
        paned.set_vexpand(True)
        paned.set_position(480)
        paned.set_wide_handle(True)
        main_box.append(paned)

        # Left pane: Raw transcript
        left_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        left_box.set_margin_top(10)
        left_box.set_margin_start(10)
        left_box.set_margin_end(6)
        left_box.set_margin_bottom(10)

        raw_label = Gtk.Label(label="Raw Transcript")
        raw_label.set_halign(Gtk.Align.START)
        raw_label.add_css_class("heading")
        left_box.append(raw_label)

        raw_scroll = Gtk.ScrolledWindow()
        raw_scroll.set_vexpand(True)
        raw_scroll.set_hexpand(True)
        raw_scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

        self.raw_buffer = Gtk.TextBuffer()
        self.raw_view = Gtk.TextView(buffer=self.raw_buffer)
        self.raw_view.set_editable(False)
        self.raw_view.set_cursor_visible(False)
        self.raw_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        self.raw_view.set_left_margin(8)
        self.raw_view.set_right_margin(8)
        self.raw_view.set_top_margin(8)
        self.raw_view.set_bottom_margin(8)
        raw_scroll.set_child(self.raw_view)
        left_box.append(raw_scroll)

        paned.set_start_child(left_box)

        # Right pane: Polished article + tweak controls
        right_box = Gtk.Box(orientation=Gtk.Orientation.VERTICAL, spacing=6)
        right_box.set_margin_top(10)
        right_box.set_margin_start(6)
        right_box.set_margin_end(10)
        right_box.set_margin_bottom(10)

        polished_label = Gtk.Label(label="Polished Article")
        polished_label.set_halign(Gtk.Align.START)
        polished_label.add_css_class("heading")
        right_box.append(polished_label)

        polished_scroll = Gtk.ScrolledWindow()
        polished_scroll.set_vexpand(True)
        polished_scroll.set_hexpand(True)
        polished_scroll.set_policy(Gtk.PolicyType.AUTOMATIC, Gtk.PolicyType.AUTOMATIC)

        self.polished_buffer = Gtk.TextBuffer()
        self.polished_view = Gtk.TextView(buffer=self.polished_buffer)
        self.polished_view.set_editable(False)
        self.polished_view.set_cursor_visible(False)
        self.polished_view.set_wrap_mode(Gtk.WrapMode.WORD_CHAR)
        self.polished_view.set_left_margin(8)
        self.polished_view.set_right_margin(8)
        self.polished_view.set_top_margin(8)
        self.polished_view.set_bottom_margin(8)
        polished_scroll.set_child(self.polished_view)
        right_box.append(polished_scroll)

        # Tweak controls
        tweak_sep = Gtk.Separator(orientation=Gtk.Orientation.HORIZONTAL)
        tweak_sep.set_margin_top(4)
        right_box.append(tweak_sep)

        tweak_label = Gtk.Label(label="Prompt tweak (optional):")
        tweak_label.set_halign(Gtk.Align.START)
        tweak_label.set_margin_top(4)
        right_box.append(tweak_label)

        self.tweak_entry = Gtk.Entry()
        self.tweak_entry.set_placeholder_text(
            "e.g. use bullet points, add a summary, make it more formal…"
        )
        right_box.append(self.tweak_entry)

        btn_box = Gtk.Box(orientation=Gtk.Orientation.HORIZONTAL, spacing=8)
        btn_box.set_margin_top(4)

        self.repolish_btn = Gtk.Button(label="Re-polish")
        self.repolish_btn.set_hexpand(True)
        self.repolish_btn.connect("clicked", self._on_repolish)
        btn_box.append(self.repolish_btn)

        copy_btn = Gtk.Button(label="Copy Article")
        copy_btn.set_hexpand(True)
        copy_btn.connect("clicked", self._on_copy)
        btn_box.append(copy_btn)

        right_box.append(btn_box)
        paned.set_end_child(right_box)

    def _start_recorder(self):
        """Launch wsi-article as a subprocess."""
        cmd = [str(ARTICLE_SCRIPT)]
        if self.args.debug:
            cmd.append("--debug")
        if self.args.language:
            cmd.extend(["--language", self.args.language])
        if self.args.no_notify:
            cmd.append("--no-notify")
        try:
            self.article_proc = subprocess.Popen(cmd)
            self._set_status("Loading model… (first start may take a few seconds)")
        except Exception as e:
            self._set_status(f"Failed to start recorder: {e}")
            self.stop_btn.set_sensitive(False)

    def _start_polling(self):
        """Start polling for file changes every 500ms."""
        self.poll_timer_id = GLib.timeout_add(500, self._poll_files)

    def _poll_files(self):
        """Poll article files for changes. Returns True to keep timer alive."""
        # Check if wsi-article has exited
        if self.article_proc is not None and self.article_proc.poll() is not None:
            self.article_proc = None
            self.stop_btn.set_sensitive(False)
            self.stop_btn.set_label("■ Stopped")
            self._set_status("Recording stopped — review and copy your article")

        # Check trigger file (a new chunk was flushed)
        if ARTICLE_TRIGGER_FILE.exists():
            try:
                mtime = ARTICLE_TRIGGER_FILE.stat().st_mtime
                if mtime > self.last_trigger_mtime:
                    self.last_trigger_mtime = mtime
                    self.chunk_count += 1
                    self._on_new_chunk()
            except Exception:
                pass

        # Check partial file (real-time updates within current chunk)
        if ARTICLE_PARTIAL_FILE.exists():
            try:
                mtime = ARTICLE_PARTIAL_FILE.stat().st_mtime
                if mtime > self.last_partial_mtime:
                    self.last_partial_mtime = mtime
                    self._update_partial()
            except Exception:
                pass

        return True  # GLib.SOURCE_CONTINUE

    def _update_partial(self):
        """Update left pane with completed chunks + current partial phrase."""
        try:
            raw = ARTICLE_RAW_FILE.read_text() if ARTICLE_RAW_FILE.exists() else ""
            partial = ARTICLE_PARTIAL_FILE.read_text() if ARTICLE_PARTIAL_FILE.exists() else ""
            display = raw
            if partial.strip():
                if display and not display.endswith("\n"):
                    display += "\n"
                display += f"[{partial.strip()}]"
            self._set_raw_text(display)
        except Exception:
            pass

    def _on_new_chunk(self):
        """Called when a new 120-second chunk has been flushed."""
        try:
            raw = ARTICLE_RAW_FILE.read_text() if ARTICLE_RAW_FILE.exists() else ""
            self._set_raw_text(raw)
        except Exception:
            pass
        self._set_status(
            f"Chunk {self.chunk_count} complete — polishing…"
        )
        if not self.is_polishing:
            self._run_polish()

    def _on_repolish(self, _btn):
        """Manual re-polish triggered by button."""
        if not self.is_polishing:
            self._set_status("Re-polishing…")
            self._run_polish()

    def _run_polish(self):
        """Run Claude polishing in a background thread."""
        if self.is_polishing:
            return
        try:
            raw = ARTICLE_RAW_FILE.read_text() if ARTICLE_RAW_FILE.exists() else ""
        except Exception:
            return
        if not raw.strip():
            return

        self.is_polishing = True
        self.repolish_btn.set_sensitive(False)
        tweak = self.tweak_entry.get_text().strip()

        def polish_thread():
            cmd = [
                "wsi-claude-process",
                "--style", "article",
                "--model", self.args.model,
            ]
            if tweak:
                cmd.extend(["--tweak", tweak])
            if self.args.debug:
                cmd.append("--debug")
            cmd.append(raw)
            try:
                result = subprocess.run(
                    cmd, capture_output=True, text=True, timeout=120
                )
                polished = result.stdout.strip() if result.returncode == 0 else ""
            except Exception:
                polished = ""
            GLib.idle_add(self._on_polish_done, polished)

        threading.Thread(target=polish_thread, daemon=True).start()

    def _on_polish_done(self, polished_text):
        """Called on the main thread when polishing completes."""
        self.is_polishing = False
        self.repolish_btn.set_sensitive(True)
        if polished_text:
            self._set_polished_text(polished_text)
            chunks = self.chunk_count
            self._set_status(
                f"Polished ✓ — {chunks} chunk{'s' if chunks != 1 else ''} recorded"
            )
        else:
            self._set_status("Polishing failed — is Claude (claude CLI) available?")
        return False  # GLib.SOURCE_REMOVE

    def _on_stop(self, _btn):
        """Terminate the wsi-article subprocess."""
        if self.article_proc and self.article_proc.poll() is None:
            self.article_proc.terminate()
            self._set_status("Stopping…")

    def _on_copy(self, _btn):
        """Copy the polished article to clipboard (falls back to raw)."""
        polished = self.polished_buffer.get_text(
            self.polished_buffer.get_start_iter(),
            self.polished_buffer.get_end_iter(),
            False
        ).strip()
        raw = self.raw_buffer.get_text(
            self.raw_buffer.get_start_iter(),
            self.raw_buffer.get_end_iter(),
            False
        ).strip()
        text = polished or raw
        if not text:
            self._set_status("Nothing to copy yet")
            return
        try:
            proc = subprocess.Popen(["wl-copy"], stdin=subprocess.PIPE)
            proc.stdin.write(text.encode())
            proc.stdin.close()
            source = "polished" if polished else "raw"
            self._set_status(f"Copied {source} article to clipboard ✓")
        except Exception as e:
            self._set_status(f"Copy failed: {e}")

    def _on_close(self, _window):
        """Stop the timer and recorder when the window is closed."""
        if self.poll_timer_id:
            GLib.Source.remove(self.poll_timer_id)
            self.poll_timer_id = None
        if self.article_proc and self.article_proc.poll() is None:
            self.article_proc.terminate()
        return False  # Allow the window to close

    def _set_status(self, text):
        self.status_label.set_text(text)

    def _set_raw_text(self, text):
        """Update raw transcript pane and scroll to bottom."""
        self.raw_buffer.set_text(text)
        GLib.idle_add(self._scroll_raw_to_bottom)

    def _scroll_raw_to_bottom(self):
        end = self.raw_buffer.get_end_iter()
        self.raw_view.scroll_to_iter(end, 0.0, False, 0.0, 1.0)
        return False

    def _set_polished_text(self, text):
        """Update polished article pane and scroll to top."""
        self.polished_buffer.set_text(text)
        GLib.idle_add(self._scroll_polished_to_top)

    def _scroll_polished_to_top(self):
        start = self.polished_buffer.get_start_iter()
        self.polished_view.scroll_to_iter(start, 0.0, False, 0.0, 0.0)
        return False


def main():
    parser = argparse.ArgumentParser(
        description="Article mode two-pane UI"
    )
    parser.add_argument("-d", "--debug", action="store_true",
                        help="Enable debug logging")
    parser.add_argument("-l", "--language", type=str, default=None,
                        help="Language code (e.g. 'en')")
    parser.add_argument("--no-notify", action="store_true",
                        help="Suppress desktop notifications")
    parser.add_argument("--model", type=str, default="sonnet",
                        choices=["sonnet", "opus", "haiku"],
                        help="Claude model for polishing")

    args = parser.parse_args()

    app = Gtk.Application(
        application_id="org.fedoradesktop.ArticleMode",
        flags=Gio.ApplicationFlags.FLAGS_NONE
    )

    def on_activate(application):
        win = ArticleWindow(application, args)
        win.present()

    app.connect("activate", on_activate)
    # Pass only the program name to GTK so it doesn't try to parse our args
    return app.run([sys.argv[0]])


if __name__ == "__main__":
    sys.exit(main())
