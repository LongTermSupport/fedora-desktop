#!/bin/bash
#
# wsi-claude-process - Post-process speech-to-text transcriptions with Claude Code
#
# Usage:
#   wsi-claude-process [OPTIONS] <transcription-text>
#
# Options:
#   -m, --model MODEL      Claude model (sonnet/opus/haiku, default: sonnet)
#   -s, --style STYLE      Processing style (corporate/natural, default: corporate)
#   -d, --debug            Enable debug logging
#
# Description:
#   Reads prompt template from ~/.config/speech-to-text/claude-prompt-{style}.txt
#   Replaces {TRANSCRIPTION} placeholder with actual transcribed text
#   Calls Claude Code CLI (ccy) in headless mode
#   Returns reformatted text or original text if processing fails
#

set -euo pipefail

# Configuration
CONFIG_DIR="${HOME}/.config/speech-to-text"
LOG_DIR="${HOME}/.local/share/speech-to-text"
LOG_FILE="${LOG_DIR}/debug.log"
DEBUG_MODE=false
CLAUDE_MODEL="sonnet"
STYLE="corporate"
TWEAK=""

# Parse arguments
TRANSCRIPTION=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        -m|--model)
            CLAUDE_MODEL="$2"
            shift 2
            ;;
        -s|--style)
            STYLE="$2"
            shift 2
            ;;
        -d|--debug)
            DEBUG_MODE=true
            shift
            ;;
        -t|--tweak)
            TWEAK="$2"
            shift 2
            ;;
        *)
            TRANSCRIPTION="$1"
            shift
            ;;
    esac
done

# Logging function
log() {
    if [[ "$DEBUG_MODE" == "true" ]]; then
        echo "[$(date +'%Y-%m-%d %H:%M:%S')] wsi-claude-process: $*" >> "$LOG_FILE"
    fi
}

# Error handling
error_exit() {
    log "ERROR: $1"
    # Return original transcription on error
    echo "$TRANSCRIPTION"
    exit 0
}

# Preflight checks
log "Starting Claude Code post-processing"
log "Model: $CLAUDE_MODEL"
log "Style: $STYLE"
log "Transcription length: ${#TRANSCRIPTION} chars"

# Check if transcription is provided
if [[ -z "$TRANSCRIPTION" ]]; then
    error_exit "No transcription text provided"
fi

# Check if claude is available
if ! command -v claude &>/dev/null; then
    error_exit "claude CLI not found in PATH"
fi

# Select prompt file based on style
PROMPT_FILE="${CONFIG_DIR}/claude-prompt-${STYLE}.txt"

# Fallback to default corporate prompt if style file doesn't exist
if [[ ! -f "$PROMPT_FILE" ]]; then
    log "Style-specific prompt not found: $PROMPT_FILE"
    PROMPT_FILE="${CONFIG_DIR}/claude-prompt.txt"
    if [[ ! -f "$PROMPT_FILE" ]]; then
        error_exit "No prompt template found"
    fi
fi

# Read prompt template
PROMPT_TEMPLATE=$(cat "$PROMPT_FILE")
log "Loaded prompt template (${#PROMPT_TEMPLATE} chars)"

# Replace {TRANSCRIPTION} placeholder
FULL_PROMPT="${PROMPT_TEMPLATE//\{TRANSCRIPTION\}/$TRANSCRIPTION}"

# Replace {TWEAK} placeholder (used by article prompt; no-op for others)
if [[ -n "$TWEAK" ]]; then
    TWEAK_LINE=$'\nAdditional instruction: '"$TWEAK"
else
    TWEAK_LINE=""
fi
FULL_PROMPT="${FULL_PROMPT//\{TWEAK\}/$TWEAK_LINE}"

log "Constructed full prompt (${#FULL_PROMPT} chars)"

# Call Claude CLI in headless mode
log "Calling claude with model=$CLAUDE_MODEL"
if ! RESULT=$(echo "$FULL_PROMPT" | claude --model "$CLAUDE_MODEL" 2>>"$LOG_FILE"); then
    log "claude failed: $RESULT"
    error_exit "Claude processing failed"
fi

# Clean up result (remove any leading/trailing whitespace)
RESULT=$(echo "$RESULT" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//')

# Verify result is not empty
if [[ -z "$RESULT" ]]; then
    error_exit "Claude Code returned empty result"
fi

log "Processing successful (result length: ${#RESULT} chars)"
echo "$RESULT"
