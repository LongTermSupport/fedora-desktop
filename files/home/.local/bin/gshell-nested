#!/usr/bin/bash
# gshell-nested - Launch nested GNOME Shell for extension testing
# Automatically calculates window size slightly smaller than current screen

set -e

# Default: 85% of screen size
SCALE=0.85
WIDTH=""
HEIGHT=""

usage() {
    cat <<EOF
Usage: gshell-nested [OPTIONS]

Launch nested GNOME Shell in a window for extension testing.

Options:
  --res WIDTH HEIGHT    Override window size (e.g., --res 1280 720)
  --fullscreen         Use full screen size (100%)
  --scale PERCENT      Percentage of screen size (default: 85)
  -h, --help           Show this help

Examples:
  gshell-nested                    # Auto-detect at 85% of screen
  gshell-nested --res 1280 720     # Fixed 1280x720 window
  gshell-nested --fullscreen       # Use full screen size
  gshell-nested --scale 90         # 90% of screen size

Notes:
  - Extensions from ~/.local/share/gnome-shell/extensions/ are available
  - Press CTRL+Q or close window to exit nested mode
  - Some features may behave differently than real session
  - Clipboard and notifications work within nested instance
EOF
}

# Parse arguments
while [ $# -gt 0 ]; do
    case "$1" in
        --res)
            WIDTH="$2"
            HEIGHT="$3"
            shift 3
            ;;
        --fullscreen)
            SCALE=1.0
            shift
            ;;
        --scale)
            SCALE=$(echo "scale=2; $2 / 100" | bc)
            shift 2
            ;;
        -h|--help)
            usage
            exit 0
            ;;
        *)
            echo "Error: Unknown option $1" >&2
            usage >&2
            exit 1
            ;;
    esac
done

# If width/height not specified, detect screen size
if [ -z "$WIDTH" ] || [ -z "$HEIGHT" ]; then
    echo "Detecting screen resolution..."

    # Detect display scaling factor first
    SCALING_FACTOR=1
    if command -v gsettings &>/dev/null; then
        # Get GNOME scaling factor - returns "uint32 X" format
        SCALING_OUTPUT=$(gsettings get org.gnome.desktop.interface scaling-factor 2>/dev/null || echo "uint32 0")
        # Extract just the number after "uint32 " using awk
        SCALING_FACTOR=$(echo "$SCALING_OUTPUT" | awk '{print $NF}')

        # Fallback: If scaling-factor is 0, try text-scaling-factor
        if [ -z "$SCALING_FACTOR" ] || [ "$SCALING_FACTOR" -eq 0 ]; then
            SCALING_FACTOR=1
            # Check if fractional scaling is enabled
            TEXT_SCALE=$(gsettings get org.gnome.desktop.interface text-scaling-factor 2>/dev/null || echo "1.0")
            TEXT_SCALE_INT=$(echo "$TEXT_SCALE" | cut -d'.' -f1)
            if [ "$TEXT_SCALE_INT" -ge 2 ]; then
                SCALING_FACTOR=2
            fi
        fi

        echo "Display scaling factor: ${SCALING_FACTOR}x"
    fi

    # Method 1: Try gdbus (GNOME Mutter DisplayConfig - most reliable on GNOME/Wayland)
    if command -v gdbus &>/dev/null; then
        # Query GNOME display configuration
        DISPLAY_INFO=$(gdbus call --session \
            --dest org.gnome.Mutter.DisplayConfig \
            --object-path /org/gnome/Mutter/DisplayConfig \
            --method org.gnome.Mutter.DisplayConfig.GetCurrentState 2>/dev/null || echo "")

        if [ -n "$DISPLAY_INFO" ]; then
            # Parse the complex DBus output - look for current mode dimensions
            # The output contains an array of monitors with modes like: (2560.0, 1600.0, 59.999...)
            # Extract the first double values representing width and height
            # Match pattern: decimal number, comma, space, decimal number at start of tuple
            RESOLUTION=$(echo "$DISPLAY_INFO" | sed -n 's/.*(\([0-9]\+\)\.[0-9]*, \([0-9]\+\)\.[0-9]*.*/\1,\2/p' | head -1)
            if [ -n "$RESOLUTION" ]; then
                WIDTH=$(echo "$RESOLUTION" | cut -d',' -f1)
                HEIGHT=$(echo "$RESOLUTION" | cut -d',' -f2)
                # Divide by scaling factor to get logical resolution
                WIDTH=$(echo "$WIDTH / $SCALING_FACTOR" | bc)
                HEIGHT=$(echo "$HEIGHT / $SCALING_FACTOR" | bc)
                echo "Detected via GNOME DisplayConfig: ${WIDTH}x${HEIGHT} (logical, after ${SCALING_FACTOR}x scaling)"
            fi
        fi
    fi

    # Method 2: Try wlr-randr (Wayland)
    if [ -z "$WIDTH" ] && command -v wlr-randr &>/dev/null; then
        RESOLUTION=$(wlr-randr 2>/dev/null | grep -E '^[[:space:]]+[0-9]+x[0-9]+' | grep '\*' | head -1 | awk '{print $1}')
        if [ -n "$RESOLUTION" ]; then
            WIDTH=$(echo "$RESOLUTION" | cut -d'x' -f1)
            HEIGHT=$(echo "$RESOLUTION" | cut -d'x' -f2)
            # Apply scaling factor
            WIDTH=$(echo "$WIDTH / $SCALING_FACTOR" | bc)
            HEIGHT=$(echo "$HEIGHT / $SCALING_FACTOR" | bc)
            echo "Detected via wlr-randr: ${WIDTH}x${HEIGHT} (logical, after ${SCALING_FACTOR}x scaling)"
        fi
    fi

    # Method 3: Try xrandr (X11 fallback)
    if [ -z "$WIDTH" ] && command -v xrandr &>/dev/null; then
        RESOLUTION=$(xrandr 2>/dev/null | grep '\*' | head -1 | awk '{print $1}')
        if [ -n "$RESOLUTION" ]; then
            WIDTH=$(echo "$RESOLUTION" | cut -d'x' -f1)
            HEIGHT=$(echo "$RESOLUTION" | cut -d'x' -f2)
            # Apply scaling factor
            WIDTH=$(echo "$WIDTH / $SCALING_FACTOR" | bc)
            HEIGHT=$(echo "$HEIGHT / $SCALING_FACTOR" | bc)
            echo "Detected via xrandr: ${WIDTH}x${HEIGHT} (logical, after ${SCALING_FACTOR}x scaling)"
        fi
    fi

    # Fail fast if detection failed
    if [ -z "$WIDTH" ] || [ -z "$HEIGHT" ]; then
        echo "ERROR: Could not detect screen resolution" >&2
        echo "Try running with explicit resolution: gshell-nested --res WIDTH HEIGHT" >&2
        exit 1
    fi

    # Calculate scaled size
    if [ "$SCALE" != "1.0" ]; then
        ORIG_WIDTH=$WIDTH
        ORIG_HEIGHT=$HEIGHT
        WIDTH=$(echo "$WIDTH * $SCALE" | bc | cut -d'.' -f1)
        HEIGHT=$(echo "$HEIGHT * $SCALE" | bc | cut -d'.' -f1)
        PERCENT=$(echo "$SCALE * 100" | bc | cut -d'.' -f1)
        echo "Scaling to ${PERCENT}%: ${WIDTH}x${HEIGHT} (from ${ORIG_WIDTH}x${ORIG_HEIGHT})"
    fi
fi

echo "Starting nested GNOME Shell at ${WIDTH}x${HEIGHT}..."
echo "Press CTRL+Q, CTRL+C, or close window to exit"
echo ""

# Trap signals for clean exit
cleanup() {
    echo ""
    echo "Shutting down nested GNOME Shell..."
    # Kill the nested shell if still running
    if [ -n "$GSHELL_PID" ] && kill -0 "$GSHELL_PID" 2>/dev/null; then
        kill "$GSHELL_PID" 2>/dev/null
        wait "$GSHELL_PID" 2>/dev/null
    fi
    exit 0
}

trap cleanup SIGINT SIGTERM

# Set resolution and launch nested GNOME Shell
MUTTER_DEBUG_DUMMY_MODE_SPECS="${WIDTH}x${HEIGHT}" \
    dbus-run-session -- gnome-shell --nested --wayland &
GSHELL_PID=$!

# Wait for process to exit
wait "$GSHELL_PID"
EXIT_CODE=$?

echo "Nested GNOME Shell exited with code $EXIT_CODE"
exit $EXIT_CODE
